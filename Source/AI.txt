---------------------------------------------------------------------------------------- 
GlobalUsings.cs 
// Global using directives

global using System.Diagnostics.CodeAnalysis;
global using System.Linq;
global using System.Net;
global using System.Net.Http.Json;
global using System.Text;
global using System.Text.Json;
global using System.Text.Json.Serialization;

global using DotNetToolbox.AI.Agents;
global using DotNetToolbox.AI.Chats;
global using DotNetToolbox.AI.Consumers;
global using DotNetToolbox.AI.Personas;
global using DotNetToolbox.AI.Shared;
global using DotNetToolbox.Collections.Generic;
global using DotNetToolbox.Http;
global using DotNetToolbox.Http.Extensions;
global using DotNetToolbox.Results;

global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.DependencyInjection.Extensions;
global using Microsoft.Extensions.Logging;

global using static DotNetToolbox.Ensure;
 
---------------------------------------------------------------------------------------- 
ServiceCollectionExtensions.cs 
﻿namespace DotNetToolbox.AI;

public static class ServiceCollectionExtensions {
    public static IServiceCollection AddAI<THttpProvider, TAgentFactory>(this IServiceCollection services, IConfiguration configuration)
        where THttpProvider : class, IHttpClientProvider
        where TAgentFactory : class, IAgentFactory {
        services.TryAddSingleton<World>();
        services.AddHttpClientProvider<IHttpClientProvider, THttpProvider>(configuration);
        services.TryAddSingleton<IAgentFactory, TAgentFactory>();
        return services;
    }
}
 
---------------------------------------------------------------------------------------- 
Agents\Agent.cs 
﻿namespace DotNetToolbox.AI.Agents;

public abstract class Agent<TAgent, TOptions, TRequest, TResponse>(
        World world,
        TOptions options,
        Persona persona,
        IMapper mapper,
        IHttpClientProvider httpClientProvider,
        ILogger<TAgent> logger)
    : IAgent<TOptions>
    where TAgent : Agent<TAgent, TOptions, TRequest, TResponse>
    where TOptions : class, IAgentOptions, new()
    where TRequest : class, IChatRequest
    where TResponse : class, IChatResponse {
    protected ILogger<TAgent> Logger = logger;

    public World World { get; } = world;
    public TOptions Options { get; set; } = IsValidOrDefault(options, new());
    public Persona Persona { get; } = persona;

    protected virtual Task<bool> IsRequestedCompleted(IConsumer source, IChat chat, CancellationToken ct)
        => Task.FromResult(true);

    public virtual async Task<HttpResult> HandleRequest(IConsumer source, IChat chat, CancellationToken ct) {
        var isCompleted = false;
        while (!isCompleted) {
            Logger.LogDebug("Sending request...");
            var result = await Submit(chat, ct);
            if (!result.IsOk) return result;
            Logger.LogDebug("Response received.");
            isCompleted = await IsRequestedCompleted(source, chat, ct);
        }
        await source.ProcessResponse(chat.Id, chat.Messages[^1], ct);
        Logger.LogDebug("Request completed.");
        return HttpResult.Ok();
    }

    private async Task<HttpResult> Submit(IChat chat, CancellationToken ct = default) {
        var request = mapper.CreateRequest(this, chat);
        var content = JsonContent.Create(request, options: IAgentOptions.SerializerOptions);
        var httpClient = httpClientProvider.GetHttpClient();
        var httpResult = await httpClient.PostAsync(Options.ApiEndpoint, content, ct).ConfigureAwait(false);
        try {
            httpResult.EnsureSuccessStatusCode();
            var json = await httpResult.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
            var apiResponse = JsonSerializer.Deserialize<TResponse>(json, IAgentOptions.SerializerOptions)!;
            var responseMessage = mapper.CreateResponseMessage(chat, apiResponse);
            chat.Messages.Add(responseMessage);
            return HttpResult.Ok();
        }
        catch (Exception ex) {
            Logger.LogWarning(ex, "Request failed!");
            switch (httpResult.StatusCode) {
                case HttpStatusCode.BadRequest:
                    var response = await httpResult.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
                    var errorMessage = $"""
                                        RequestPackage: {JsonSerializer.Serialize(request, IAgentOptions.SerializerOptions)}
                                        ResponseContent: {response};
                                        """;
                    return HttpResult.BadRequest(errorMessage);
                case HttpStatusCode.Unauthorized:
                case HttpStatusCode.Forbidden:
                    return HttpResult.Unauthorized();
                case HttpStatusCode.NotFound:
                    return HttpResult.NotFound();
                default:
                    return HttpResult.InternalError(ex);
            }
        }
    }
}
 
---------------------------------------------------------------------------------------- 
Agents\BackgroundAgent.cs 
﻿namespace DotNetToolbox.AI.Agents;

public abstract class BackgroundAgent<TAgent, TOptions, TRequest, TResponse>(
        World world,
        TOptions options,
        Persona persona,
        IMapper mapper,
        IHttpClientProvider httpClientProvider,
        ILogger<TAgent> logger)
    : Agent<TAgent, TOptions, TRequest, TResponse>(world, options, persona, mapper, httpClientProvider, logger),
      IBackgroundAgent
    where TAgent : BackgroundAgent<TAgent, TOptions, TRequest, TResponse>
    where TOptions : class, IAgentOptions, new()
    where TRequest : class, IChatRequest
    where TResponse : class, IChatResponse {

    // this should be a fire and forget method.
    // Use the cancellation token to stop the agent.
    public async void Run(CancellationToken ct) {
        Logger.LogInformation("Start running...");
        try {
            while (!ct.IsCancellationRequested) {
                await Execute(ct);
                await Task.Delay(100, ct);
            }
        }
        catch (OperationCanceledException ex) {
            Logger.LogWarning(ex, "Running cancellation requested!");
        }
        catch (Exception ex) {
            Logger.LogError(ex, "An error occurred while running the actor!");
            throw;
        }
        Logger.LogInformation("Running stopped.");
    }

    protected virtual Task Execute(CancellationToken token) => Task.CompletedTask;
}
 
---------------------------------------------------------------------------------------- 
Agents\IAgent.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IAgent {
    World World { get; }
    IAgentOptions Options { get; }
    Persona Persona { get; }
    Task<HttpResult> HandleRequest(IConsumer source, IChat chat, CancellationToken ct);
}

public interface IAgent<out TOptions> : IAgent
    where TOptions : class, IAgentOptions, new() {
    IAgentOptions IAgent.Options => Options;
    new TOptions Options { get; }
}
 
---------------------------------------------------------------------------------------- 
Agents\IAgentFactory.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IAgentFactory {
    TAgent CreateAgent<TAgent>(IAgentOptions options, Persona persona)
        where TAgent : class, IAgent;
}
 
---------------------------------------------------------------------------------------- 
Agents\IAgentOptions.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IAgentOptions : IValidatable {
    public static readonly JsonSerializerOptions SerializerOptions = new() {
        WriteIndented = true,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,
        Converters = { new JsonStringEnumConverter(JsonNamingPolicy.SnakeCaseLower) },
    };

    string ApiEndpoint { get; }
    string Model { get; }
}
 
---------------------------------------------------------------------------------------- 
Agents\IBackgroundAgent.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IBackgroundAgent : IAgent {
    void Run(CancellationToken ct);
}
 
---------------------------------------------------------------------------------------- 
Agents\IChatRequest.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IChatRequest;
 
---------------------------------------------------------------------------------------- 
Agents\IChatResponse.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IChatResponse;
 
---------------------------------------------------------------------------------------- 
Agents\IMapper.cs 
﻿
namespace DotNetToolbox.AI.Agents;

public interface IMapper {
    IChatRequest CreateRequest(IAgent agent, IChat chat);
    Message CreateResponseMessage(IChat chat, IChatResponse response);
}
 
---------------------------------------------------------------------------------------- 
Agents\QueuedAgent.cs 
﻿namespace DotNetToolbox.AI.Agents;

public abstract class QueuedAgent<TAgent, TOptions, TRequest, TResponse>(
        World world,
        TOptions options,
        Persona persona,
        IMapper mapper,
        IHttpClientProvider httpClientProvider,
        ILogger<TAgent> logger)
    : BackgroundAgent<TAgent, TOptions, TRequest, TResponse>(world, options, persona, mapper, httpClientProvider, logger)
    where TAgent : QueuedAgent<TAgent, TOptions, TRequest, TResponse>
    where TOptions : class, IAgentOptions, new()
    where TRequest : class, IChatRequest
    where TResponse : class, IChatResponse {
    private readonly Queue<RequestPackage> _receivedRequests = [];

    protected override Task Execute(CancellationToken ct)
        => _receivedRequests.TryDequeue(out var request)
               ? ProcessRequest(request, ct)
               : Task.CompletedTask;

    public override Task<HttpResult> HandleRequest(IConsumer source, IChat chat, CancellationToken ct) {
        var package = new RequestPackage(source, chat);
        _receivedRequests.Enqueue(package);
        return HttpResult.OkTask();
    }

    [SuppressMessage("Performance", "CA1859:Use concrete types when possible for improved performance", Justification = "Irrelevant here.")]
    private Task ProcessRequest(RequestPackage package, CancellationToken ct)
        => base.HandleRequest(package.Source, package.Chat, ct);
}
 
---------------------------------------------------------------------------------------- 
Agents\RequestPackage.cs 
﻿namespace DotNetToolbox.AI.Agents;

public class RequestPackage(IConsumer source, IChat chat) {
    public IConsumer Source { get; } = source;
    public IChat Chat { get; } = chat;
}
 
---------------------------------------------------------------------------------------- 
Agents\ResponsePackage.cs 
﻿namespace DotNetToolbox.AI.Agents;

public class ResponsePackage(string chatId, Message message) {
    public string ChatId { get; } = chatId;
    public Message Message { get; } = message;
}
 
---------------------------------------------------------------------------------------- 
Chats\Chat.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class Chat(
        string id,
        Instructions instructions,
        IEnumerable<Message> messages,
        uint totalTokens = default)
    : IChat {

    public Chat(string id)
        : this(id, new(), []) {
    }

    public Chat(IEnvironment environment)
        : this(environment.Guid.New().ToString(), new(), []) {
    }

    public string Id { get; set; } = id;
    public Instructions Instructions { get; set; } = instructions ?? new();
    public List<Message> Messages { get; set; } = messages?.ToList() ?? [];
    public uint TotalTokens { get; set; } = totalTokens;
}
 
---------------------------------------------------------------------------------------- 
Chats\Example.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class Example {
    public required string Title { get; set; }

    public required string Text { get; init; }

    public override string ToString() => $"{Title}: {Text}";
}
 
---------------------------------------------------------------------------------------- 
Chats\IChat.cs 
﻿namespace DotNetToolbox.AI.Chats;

public interface IChat {
    string Id { get; }
    Instructions Instructions { get; }
    List<Message> Messages { get; }
    uint TotalTokens { get; set; }
}
 
---------------------------------------------------------------------------------------- 
Chats\Instructions.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class Instructions {
    public string Goal { get; set; } = string.Empty;
    public IList<Information> AdditionalInformation { get; } = [];
    public List<Example> Examples { get; set; } = [];

    public override string ToString() {
        var builder = new StringBuilder();
        builder.AppendLine(Goal);
        if (Examples.Count > 0) builder.AppendLine("Examples:");
        foreach (var example in Examples)
            builder.AppendLine(example.ToString());
        if (AdditionalInformation.Count > 0) builder.AppendLine("Additional information:");
        foreach (var value in AdditionalInformation)
            builder.AppendLine(value.ToString());
        return builder.ToString();
    }
}
 
---------------------------------------------------------------------------------------- 
Chats\Message.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class Message(string source, MessagePart[] parts) {
    public Message(string source, string message)
        : this(source, [new MessagePart("text", message)]) {
    }

    public string Role { get; set; } = source;
    public MessagePart[] Parts { get; set; } = parts;
}
 
---------------------------------------------------------------------------------------- 
Chats\MessagePart.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class MessagePart(string type, object value) {
    public string Type { get; set; } = type;
    public object Value { get; set; } = value;
}
 
---------------------------------------------------------------------------------------- 
Consumers\Consumer.cs 
﻿namespace DotNetToolbox.AI.Consumers;

public abstract class Consumer<TConsumer>(IChat chat, ILogger<TConsumer> logger)
    : IConsumer
    where TConsumer : Consumer<TConsumer> {

    public IChat Chat { get; } = chat;
    protected ILogger<TConsumer> Logger = logger;

    public virtual async Task ProcessResponse(string chatId, Message response, CancellationToken ct) {
        if (ct.IsCancellationRequested) return;
        if (Chat?.Id != chatId) return;
        Logger.LogDebug("Response received...");
        await ProcessResponse(response, ct);
        Logger.LogDebug("Request completed.");
    }

    protected abstract Task ProcessResponse(Message response, CancellationToken ct);
}
 
---------------------------------------------------------------------------------------- 
Consumers\IConsumer.cs 
﻿namespace DotNetToolbox.AI.Consumers;

public interface IConsumer {
    Task ProcessResponse(string chatId, Message response, CancellationToken ct);
}
 
---------------------------------------------------------------------------------------- 
Models\IModelsHandler.cs 
﻿namespace DotNetToolbox.AI.Models;

public interface IModelsHandler
    : IModelsHandler<string>;

/// <summary>
/// This class contains methods for handling models using OpenAI.
/// </summary>
/// <remarks>
/// This class is responsible for handling models using OpenAI. It contains methods for getting a list of models, getting a model by ID, and deleting a model. It also includes a detailed XML documentation for each method.
/// </remarks>
public interface IModelsHandler<TModel> {
    /// <summary>
    /// Gets a list of models ids of the specified type.
    /// </summary>
    /// <param name="type">The type of the models to get.</param>
    /// <returns>An array of strings with the ids of models of the specified type.</returns>
    /// <remarks>
    /// This method gets a list of model's id of the specified type from the OpenAI API.
    /// </remarks>
    Task<string[]> GetIds(string? type = null);
}
 
---------------------------------------------------------------------------------------- 
Personas\IPersona.cs 
﻿//namespace DotNetToolbox.AI.Personas;

//public interface Persona {
//    string Name { get; }
//    string? Description { get; }
//    Profile Profile { get; }
//    List<Skill> Skills { get; }
//}
 
---------------------------------------------------------------------------------------- 
Personas\Persona.cs 
﻿namespace DotNetToolbox.AI.Personas;

[method: JsonConstructor]
public class Persona(Profile? profile = null, List<Skill>? skills = null) {

    public Persona(string name, string? description = null, Profile? profile = null, List<Skill>? skills = null)
        : this(profile, skills) {
        Name = IsNotNull(name);
        Description = description;
    }

    public string Name { get; set; } = "Agent";
    public string? Description { get; set; }
    public Profile Profile { get; set; } = profile ?? new();
    public List<Skill> Skills { get; set; } = skills ?? [];
}
 
---------------------------------------------------------------------------------------- 
Personas\Profile.cs 
﻿namespace DotNetToolbox.AI.Personas;

public class Profile {
    public string Description { get; init; } = "You are a helpful agent.";
    public string Personality { get; init; } = string.Empty;
    public List<string> Instructions { get; set; } = [];
    public List<Information> AdditionalInformation { get; } = [];
    public List<Skill> Skills { get; set; } = [];

    public override string ToString() {
        var builder = new StringBuilder();
        builder.AppendLine(Description);
        if (!string.IsNullOrWhiteSpace(Personality)) builder.AppendLine(Personality);
        if (Instructions.Count > 0) builder.AppendLine("Instructions:");
        foreach (var instruction in Instructions)
            builder.AppendLine(instruction);
        if (Skills.Count > 0) builder.AppendLine("Your skills are:");
        foreach (var skill in Skills)
            builder.AppendLine(skill.ToString());
        if (AdditionalInformation.Count > 0) builder.AppendLine("Additional information;");
        foreach (var information in AdditionalInformation)
            builder.AppendLine(information.ToString());
        return builder.ToString();
    }
}
 
---------------------------------------------------------------------------------------- 
Shared\Argument.cs 
﻿namespace DotNetToolbox.AI.Shared;

public class Argument {
    public required string Name { get; set; }
    public required string Type { get; set; }
    public string? Description { get; set; }
    public string[]? Options { get; set; } = [];
    public bool IsRequired { get; set; }
}
 
---------------------------------------------------------------------------------------- 
Shared\Information.cs 
﻿namespace DotNetToolbox.AI.Shared;

public class Information : IValidatableAsync {
    public string? Value { get; set; }

    [StringSyntax(StringSyntaxAttribute.CompositeFormat)]
    public required string ValueTemplate { get; set; }

    public required string DefaultText { get; set; }

    public Task<Result> Validate(IDictionary<string, object?>? context = null, CancellationToken token = default)
        => Result.SuccessTask();

    public override string ToString()
        => string.IsNullOrWhiteSpace(Value)
               ? DefaultText
               : string.Format(ValueTemplate, Value);
}
 
---------------------------------------------------------------------------------------- 
Shared\Skill.cs 
﻿namespace DotNetToolbox.AI.Shared;

public class Skill
    : IValidatable {
    public required int Id { get; set; }
    public required string Name { get; set; }
    public string? Description { get; set; }
    public List<Argument> Arguments { get; set; } = [];

    public override string ToString() {
        var builder = new StringBuilder();
        builder.Append($"{Id}. {Name}: '{Description}'");
        if (Arguments.Count > 0) {
            builder.AppendLine();
            builder.Append("Arguments:");
            for (var index = 0; index < Arguments.Count; index++) {
                builder.AppendLine();
                var argument = Arguments[index];
                builder.Append("   ");
                if (!argument.IsRequired) builder.Append('[');
                if (index > 0) builder.Append(", ");
                builder.Append($"{index}. {argument.Type} {argument.Name}");
                if (argument.Options?.Length > 0)
                    builder.Append($" in {{{string.Join('|', argument.Options)}}}");
                if (Description is not null) builder.Append(" '{argument.Description}'");
                if (!argument.IsRequired) builder.Append(']');
            }
        }
        builder.AppendLine(";");
        return builder.ToString();
    }

    public Result Validate(IDictionary<string, object?>? context = null)
        => Result.Success();

}
 
---------------------------------------------------------------------------------------- 
Shared\World.cs 
﻿namespace DotNetToolbox.AI.Shared;

public class World(IDateTimeProvider? dateTime = null)
    : IValidatable {
    public DateTimeOffset DateTime => dateTime?.Now ?? DateTimeOffset.Now;
    public int Id { get; set; }
    public string? Location { get; set; } = string.Empty;
    public string? UserProfile { get; set; } = string.Empty;
    public List<Information> AdditionalInformation { get; set; } = [];
    public List<Skill> Skills { get; set; } = [];

    public IDateTimeProvider? GetProvider() => dateTime;

    public override string ToString() {
        var builder = new StringBuilder();
        builder.AppendLine($"The current date time is {DateTime}.");
        if (string.IsNullOrWhiteSpace(Location)) builder.AppendLine("You do not know your current location.");
        else builder.AppendLine($"You are located at '{Location}'.");
        if (string.IsNullOrWhiteSpace(UserProfile)) builder.AppendLine("You do not know the name of the user.");
        else builder.AppendLine($"The name of the user is '{Location}'.");
        if (AdditionalInformation.Count > 0) builder.AppendLine("Additional information;");
        foreach (var information in AdditionalInformation)
            builder.AppendLine(information.ToString());
        return builder.ToString();
    }

    public Result Validate(IDictionary<string, object?>? context = null)
        => Result.Success();
}
 
