---------------------------------------------------------------------------------------- 
GlobalUsings.cs 
// Global using directives

global using System.Diagnostics.CodeAnalysis;
global using System.Linq;
global using System.Net;
global using System.Net.Http.Json;
global using System.Runtime.CompilerServices;
global using System.Text;
global using System.Text.Json;
global using System.Text.Json.Serialization;

global using DotNetToolbox.AI.Agents;
global using DotNetToolbox.AI.Chats;
global using DotNetToolbox.AI.Common;
global using DotNetToolbox.AI.Consumers;
global using DotNetToolbox.AI.Extensions;
global using DotNetToolbox.AI.Personas;
global using DotNetToolbox.Collections.Generic;
global using DotNetToolbox.Extensions;
global using DotNetToolbox.Http;
global using DotNetToolbox.Http.Extensions;
global using DotNetToolbox.Results;

global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.DependencyInjection.Extensions;
global using Microsoft.Extensions.Logging;

global using static DotNetToolbox.Ensure;
 
---------------------------------------------------------------------------------------- 
ServiceCollectionExtensions.cs 
﻿namespace DotNetToolbox.AI;

public static class ServiceCollectionExtensions {
    public static IServiceCollection AddAI<THttpProvider, TAgentFactory>(this IServiceCollection services, IConfiguration configuration)
        where THttpProvider : class, IHttpClientProvider
        where TAgentFactory : class, IAgentFactory {
        services.TryAddSingleton<World>();
        services.AddHttpClientProvider<IHttpClientProvider, THttpProvider>(configuration);
        services.TryAddSingleton<IAgentFactory, TAgentFactory>();
        return services;
    }
}
 
---------------------------------------------------------------------------------------- 
Agents\Agent.cs 
﻿namespace DotNetToolbox.AI.Agents;

public abstract class Agent<TAgent, TOptions, TRequest, TResponse>(
        World world,
        TOptions options,
        Persona persona,
        IMapper mapper,
        IHttpClientProvider httpClientProvider,
        ILogger<TAgent> logger)
    : IAgent<TOptions>
    where TAgent : Agent<TAgent, TOptions, TRequest, TResponse>
    where TOptions : class, IAgentOptions, new()
    where TRequest : class, IChatRequest
    where TResponse : class, IChatResponse {
    protected ILogger<TAgent> Logger = logger;

    public World World { get; } = world;
    public TOptions Options { get; set; } = IsValidOrDefault(options, new());
    public Persona Persona { get; } = persona;

    protected virtual Task<bool> IsRequestedCompleted(IConsumer source, IChat chat, CancellationToken ct)
        => Task.FromResult(true);

    public virtual async Task<HttpResult> HandleRequest(IConsumer source, IChat chat, CancellationToken ct) {
        var isCompleted = false;
        while (!isCompleted) {
            Logger.LogDebug("Sending request...");
            var result = await Submit(chat, ct);
            if (!result.IsOk) return result;
            Logger.LogDebug("Response received.");
            isCompleted = await IsRequestedCompleted(source, chat, ct);
        }
        await source.ProcessResponse(chat.Id, chat.Messages[^1], ct);
        Logger.LogDebug("Request completed.");
        return HttpResult.Ok();
    }

    private async Task<HttpResult> Submit(IChat chat, CancellationToken ct = default) {
        var request = mapper.CreateRequest(this, chat);
        var content = JsonContent.Create(request, options: IAgentOptions.SerializerOptions);
        var httpClient = httpClientProvider.GetHttpClient();
        var httpResult = await httpClient.PostAsync(Options.ApiEndpoint, content, ct).ConfigureAwait(false);
        try {
            httpResult.EnsureSuccessStatusCode();
            var json = await httpResult.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
            var apiResponse = JsonSerializer.Deserialize<TResponse>(json, IAgentOptions.SerializerOptions)!;
            var responseMessage = mapper.CreateResponseMessage(chat, apiResponse);
            chat.Messages.Add(responseMessage);
            return HttpResult.Ok();
        }
        catch (Exception ex) {
            Logger.LogWarning(ex, "Request failed!");
            switch (httpResult.StatusCode) {
                case HttpStatusCode.BadRequest:
                    var response = await httpResult.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
                    var errorMessage = $"""
                                        RequestPackage: {JsonSerializer.Serialize(request, IAgentOptions.SerializerOptions)}
                                        ResponseContent: {response};
                                        """;
                    return HttpResult.BadRequest(errorMessage);
                case HttpStatusCode.Unauthorized:
                case HttpStatusCode.Forbidden:
                    return HttpResult.Unauthorized();
                case HttpStatusCode.NotFound:
                    return HttpResult.NotFound();
                default:
                    return HttpResult.InternalError(ex);
            }
        }
    }
}
 
---------------------------------------------------------------------------------------- 
Agents\BackgroundAgent.cs 
﻿namespace DotNetToolbox.AI.Agents;

public abstract class BackgroundAgent<TAgent, TOptions, TRequest, TResponse>(
        World world,
        TOptions options,
        Persona persona,
        IMapper mapper,
        IHttpClientProvider httpClientProvider,
        ILogger<TAgent> logger)
    : Agent<TAgent, TOptions, TRequest, TResponse>(world, options, persona, mapper, httpClientProvider, logger),
      IBackgroundAgent
    where TAgent : BackgroundAgent<TAgent, TOptions, TRequest, TResponse>
    where TOptions : class, IAgentOptions, new()
    where TRequest : class, IChatRequest
    where TResponse : class, IChatResponse {

    // this should be a fire and forget method.
    // Use the cancellation token to stop the agent.
    public async void Run(CancellationToken ct) {
        Logger.LogInformation("Start running...");
        try {
            while (!ct.IsCancellationRequested) {
                await Execute(ct);
                await Task.Delay(100, ct);
            }
        }
        catch (OperationCanceledException ex) {
            Logger.LogWarning(ex, "Running cancellation requested!");
        }
        catch (Exception ex) {
            Logger.LogError(ex, "An error occurred while running the actor!");
            throw;
        }
        Logger.LogInformation("Running stopped.");
    }

    protected virtual Task Execute(CancellationToken token) => Task.CompletedTask;
}
 
---------------------------------------------------------------------------------------- 
Agents\IAgent.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IAgent {
    World World { get; }
    IAgentOptions Options { get; }
    Persona Persona { get; }
    Task<HttpResult> HandleRequest(IConsumer source, IChat chat, CancellationToken ct);
}

public interface IAgent<out TOptions> : IAgent
    where TOptions : class, IAgentOptions, new() {
    IAgentOptions IAgent.Options => Options;
    new TOptions Options { get; }
}
 
---------------------------------------------------------------------------------------- 
Agents\IAgentFactory.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IAgentFactory {
    TAgent CreateAgent<TAgent>(IAgentOptions options, Persona persona)
        where TAgent : class, IAgent;
}
 
---------------------------------------------------------------------------------------- 
Agents\IAgentOptions.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IAgentOptions : IValidatable {
    public static readonly JsonSerializerOptions SerializerOptions = new() {
        WriteIndented = true,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,
        Converters = { new JsonStringEnumConverter(JsonNamingPolicy.SnakeCaseLower) },
    };

    string ApiEndpoint { get; }
    string Model { get; }
}
 
---------------------------------------------------------------------------------------- 
Agents\IBackgroundAgent.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IBackgroundAgent : IAgent {
    void Run(CancellationToken ct);
}
 
---------------------------------------------------------------------------------------- 
Agents\IChatRequest.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IChatRequest;
 
---------------------------------------------------------------------------------------- 
Agents\IChatResponse.cs 
﻿namespace DotNetToolbox.AI.Agents;

public interface IChatResponse;
 
---------------------------------------------------------------------------------------- 
Agents\IMapper.cs 
﻿
namespace DotNetToolbox.AI.Agents;

public interface IMapper {
    IChatRequest CreateRequest(IAgent agent, IChat chat);
    Message CreateResponseMessage(IChat chat, IChatResponse response);
}
 
---------------------------------------------------------------------------------------- 
Agents\QueuedAgent.cs 
﻿namespace DotNetToolbox.AI.Agents;

public abstract class QueuedAgent<TAgent, TOptions, TRequest, TResponse>(
        World world,
        TOptions options,
        Persona persona,
        IMapper mapper,
        IHttpClientProvider httpClientProvider,
        ILogger<TAgent> logger)
    : BackgroundAgent<TAgent, TOptions, TRequest, TResponse>(world, options, persona, mapper, httpClientProvider, logger)
    where TAgent : QueuedAgent<TAgent, TOptions, TRequest, TResponse>
    where TOptions : class, IAgentOptions, new()
    where TRequest : class, IChatRequest
    where TResponse : class, IChatResponse {
    private readonly Queue<RequestPackage> _receivedRequests = [];

    protected override Task Execute(CancellationToken ct)
        => _receivedRequests.TryDequeue(out var request)
               ? ProcessRequest(request, ct)
               : Task.CompletedTask;

    public override Task<HttpResult> HandleRequest(IConsumer source, IChat chat, CancellationToken ct) {
        var package = new RequestPackage(source, chat);
        _receivedRequests.Enqueue(package);
        return HttpResult.OkTask();
    }

    [SuppressMessage("Performance", "CA1859:Use concrete types when possible for improved performance", Justification = "Irrelevant here.")]
    private Task ProcessRequest(RequestPackage package, CancellationToken ct)
        => base.HandleRequest(package.Source, package.Chat, ct);
}
 
---------------------------------------------------------------------------------------- 
Agents\RequestPackage.cs 
﻿namespace DotNetToolbox.AI.Agents;

public class RequestPackage(IConsumer source, IChat chat) {
    public IConsumer Source { get; } = source;
    public IChat Chat { get; } = chat;
}
 
---------------------------------------------------------------------------------------- 
Agents\ResponsePackage.cs 
﻿namespace DotNetToolbox.AI.Agents;

public class ResponsePackage(string chatId, Message message) {
    public string ChatId { get; } = chatId;
    public Message Message { get; } = message;
}
 
---------------------------------------------------------------------------------------- 
Chats\Chat.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class Chat(
        string id,
        Instructions instructions,
        IEnumerable<Message> messages,
        uint totalTokens = default)
    : IChat {

    public Chat(string id)
        : this(id, new(), []) {
    }

    public Chat(IEnvironment environment)
        : this(environment.Guid.New().ToString(), new(), []) {
    }

    public string Id { get; set; } = id;
    public Instructions Instructions { get; set; } = instructions ?? new();
    public List<Message> Messages { get; set; } = messages?.ToList() ?? [];
    public uint TotalTokens { get; set; } = totalTokens;
}
 
---------------------------------------------------------------------------------------- 
Chats\Example.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class Example {
    public required string Title { get; set; }

    public required string Text { get; init; }

    public override string ToString() => $"{Title}: {Text}";
}
 
---------------------------------------------------------------------------------------- 
Chats\IChat.cs 
﻿namespace DotNetToolbox.AI.Chats;

public interface IChat {
    string Id { get; }
    Instructions Instructions { get; }
    List<Message> Messages { get; }
    uint TotalTokens { get; set; }
}
 
---------------------------------------------------------------------------------------- 
Chats\Instructions.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class Instructions {
    public string[] Goals { get; set; } = [];
    public string[] AcceptanceCriteria { get; set; } = [];
    public string[] Requirements { get; set; } = [];
    public string[] Assumptions { get; set; } = [];
    public string[] Constraints { get; set; } = [];
    public List<Example> Examples { get; set; } = [];
    public List<Fact> Facts { get; set; } = [];

    public override string ToString() {
        var builder = new StringBuilder();
        builder.AppendSection(Goals);
        builder.AppendSection(AcceptanceCriteria, "Acceptance Criteria");
        builder.AppendSection(Assumptions);
        builder.AppendSection(Requirements);
        builder.AppendSection(Constraints);
        builder.AppendSection(Examples);
        builder.AppendSection(Facts);
        return builder.ToString();
    }
}
 
---------------------------------------------------------------------------------------- 
Chats\Message.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class Message(string source, MessagePart[] parts) {
    public Message(string source, string message)
        : this(source, [new MessagePart("text", message)]) {
    }

    public string Role { get; set; } = source;
    public MessagePart[] Parts { get; set; } = parts;
}
 
---------------------------------------------------------------------------------------- 
Chats\MessagePart.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class MessagePart(string type, object value) {
    public string Type { get; set; } = type;
    public object Value { get; set; } = value;
}
 
---------------------------------------------------------------------------------------- 
Common\Argument.cs 
﻿namespace DotNetToolbox.AI.Common;

public class Argument {
    public required int Index { get; set; }
    public required string Name { get; set; }
    public required ArgumentType Type { get; set; }
    public string? Description { get; set; }
    public string[]? Options { get; set; } = [];
    public bool IsRequired { get; set; }

    public override string ToString() {
        var builder = new StringBuilder();
        builder.Append($"{Index}: ");
        if (!IsRequired) builder.Append('[');
        builder.Append($"{Name}: <{Type}>");
        if (Options?.Length > 0)
            builder.Append($" in {{{string.Join('|', Options)}}}");
        if (!IsRequired) builder.Append(']');
        if (Description is not null) builder.Append($" '{Description}'");
        return builder.ToString();
    }
}
 
---------------------------------------------------------------------------------------- 
Common\ArgumentType.cs 
﻿namespace DotNetToolbox.AI.Common;

public enum ArgumentType {
    Text = 0,
    Number = 1,
    Flag = 2,
    DateTime = 3,
    Enum = 4,
}
 
---------------------------------------------------------------------------------------- 
Common\Fact.cs 
﻿namespace DotNetToolbox.AI.Common;

public class Fact : IValidatableAsync {
    public string? Value { get; set; }

    [StringSyntax(StringSyntaxAttribute.CompositeFormat)]
    public required string ValueTemplate { get; set; }

    public required string DefaultText { get; set; }

    public Task<Result> Validate(IDictionary<string, object?>? context = null, CancellationToken token = default)
        => Result.SuccessTask();

    public override string ToString()
        => string.IsNullOrWhiteSpace(Value)
               ? DefaultText
               : string.Format(ValueTemplate, Value);
}
 
---------------------------------------------------------------------------------------- 
Common\Tool.cs 
﻿namespace DotNetToolbox.AI.Common;

public class Tool
    : IValidatable {
    public required int Id { get; set; }
    public required string Name { get; set; }
    public string? Description { get; set; }
    public List<Argument> Arguments { get; set; } = [];

    public override string ToString() {
        var builder = new StringBuilder();
        builder.Append($"{Id}. {Name}: '{Description}'");
        builder.AppendSection("    ", Arguments);
        return builder.ToString();
    }

    public Result Validate(IDictionary<string, object?>? context = null)
        => Result.Success();
}
 
---------------------------------------------------------------------------------------- 
Common\UserProfile.cs 
﻿namespace DotNetToolbox.AI.Common;

public class UserProfile {
    public string? Name { get; set; }
    public string? Language { get; set; }

    public override string ToString() {
        var builder = new StringBuilder();
        if (!string.IsNullOrWhiteSpace(Name)) builder.Append($"The USER name is {Name}.");
        if (!string.IsNullOrWhiteSpace(Language)) builder.AppendIntoNewLine($"The USER preferred language is {Language}.");
        return builder.ToString();
    }
}
 
---------------------------------------------------------------------------------------- 
Common\World.cs 
﻿namespace DotNetToolbox.AI.Common;

public class World(IDateTimeProvider? dateTimeProvider = null)
    : IValidatable {
    public IDateTimeProvider DateTimeProvider { get; } = dateTimeProvider ?? new DateTimeProvider();
    public DateTimeOffset DateTime => DateTimeProvider.Now;
    public int Id { get; set; }
    public string? Location { get; set; } = string.Empty;
    public UserProfile UserProfile { get; set; } = new();
    public List<Fact> Facts { get; set; } = [];
    public List<Tool> AvailableTools { get; set; } = [];

    public override string ToString() {
        var builder = new StringBuilder();
        builder.Append($"The current local date is {DateTime.Date:dddd}, {DateTime.Date} and the time is {DateTime.TimeOfDay:HH:mm:ss} ({DateTime:K}).");
        builder.AppendIntoNewLine(GetAgentLocation(Location));
        builder.AppendIntoNewLine(UserProfile.ToString());
        builder.AppendSection(Facts);
        return builder.ToString();
    }

    private string GetUserProfile(string? profile)
        => string.IsNullOrWhiteSpace(profile)
               ? "You have no information about the USER."
               : profile;

    private static string GetAgentLocation(string? location)
        => string.IsNullOrWhiteSpace(location)
               ? "You do not know your current location."
               : $"You are located at {location}.";

    public Result Validate(IDictionary<string, object?>? context = null)
        => Result.Success();
}
 
---------------------------------------------------------------------------------------- 
Consumers\Consumer.cs 
﻿namespace DotNetToolbox.AI.Consumers;

public abstract class Consumer<TConsumer>(IChat chat, ILogger<TConsumer> logger)
    : IConsumer
    where TConsumer : Consumer<TConsumer> {

    public IChat Chat { get; } = chat;
    protected ILogger<TConsumer> Logger = logger;

    public virtual async Task ProcessResponse(string chatId, Message response, CancellationToken ct) {
        if (ct.IsCancellationRequested) return;
        if (Chat?.Id != chatId) return;
        Logger.LogDebug("Response received...");
        await ProcessResponse(response, ct);
        Logger.LogDebug("Request completed.");
    }

    protected abstract Task ProcessResponse(Message response, CancellationToken ct);
}
 
---------------------------------------------------------------------------------------- 
Consumers\IConsumer.cs 
﻿namespace DotNetToolbox.AI.Consumers;

public interface IConsumer {
    Task ProcessResponse(string chatId, Message response, CancellationToken ct);
}
 
---------------------------------------------------------------------------------------- 
Extensions\StringBuilderExtensions.cs 
﻿namespace DotNetToolbox.AI.Extensions;
internal static class StringBuilderExtensions {
    public static void AppendSection<TItem>(this StringBuilder builder, ICollection<TItem> items, [CallerArgumentExpression(nameof(items))]string? paramName = null)
        => builder.AppendSection(string.Empty, items, paramName);

    public static void AppendSection<TItem>(this StringBuilder builder, string ident, ICollection<TItem> items, [CallerArgumentExpression(nameof(items))] string? paramName = null) {
        if (items.Count == 0) return;
        builder.AppendIntoNewLine($"{ident}{paramName}");
        foreach (var item in items)
            builder.AppendIntoNewLine($"{ident}{item}");
    }
}
 
---------------------------------------------------------------------------------------- 
Models\IModelsHandler.cs 
﻿namespace DotNetToolbox.AI.Models;

public interface IModelsHandler
    : IModelsHandler<string>;

/// <summary>
/// This class contains methods for handling models using OpenAI.
/// </summary>
/// <remarks>
/// This class is responsible for handling models using OpenAI. It contains methods for getting a list of models, getting a model by ID, and deleting a model. It also includes a detailed XML documentation for each method.
/// </remarks>
public interface IModelsHandler<TModel> {
    /// <summary>
    /// Gets a list of models ids of the specified type.
    /// </summary>
    /// <param name="type">The type of the models to get.</param>
    /// <returns>An array of strings with the ids of models of the specified type.</returns>
    /// <remarks>
    /// This method gets a list of model's id of the specified type from the OpenAI API.
    /// </remarks>
    Task<string[]> GetIds(string? type = null);
}
 
---------------------------------------------------------------------------------------- 
Personas\Persona.cs 
﻿namespace DotNetToolbox.AI.Personas;

[method: JsonConstructor]
public class Persona() {

    public Persona(string name)
        : this() {
        Name = IsNotNull(name);
    }

    public string Name { get; set; } = "Agent";
    public string Description { get; set; } = "You are a helpful agent.";
    public string? Personality { get; set; }
    public List<string> Instructions { get; set; } = [];
    public List<Fact> Facts { get; set; } = [];
    public List<Tool> KnownTools { get; set; } = [];

    public override string ToString() {
        var builder = new StringBuilder();
        builder.AppendLine($"You name is {Name}.");
        builder.AppendLine(Description);
        if (!string.IsNullOrWhiteSpace(Personality)) builder.AppendLine(Personality);
        builder.AppendSection(KnownTools, "Known Tools");
        builder.AppendSection(Facts);
        builder.AppendSection(Instructions);
        return builder.ToString();
    }
}
 
