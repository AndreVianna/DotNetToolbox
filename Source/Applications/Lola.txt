LolaSettings.cs 
namespace Lola;

public class LolaSettings
    : ApplicationSettings {
    public string DefaultAIProvider { get; set; } = string.Empty;
    public string[] AvailableModels { get; set; } = [];
    public string CurrentAgentKey { get; set; } = string.Empty;
}
 
---------------------------------------------------------------------------------------- 
LolaShellApplication.cs 
namespace Lola;

public class LolaShellApplication
        : ShellApplication<LolaShellApplication, LolaSettings> {
    private readonly Lazy<IUserProfileHandler> _userHandler;
    private readonly ILogger<LolaShellApplication> _logger;

    public LolaShellApplication(string[] args, IServiceCollection services, Lazy<IUserProfileHandler> userHandler, ILogger<LolaShellApplication> logger)
        : base(args, services) {
        _userHandler = userHandler;
        _logger = logger;
        AddCommand<HelpCommand>();
        AddCommand<SettingsCommand>();
        AddCommand<ProvidersCommand>();
        AddCommand<ModelsCommand>();
        if (_userHandler.Value.CurrentUser is not null) AddCommand<UserProfileCommand>();
        AddCommand<PersonasCommand>();
        AddCommand<TasksCommand>();
    }

    protected override async Task<Result> OnStart(CancellationToken ct = default) {
        _logger.LogInformation("Starting Lola application...");
        var header = new FigletText($"{Name} {DisplayVersion}").LeftJustified().Color(Color.Fuchsia);
        Output.Write(header);

        var user = _userHandler.Value.CurrentUser;
        return user is not null ? SaluteUser(user) : await RegisterUser(ct);
    }

    protected override Result OnExit() {
        AnsiConsole.MarkupLine("[green]Thank you for using Lola. Goodbye![/]");
        return Result.Success();
    }

    protected override Task<Result> ProcessInteraction(CancellationToken ct = default) {
        _logger.LogInformation("Executing default command...");
        var choice = Input.BuildSelectionPrompt<string>("What would you like to do?")
                          .ConvertWith(MapTo)
                          .AddChoices("Providers",
                                      "Models",
                                      "Personas",
                                      "Tasks",
                                      "UserProfile",
                                      "Settings",
                                      "Help",
                                      "Exit").Show();

        return ProcessCommand(choice, ct);

        static string MapTo(string choice) => choice switch {
            "Providers" => "Manage Providers",
            "Models" => "Manage Models",
            "Personas" => "Manage Personas",
            "Tasks" => "Manage Tasks",
            "UserProfile" => "Manage User Profile",
            "Settings" => "Settings",
            "Help" => "Help",
            "Exit" => "Exit",
            _ => string.Empty,
        };
    }

    protected override Task<Result> ProcessCommand(string[] input, CancellationToken ct) {
        _logger.LogInformation("Processing command: '{Command}'...", string.Join(" ", input));
        return base.ProcessCommand(input, ct);
    }

    protected override bool HandleException<TException>(TException ex) {
        _logger.LogError(ex, "An error occurred while executing the app.");
        return base.HandleException(ex);
    }

    private Result SaluteUser(UserProfileEntity user) {
        Output.WriteLine($"[Green]Hi {user.Name}! Welcome back.[/]");
        Output.WriteLine();
        return Result.Success();
    }

    private Task<Result> RegisterUser(CancellationToken ct = default) {
        Output.WriteLine($"[bold]Welcome to {Name}, your AI assisted shell![/]");
        Output.WriteLine();
        var command = new UserProfileSetCommand(this, _userHandler.Value);
        Output.WriteLine("[bold][Yellow]Hi![/] It seems that is the first time that I see you around here.[/]");
        return command.Execute([], ct);
    }
}
 
---------------------------------------------------------------------------------------- 
Program.cs 
using Lola.Utilities.HttpConnection.Handlers;

var app = LolaShellApplication.Create(args, cb => {
    cb.AddAppSettings(); // This will add the values from appsettings.json to the context
    cb.AddUserSecrets<Program>(); // This will add the values from the user secrets to the context
}, ab => {
    ab.ConfigureLogging((loggingBuilder) => {
        var logPath = Path.Combine("logs", "lola-.log");
        Log.Logger = new LoggerConfiguration()
                    .ReadFrom.Configuration(ab.Configuration)
                    .Enrich.FromLogContext()
                    .WriteTo.File(logPath,
                                  fileSizeLimitBytes: 5 * 1024 * 1024,
                                  rollingInterval: RollingInterval.Day,
                                  retainedFileCountLimit: 7) // 5MB file size limit
                    .CreateLogger();

        loggingBuilder.AddSerilog(dispose: true);
    });
    ab.SetOutputHandler(new ConsoleOutput());
    ab.SetInputHandler(new ConsoleInput());
    ab.Services.Configure<LolaSettings>(ab.Configuration.GetSection("Lola"));
    ab.Services.AddOptions<LolaSettings>();

    ab.Services.AddOpenAI();
    ab.Services.AddAnthropic();

    ab.Services.AddScoped<IHttpConnectionHandler, HttpConnectionHandler>();
    ab.Services.AddScoped(p => new Lazy<IHttpConnectionHandler>(p.GetRequiredService<IHttpConnectionHandler>));

    ab.Services.AddSingleton<IUserProfileStorage, UserProfileStorage>();
    ab.Services.AddScoped<IUserProfileDataSource, UserProfileDataSource>();
    ab.Services.AddScoped<IUserProfileHandler, UserProfileHandler>();
    ab.Services.AddScoped(p => new Lazy<IUserProfileDataSource>(p.GetRequiredService<IUserProfileDataSource>));
    ab.Services.AddScoped(p => new Lazy<IUserProfileHandler>(p.GetRequiredService<IUserProfileHandler>));

    ab.Services.AddSingleton<IProviderStorage, ProviderStorage>();
    ab.Services.AddScoped<IProviderDataSource, ProviderDataSource>();
    ab.Services.AddScoped<IProviderHandler, ProviderHandler>();
    ab.Services.AddScoped(p => new Lazy<IProviderDataSource>(p.GetRequiredService<IProviderDataSource>));
    ab.Services.AddScoped(p => new Lazy<IProviderHandler>(p.GetRequiredService<IProviderHandler>));

    ab.Services.AddSingleton<IModelStorage, ModelStorage>();
    ab.Services.AddScoped<IModelDataSource, ModelDataSource>();
    ab.Services.AddScoped<IModelHandler, ModelHandler>();
    ab.Services.AddScoped(p => new Lazy<IModelDataSource>(p.GetRequiredService<IModelDataSource>));
    ab.Services.AddScoped(p => new Lazy<IModelHandler>(p.GetRequiredService<IModelHandler>));

    ab.Services.AddSingleton<IPersonaStorage, PersonaStorage>();
    ab.Services.AddScoped<IPersonaDataSource, PersonaDataSource>();
    ab.Services.AddScoped<IPersonaHandler, PersonaHandler>();
    ab.Services.AddScoped(p => new Lazy<IPersonaDataSource>(p.GetRequiredService<IPersonaDataSource>));
    ab.Services.AddScoped(p => new Lazy<IPersonaHandler>(p.GetRequiredService<IPersonaHandler>));

    ab.Services.AddSingleton<ITaskStorage, TaskStorage>();
    ab.Services.AddScoped<ITaskDataSource, TaskDataSource>();
    ab.Services.AddScoped<ITaskHandler, TaskHandler>();
    ab.Services.AddScoped(p => new Lazy<ITaskDataSource>(p.GetRequiredService<ITaskDataSource>));
    ab.Services.AddScoped(p => new Lazy<ITaskHandler>(p.GetRequiredService<ITaskHandler>));
});

try {
    await app.RunAsync();
}
finally {
    Log.CloseAndFlush();
}
 
---------------------------------------------------------------------------------------- 
appsettings.json 
{
  "Lola": {
    "DefaultAIProvider": "Anthropic",
    "AvailableModels": [
      "claude-3-5-sonnet-20240620",
      "claude-3-haiku-20240307"
    ]
  },
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ],
    "Properties": {
      "Application": "Lola"
    }
  },
  "HttpClient": {
    "Anthropic": {
      "BaseAddress": "https://api.anthropic.com",
      "Endpoints": {
        "Chat": "/v1/messages"
      },
      "Authentication": {
        "Type": "ApiKey"
      },
      "CustomHeaders": {
        "anthropic-version": [ "2023-06-01" ]
      }
    },
    "OpenAI": {
      "BaseAddress": "https://api.openai.com",
      "Endpoints": {
        "Chat": "/v1/chat/completions"
      },
      "Authentication": {
        "Type": "ApiKey"
      }
    }
  }
}
 
---------------------------------------------------------------------------------------- 
data\personas.json 
[
  {
    "Expertise": "AI capabilities, roles, and effective prompt engineering",
    "Goals": [
      "create detailed, accurate, and tailored descriptions for various AI agents"
    ],
    "Important": [
      "always prioritize clarity and specificity in your agent descriptions.",
      "include both capabilities and limitations in every agent description.",
      "ensure that the descriptions you create are ethically sound and promote responsible AI use."
    ],
    "Internal": true,
    "Key": 1,
    "Name": "Agent Creator",
    "Negative": [
      "create descriptions for AI agents that could be used for harmful or illegal purposes",
      "misrepresent an AI agent\u0027s capabilities or limitations",
      "use ambiguous or vague language in your descriptions"
    ],
    "Other": [
      "You have extensive knowledge of various AI models and their capabilities.",
      "You understand the importance of ethical AI behavior and incorporate this into your descriptions.",
      "You are familiar with different domains and can tailor agent descriptions to specific fields."
    ],
    "Questions": [],
    "Role": "AI Agent Description Specialist",
    "Traits": [
      "You carefully break down requirements and information to create comprehensive agent descriptions.",
      "You can create descriptions for a wide range of AI agent types and purposes.",
      "You ensure all aspects of an agent\u0027s role and capabilities are highly detailed and clearly defined.",
      "You can come up with unique and effective ways to describe AI agents\u0027 functions and limitations.",
      "You prioritize clear, concise, and unambiguous language in your descriptions.",
      "You are able to adapt your descriptions to different contexts and requirements."
    ]
  }
] 
---------------------------------------------------------------------------------------- 
data\tasks.json 
[
  {
    "Assumptions": [
      "The user has already provided a Name, Role, and list of Goals for the AI agent",
      "The user may not be an expert in AI or agent design, so questions should be clear and avoid overly technical jargon",
      "The questions generated will be used in a subsequent step to create a full agent description",
      "The Agent is an AI agent so, it is limited to the capabilities of a AI agent.",
      "The Agent will only interact with the USER and the tools he have available to execute the task."
    ],
    "Constraints": [
      "make assumptions about the agent's capabilities beyond what is explicitly stated in the provided information",
      "generate questions about technical implementation details that the average user wouldn't be able to answer",
      "include questions that have already been answered by the provided Name, Role, and Goals",
      "include questions that were already answered by the user in a previous interaction"
    ],
    "Examples": [
      "Input:\nName: EcoAdvise\nRole: Environmental Sustainability Consultant\nGoals:\n1. Provide personalized advice on reducing carbon footprint\n2. Educate users on environmental issues\n3. Suggest eco-friendly alternatives for daily activities\n\nResponse:\n{\"Questions\":[{\"Question\":\"What level of expertise should EcoAdvise have? (e.g., general knowledge, academic-level, or industry-expert level)\",\"Explanation\":\"This will help determine the depth and complexity of advice the agent can provide.\"}]}",
      "Input:\nName: CodeCraft\nRole: Programming Assistant\nGoals:\n1. Help users debug their code\n2. Explain programming concepts\n3. Suggest optimizations for code efficiency\nPrevious Questions:\nQ: What programming languages should CodeCraft be proficient in?\nThis will define the scope of the agent's expertise and ensure it can assist with relevant languages.\nA: C# .NET\n\nResponse:\n{\"Questions\":[{\"Question\":\"Should CodeCraft be able to generate code snippets or complete functions, or only provide guidance?\",\"Explanation\":\"This will clarify the extent of the agent's coding capabilities and set appropriate user expectations.\"}]}"
    ],
    "Guidelines": [
      "Begin by carefully analyzing the provided Name, Role, and Goals to understand the general direction of the agent.",
      "Generate questions that cover different aspects of the agent, such as:\n- Specific capabilities within the given role;\n- Intended user interaction style;\n- Ethical guidelines and limitations;\n- Knowledge base and areas of expertise; and\n- Personality traits or communication style;",
      "Ensure questions are open-ended to encourage detailed responses.",
      "Frame questions in a way that helps users think deeply about their agent's design.",
      "Include a mix of questions about both capabilities and limitations."
    ],
    "Goals": [
      "generate insightful and relevant questions that will help users further define the characteristics, capabilities, and limitations of the AI agent they want to create",
      "analyze the provided Name, Role, and Goals of the prospective AI agent",
      "identify areas where more information is needed to create a comprehensive agent description",
      "generate clear, specific questions that will elicit useful information from the user",
      "ensure that the questions cover a wide range of agent characteristics, including capabilities, limitations, ethical considerations, and interaction style",
      "adapt the questions based on the context provided by the initial input"
    ],
    "InputTemplate": "Name: <<Name>>\nMain Role: <<Role>>\nGoals:\n<<Goals>>\nPrevious Questions:\n<<Questions>>\n",
    "Internal": true,
    "Key": 1,
    "Name": "Ask Questions about the AI Agent",
    "Scope": [
      "generating questions based solely on the Name, Role, and Goals provided by the user",
      "focusing on aspects of the agent that are not fully clear from the initial information",
      "covering various aspects of agent design, including but not limited to: knowledge base, interaction style, ethical guidelines, specific capabilities, and limitations"
    ],
    "Requirements": [
      "generate ONE question per request",
      "generate questions directly relevant to the provided Name, Role, and Goals",
      "generate questions designed to elicit specific, actionable information for agent creation",
      "generate an output that is a valid JSON file following strictly the schema defined in the prompt"
    ],
    "ResponseSchema": "{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"Questions\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"Question\":{\"type\":\"string\"},\"Explanation\":{\"type\":\"string\"}},\"required\":[\"Explanation\",\"Question\"]}}}}",
    "ResponseType": "Json",
    "Validations": [
      "Ensuring each question is directly relevant to the provided Name, Role, and Goals",
      "Checking that the set of questions covers a diverse range of agent characteristics",
      "Verifying that each question is clear, concise, and likely to elicit useful information",
      "Confirming that the questions do not make unwarranted assumptions about the agent",
      "Reviewing the brief explanations to ensure they clearly convey why each question is important"
    ]
  },
  {
    "Assumptions": [
      "The user has provided a Name, Role, and list of Goals for the AI agent",
      "The user has answered additional questions about the AI agent",
      "All provided information is relevant to the Persona creation",
      "The Agent is an AI agent so, it is limited to the capabilities of a AI agent.",
      "The Agent will only interact with the USER and the tools he have available to execute the task."
    ],
    "Constraints": [
      "introduce new information that isn't derived from the user's input or question responses",
      "generate properties that contradict the provided Name, Role, Goals or Answered Questions",
      "include traits in multiple categories (e.g., a trait shouldn't appear in both Traits and Important lists)"
    ],
    "Examples": [
      "Input:\nName: EcoAdvise\nRole: Environmental Sustainability Consultant\nGoals:\n1. Provide personalised advice at reducing carbon footprint\n2. Educate the users on environmental issues\n3. Suggest eco-friendly alternative for daiyl activities\nQuestions:\nQ: What level of expertise should EcoAdvise have?\nThis question will help identify the scope and depth of the knowledge that the agent have.\nA: EcoAdvise should have industry-expert level knowledge.\nQ: How should EcoAdvise balance between providing scientific facts and motivating users?\nThis question will help define the type of answer the user is expecting.\nA: EcoAdvise should use a 70-30 split, with 70% focus on scientific facts and 30% on motivation.\n\nOutput:\n{\"Role\":\"Environmental Sustainability Consultant\",\"Goals\":[\"Provide personalized advice on reducing carbon footprint\",\"Educate the user on environmental issues\",\"Suggest eco-friendly alternatives for daily activities\"],\"Expertise\":\"Advanced environmental science with a focus on sustainability and carbon footprint reduction\",\"Traits\":[\"Broadly Knowlegeable: Knowledgeable about global and local environmental issues\",\"Excellent Communicator: Able to communicate complex scientific concepts clearly\",\"Data-Driven: Data-driven in approach to sustainability\"],\"Important\":[\"You MUST provide accurate, up-to-date environmental information\",\"ALWAYS respects user privacy when handling location data\",\"You MUST balances scientific facts with motivational encouragement\"],\"Negative\":[\"be alarmist or overly pessimistic about environmental issues\",\"recommend unsustainable or unethical practices\",\"ignore local context in sustainability advice\"],\"Other\":[\"Uses a 70-30 split between scientific facts and motivation in communications\",\"Capable of tailoring advice to specific geographic locations\",\"Stays updated on the latest environmental research and sustainability practices\"]}\n"
    ],
    "Guidelines": [
      "Begin by carefully analyzing all provided information: Name, Role, Goals, and question responses",
      "For Expertise, identify the core area of knowledge or skill central to the Persona's role and goals",
      "For Traits, identify characteristics that support the Persona's role and goals but aren't crucial",
      "For Important, identify crucial characteristics without which the Persona couldn't fulfill its role or achieve its goals",
      "For Negative, identify traits or behaviors that would hinder the Persona's effectiveness or contradict its purpose",
      "For Other, include any relevant information that doesn't fit into the above categories but adds depth to the Persona",
      "Ensure all generated properties align with the Persona's Name, Role, and Goals",
      "Provide clear, concise explanations for each generated property"
    ],
    "Goals": [
      "generate the Expertise, Traits, Important, Negative, and Other properties of the Persona",
      "ensure that the generated properties are consistent with the initial input and question responses",
      "create a comprehensive and coherent Persona description",
      "provide explanations for each generated property to justify its relevance to the Persona"
    ],
    "InputTemplate": "Name: <<Name>>\nMain Role: <<Role>>\nGoals:\n<<Goals>>\nQuestions:\n<<Questions>>\n",
    "Internal": true,
    "Key": 2,
    "Name": "Generate AI Agent Persona",
    "Scope": [
      "generating the Expertise, Traits, Important, Negative, and Other properties based solely on the provided information",
      "ensuring all generated properties align with the Persona's Name, Role, and Goals",
      "focusing on creating a well-rounded and consistent Persona description"
    ],
    "Requirements": [
      "generate all five properties: Expertise, Traits, Important, Negative, and Other",
      "rewrite the Role and Goals properties with correct English without changing their intended contents",
      "ensure the Role property is a text that is a continuation of: 'You are a highly capable and versatile {Role}'",
      "ensure that each Goal is a simple phrase that is a continuation of: 'Your goal is {Goal}'",
      "ensure the Expertise property is a text describing list of skills the agent and is a continuation of 'You are an expert in {Expertise}'",
      "ensure the Traits, Important, Negative, and Other properties are lists of strings",
      "ensure that each Trait also include a short explanation of their intent. For example:\n Highly Analytical: You meticulously break down complex programming problems and user requirements to provide comprehensive solutions and explanations.\n Excellent Communicator: You explain complex technical concepts and code structures in clear, accessible language tailored to the USER's level of understanding.",
      "ensure that the Important and Negative lists do not contradict each other",
      "ensure that each Important item is written in an imperative way as continuation of the text: '**IMPORTANT, ** {Important_Item}'. They should normally start with 'You MUST ' or 'ALWAYS '.",
      "ensure that each Negative item is written as their POSITIVE version as a continuation of the text: '**NEVER, IN ANY CIRCUMSTANCE, ** {Negative_Item}'",
      "provide a brief explanation for each generated property, justifying its relevance to the Persona"
    ],
    "ResponseSchema": "{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"Role\":{\"type\":\"string\"},\"Goals\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Expertise\":{\"type\":\"string\"},\"Traits\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Important\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Negative\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Other\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"Role\",\"Goals\",\"Expertise\",\"Traits\",\"Important\",\"Negative\",\"Other\"]}",
    "ResponseType": "Json",
    "Validations": [
      "ensuring each generated property is directly relevant to and consistent with the provided information",
      "checking that the Expertise aligns closely with the Role and Goals",
      "verifying that Traits and Important lists contain distinct items that don't contradict each other",
      "confirming that Negative traits are genuinely detrimental to the Persona's purpose",
      "reviewing the Other list to ensure it adds value without redundancy",
      "validating that clear, concise explanations are provided for each generated property"
    ]
  }
]
 
---------------------------------------------------------------------------------------- 
data\users.json 
[
  {
    "Internal": true,
    "Name": "User",
    "Key": 0
  }
] 
---------------------------------------------------------------------------------------- 
Main\Commands\HelpCommand.cs 
using Lola.Utilities;

namespace Lola.Main.Commands;

public class HelpCommand(IHasChildren parent)
    : Command<HelpCommand>(parent, "Help", n => {
        n.Aliases = ["?"];
        n.Description = "Show help";
        n.Help = "Display this help information.";
        n.AddParameter("Target", string.Empty);
    }) {
    private const int _indentSize = 4;

    protected override Result Execute() => this.HandleCommand(() => {
        Logger.LogInformation("Executing Help command...");
        ShowHelp();
        return Result.Success();
    }, "Error displaying the help information.");

    private void ShowHelp() {
        var target = Context.GetValueAs<string>("Target");
        var command = Parent.Commands.FirstOrDefault(i => i.Name.Equals(target, StringComparison.OrdinalIgnoreCase));
        var node = command ?? Parent;
        var helpText = GetHelp(node);
        Output.Write(helpText);
    }

    private static string GetHelp(IHasChildren node) {
        var builder = new StringBuilder();
        AppendNodeDescription(builder, node);
        AppendUsage(builder, node);
        AppendAliases(builder, node);
        AppendItems(builder, "Options", node.Options);
        AppendItems(builder, "Parameters", node.Parameters);
        AppendItems(builder, "Commands", node.Commands);
        return builder.ToString();
    }

    private static void AppendNodeDescription(StringBuilder builder, INode node) {
        if (node is IApplication app) builder.AppendLine(app.FullName);
        if (string.IsNullOrWhiteSpace(node.Help)) return;
        builder.AppendLine(node.Help.Trim());
    }

    private static void AppendUsage(StringBuilder builder, IHasChildren node) {
        if (builder.Length != 0) builder.AppendLine();
        builder.AppendLine("Usage:");
        AppendDefaultUsage(builder, node);
        AppendUsageWithParameters(builder, node);
    }

    private static void AppendDefaultUsage(StringBuilder builder, IHasChildren node) {
        if (node.Commands.Length == 0 && node.Parameters.Length != 0) return;
        builder.Append(' ', _indentSize).Append(node.Path);
        if (node.Options.Length != 0) builder.Append(" [[Options]]");
        if (node.Commands.Length != 0) builder.Append(" [[Commands]]");
        builder.AppendLine();
    }

    private static void AppendUsageWithParameters(StringBuilder builder, IHasChildren node) {
        if (node.Parameters.Length == 0) return;
        builder.Append(' ', _indentSize).Append(node.Path);
        if (node.Options.Length != 0) builder.Append(" [[Options]]");
        foreach (var parameter in node.Parameters) {
            if (parameter.IsRequired) builder.Append($" <{parameter.Name}>");
            else builder.Append($" [<{parameter.Name}>]");
        }
        builder.AppendLine();
    }

    private static void AppendAliases(StringBuilder builder, IHasChildren node) {
        if (node.Aliases.Length == 0) return;
        builder.AppendLine();
        builder.Append("Aliases: ").AppendJoin(", ", node.Aliases).AppendLine();
    }

    private static void AppendItems(StringBuilder builder, string section, IReadOnlyCollection<INode> items) {
        if (items.Count == 0) return;
        builder.AppendLine();
        builder.AppendLine($"{section}:");
        foreach (var item in items)
            AppendItem(builder, item);
    }

    private static void AppendItem(StringBuilder builder, INode node) {
        builder.Append(' ', _indentSize);
        var ids = GetIds(node);
        builder.Append(ids);
        AppendNodeDescription(builder, node, ids.Length + _indentSize);
    }

    private static string GetIds(INode node) {
        string[] ids = node is IArgument _
                           ? [$"--{node.Name.ToLowerInvariant()}", .. node.Aliases.Select(a => $"-{a}")]
                           : [node.Name, .. node.Aliases];
        return string.Join(", ", ids);
    }

    private static void AppendNodeDescription(StringBuilder builder, INode node, int length) {
        var lines = node.Help.Split(System.Environment.NewLine, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length == 0) {
            builder.AppendLine();
            return;
        }
        builder.Append(' ', 30 - length).AppendLine(lines[0]);
        foreach (var line in lines.Skip(1)) builder.Append(' ', 30).AppendLine(line);
    }
}
 
---------------------------------------------------------------------------------------- 
Main\Commands\SettingsCommand.cs 
using Lola.Utilities;

namespace Lola.Main.Commands;

public class SettingsCommand(IHasChildren parent, IOptions<LolaSettings> settings)
    : Command<SettingsCommand>(parent, "Settings", n => {
        n.Aliases = ["set"];
        n.Description = "Show settings";
        n.Help = "Display the current configuration of Lola.";
    }) {
    private readonly LolaSettings _settings = settings.Value;

    protected override Result Execute() => this.HandleCommand(() => {
        Logger.LogInformation("Executing Settings command...");
        DrawTable();
        return Result.Success();
    }, "Error displaying the settings.");

    private void DrawTable() {
        var table = new Table();
        table.AddColumn("Setting");
        table.AddColumn("Value");
        table.AddRow("Default AI Provider", _settings.DefaultAIProvider);
        table.AddRow("Available Models", string.Join(", ", _settings.AvailableModels));
        Output.Write(table);
        Output.WriteLine();
    }
}
 
---------------------------------------------------------------------------------------- 
Models\Commands\ModelAddCommand.cs 
using Lola.Utilities;

using Task = System.Threading.Tasks.Task;
using ValidationException = DotNetToolbox.Results.ValidationException;

namespace Lola.Models.Commands;

public class ModelAddCommand(IHasChildren parent, IModelHandler modelHandler, IProviderHandler providerHandler)
    : Command<ModelAddCommand>(parent, "Add", c => {
        c.Aliases = ["new"];
        c.Description = "Add a new model";
        c.Help = "Register a new model from a specific LLM provider.";
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        try {
            Logger.LogInformation("Executing Models->Add command...");
            var providers = providerHandler.List();
            if (providers.Length == 0) {
                Output.WriteLine("[yellow bold]No providers available. Please add a provider first.[/]");
                Logger.LogInformation("No providers available. Create model action cancelled.");
                return Result.Invalid("No providers available.");
            }

            var provider = await Input.BuildSelectionPrompt<ProviderEntity>("Select a provider:")
                                      .ConvertWith(p => $"{p.Key}: {p.Name}")
                                      .AddChoices(providers)
                                      .ShowAsync(ct);
            var model = new ModelEntity();
            await SetUpAsync(model, provider, lt);

            modelHandler.Add(model);
            Output.WriteLine($"[green]Settings '{model.Name}' added successfully.[/]");
            Logger.LogInformation("Settings '{ModelKey}:{ModelName}' added successfully.", model.Key, model.Name);
            return Result.Success();
        }
        catch (ValidationException ex) {
            var errors = string.Join("\n", ex.Errors.Select(e => $" - {e.Source}: {e.Message}"));
            Logger.LogWarning("Error adding the new model. Validation errors:\n{Errors}", errors);
            Output.WriteLine($"[red]We found some problems while adding the model. Please correct the following errors and try again:\n{errors}[/]");
            return Result.Invalid(ex.Errors);
        }
    }, "Error adding a new model.", ct);

    private async Task SetUpAsync(ModelEntity model, ProviderEntity provider, CancellationToken ct) {
        model.Key = await Input.BuildTextPrompt<string>("Enter the model identifier:")
                               .AddValidation(key => ModelEntity.ValidateKey(key, modelHandler))
                               .ShowAsync(ct);
        model.Name = await Input.BuildTextPrompt<string>("Enter the model name:")
                                .AddValidation(name => ModelEntity.ValidateName(name, modelHandler))
                                .ShowAsync(ct);
        model.ProviderKey = provider.Key;
        model.MaximumContextSize = await Input.BuildTextPrompt<uint>("Enter the maximum context size:")
                                              .ShowAsync(ct);
        model.MaximumOutputTokens = await Input.BuildTextPrompt<uint>("Enter the maximum output tokens:")
                                               .ShowAsync(ct);
        model.InputCostPerMillionTokens = await Input.BuildTextPrompt<decimal>("Enter the input cost per million tokens:")
                                                     .AddValidation(ModelEntity.ValidateInputCost)
                                                     .ShowAsync(ct);
        model.OutputCostPerMillionTokens = await Input.BuildTextPrompt<decimal>("Enter the output cost per million tokens:")
                                                      .AddValidation(ModelEntity.ValidateOutputCost)
                                                      .ShowAsync(ct);
        model.TrainingDateCutOff = await Input.BuildTextPrompt<DateOnly?>("Enter the training data cut-off date (YYYY-MM-DD):")
                                              .AddValidation(ModelEntity.ValidateDateCutOff)
                                              .ShowAsync(ct);
    }
}
 
---------------------------------------------------------------------------------------- 
Models\Commands\ModelListCommand.cs 
using Lola.Utilities;

namespace Lola.Models.Commands;

public class ModelListCommand(IHasChildren parent, IModelHandler modelHandler, IProviderHandler providerHandler)
    : Command<ModelListCommand>(parent, "List", n => {
        n.Aliases = ["ls"];
        n.Description = "List models";
        n.Help = "List all the models or those from a specific LLM provider.";
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        Logger.LogInformation("Executing Models->List command...");
        var providers = providerHandler.List();
        if (providers.Length == 0) {
            Output.WriteLine("[yellow bold]No providers available. Please add a provider first.[/]");
            Logger.LogInformation("No providers available. List models action cancelled.");
            return Result.Invalid("No providers available.");
        }
        var choices = providers.ToList(p => new ListItem<ProviderEntity, uint>(p.Key, p.Name, p));
        var cancelOption = new ListItem<ProviderEntity, uint>(0, "All", null);
        choices.Insert(0, cancelOption);
        var selectedChoice = await Input.BuildSelectionPrompt<ListItem<ProviderEntity, uint>>("Select a provider:")
                                    .ConvertWith(p => p.Text)
                                    .AddChoices([.. choices])
                                    .ShowAsync(lt);
        var models = selectedChoice.Key == default
            ? modelHandler.List()
            : modelHandler.List(selectedChoice.Item!.Key);
        if (models.Length == 0) {
            Output.WriteLine("[yellow]No models found.[/]");
            return Result.Success();
        }

        var sortedList = models.OrderBy(m => m.Provider!.Name).ThenBy(m => m.Name);

        ShowList(sortedList, providerHandler);

        return Result.Success();
    }, "Error listing models.", ct);

    private void ShowList(IOrderedEnumerable<ModelEntity> sortedModels, IProviderHandler providerHandler) {
        var table = new Table();
        table.Expand();
        table.AddColumn(new("[yellow]Name[/]"));
        table.AddColumn(new("[yellow]Provider[/]"));
        table.AddColumn(new("[yellow]Id[/]"));
        table.AddColumn(new TableColumn("[yellow]Map Size[/]").RightAligned());
        table.AddColumn(new TableColumn("[yellow]Output Tokens[/]").RightAligned());
        foreach (var model in sortedModels) {
            var provider = providerHandler.GetByKey(model.ProviderKey)!;
            table.AddRow(
                model.Name,
                provider.Name,
                model.Key,
                $"{model.MaximumContextSize:#,##0}",
                $"{model.MaximumOutputTokens:#,##0}"
            );
        }
        Output.Write(table);
    }
}
 
---------------------------------------------------------------------------------------- 
Models\Commands\ModelRemoveCommand.cs 
using Lola.Utilities;

namespace Lola.Models.Commands;

public class ModelRemoveCommand(IHasChildren parent, IModelHandler handler)
    : Command<ModelRemoveCommand>(parent, "Remove", n => {
        n.Aliases = ["delete", "del"];
        n.Description = "Remove a model";
        n.Help = "Remove a model.";
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        Logger.LogInformation("Executing Models->Remove command...");
        var models = handler.List();
        if (models.Length == 0) {
            Output.WriteLine("[yellow]No models found.[/]");
            Logger.LogInformation("No models found. Remove model action cancelled.");
            return Result.Success();
        }
        var model = await this.SelectEntityAsync<ModelEntity, string>(models.OrderBy(m => m.ProviderKey).ThenBy(m => m.Name), m => m.Name, lt);
        if (model is null) {
            Logger.LogInformation("No model selected.");
            return Result.Success();
        }

        if (!await Input.ConfirmAsync($"Are you sure you want to remove the model '{model.Name}' ({model.Key})?", lt)) {
            return Result.Invalid("Action cancelled.");
        }

        handler.Remove(model.Key);
        Output.WriteLine($"[green]Settings with key '{model.Name}' removed successfully.[/]");
        return Result.Success();
    }, "Error removing a model.", ct);
}
 
---------------------------------------------------------------------------------------- 
Models\Commands\ModelsCommand.cs 
using Lola.Utilities;

namespace Lola.Models.Commands;

public class ModelsCommand(IHasChildren parent)
    : Command<ModelsCommand>(parent, "Models", n => {
        n.Description = "Manage models";
        n.Help = "Register, update, or remove models from a specific LLM provider.";
        n.AddCommand<ModelListCommand>();
        n.AddCommand<ModelAddCommand>();
        n.AddCommand<ModelUpdateCommand>();
        n.AddCommand<ModelRemoveCommand>();
        n.AddCommand<ModelViewCommand>();
        n.AddCommand<HelpCommand>();
        n.AddCommand<BackCommand>();
        n.AddCommand<ExitCommand>();
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        Logger.LogInformation("Showing Models main menu...");
        var choice = await Input.BuildSelectionPrompt<string>("What would you like to do?")
                                .ConvertWith(MapTo)
                                .AddChoices(Commands.ToArray(c => c.Name))
                                .ShowAsync(lt);

        var command = Commands.FirstOrDefault(i => i.Name == choice);
        return command is null
            ? Result.Success()
            : await command.Execute([], lt);

        string MapTo(string item) => Commands.FirstOrDefault(i => i.Name == item)?.Description ?? string.Empty;
    }, "Error displaying model's menu.", ct);
}
 
---------------------------------------------------------------------------------------- 
Models\Commands\ModelSelectCommand.cs 
using Lola.Utilities;

namespace Lola.Models.Commands;

public class ModelSelectCommand(IHasChildren parent, IModelHandler handler)
    : Command<ModelSelectCommand>(parent, "Select", n => {
        n.Aliases = ["sel"];
        n.Description = "Select default model.";
        n.Help = "Select the default model.";
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        Logger.LogInformation("Executing Models->Select default model command...");
        var models = handler.List();
        if (models.Length == 0) {
            Output.WriteLine("[yellow]No models available. Please add a model before proceeding.[/]");
            return Result.Success();
        }

        var selected = await Input.BuildSelectionPrompt<ModelEntity>("Select an model:")
                                  .AddChoices(models.OrderBy(m => m.ProviderKey).ThenBy(m => m.Name))
                                  .ConvertWith(c => c.Name)
                                  .ShowAsync(lt);

        handler.Select(selected.Key);
        Output.WriteLine($"[green]Settings '{selected.Key}' selected successfully.[/]");
        return Result.Success();
    }, "Error selecting a model.", ct);
}
 
---------------------------------------------------------------------------------------- 
Models\Commands\ModelUpdateCommand.cs 
using Lola.Utilities;

using Task = System.Threading.Tasks.Task;
using ValidationException = DotNetToolbox.Results.ValidationException;

namespace Lola.Models.Commands;

public class ModelUpdateCommand(IHasChildren parent, IModelHandler modelHandler, IProviderHandler providerHandler)
    : Command<ModelUpdateCommand>(parent, "Update", n => {
        n.Aliases = ["edit"];
        n.Description = "Update model";
        n.Help = "Update an existing model.";
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        try {
            Logger.LogInformation("Executing Models->Update command...");
            var models = modelHandler.List();
            if (models.Length == 0) {
                Output.WriteLine("[yellow]No models found.[/]");
                Logger.LogInformation("No models found. Remove model action cancelled.");
                return Result.Success();
            }
            var model = await this.SelectEntityAsync<ModelEntity, string>(models.OrderBy(m => m.ProviderKey).ThenBy(m => m.Name), m => m.Name, lt);
            if (model is null) {
                Logger.LogInformation("No model selected.");
                return Result.Success();
            }

            await SetUpAsync(model, lt);
            modelHandler.Update(model);
            Logger.LogInformation("Settings '{ModelKey}:{ModelName}' updated successfully.", model.Key, model.Name);
            Output.WriteLine("[green]Settings updated successfully.[/]");
            return Result.Success();
        }
        catch (ValidationException ex) {
            var errors = string.Join("\n", ex.Errors.Select(e => $" - {e.Source}: {e.Message}"));
            Logger.LogWarning("Error updating the model. Validation errors:\n{Errors}", errors);
            Output.WriteLine($"[red]We found some problems while updating the model. Please correct the following errors and try again:\n{errors}[/]");
            return Result.Invalid(ex.Errors);
        }
    }, "Error updating the model.", ct);

    private async Task SetUpAsync(ModelEntity model, CancellationToken ct) {
        var currentProvider = providerHandler.GetByKey(model.ProviderKey);
        var provider = await Input.BuildSelectionPrompt<ProviderEntity>("Select a provider:")
                                  .ConvertWith(p => $"{p.Key}: {p.Name}")
                                  .WithDefault(currentProvider!)
                                  .AddChoices(providerHandler.List())
                                  .ShowAsync(ct);
        model.ProviderKey = provider.Key;
        model.Key = await Input.BuildTextPrompt<string>("Enter the model identifier:")
                               .AddValidation(key => ModelEntity.ValidateKey(key, modelHandler))
                               .ShowAsync(ct);
        model.Name = await Input.BuildTextPrompt<string>("Enter the model name:")
                                .AddValidation(name => ModelEntity.ValidateName(name, modelHandler))
                                .ShowAsync(ct);
        model.ProviderKey = provider.Key;
        model.MaximumContextSize = await Input.BuildTextPrompt<uint>("Enter the maximum context size:")
                                              .ShowAsync(ct);
        model.MaximumOutputTokens = await Input.BuildTextPrompt<uint>("Enter the maximum output tokens:")
                                               .ShowAsync(ct);
        model.InputCostPerMillionTokens = await Input.BuildTextPrompt<decimal>("Enter the input cost per million tokens:")
                                                     .AddValidation(ModelEntity.ValidateInputCost)
                                                     .ShowAsync(ct);
        model.OutputCostPerMillionTokens = await Input.BuildTextPrompt<decimal>("Enter the output cost per million tokens:")
                                                      .AddValidation(ModelEntity.ValidateOutputCost)
                                                      .ShowAsync(ct);
        model.TrainingDateCutOff = await Input.BuildTextPrompt<DateOnly?>("Enter the training data cut-off date (YYYY-MM-DD):")
                                              .AddValidation(ModelEntity.ValidateDateCutOff)
                                              .ShowAsync(ct);
    }
}
 
---------------------------------------------------------------------------------------- 
Models\Commands\ModelViewCommand.cs 
using Lola.Utilities;

namespace Lola.Models.Commands;

public class ModelViewCommand(IHasChildren parent, IModelHandler handler, IProviderHandler providerHandler)
    : Command<ModelViewCommand>(parent, "Info", n => {
        n.Aliases = ["i"];
        n.Description = "View model";
        n.Help = "Display detailed information about a model.";
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        Logger.LogInformation("Executing Models->Info command...");
        var models = handler.List();
        if (models.Length == 0) {
            Output.WriteLine("[yellow]No models found.[/]");
            Logger.LogInformation("No models found. View model action cancelled.");
            return Result.Success();
        }
        var model = await this.SelectEntityAsync<ModelEntity, string>(models.OrderBy(m => m.ProviderKey).ThenBy(m => m.Name), m => m.Name, lt);
        if (model is null) {
            Logger.LogInformation("No model selected.");
            return Result.Success();
        }
        model.Provider = providerHandler.GetByKey(model.ProviderKey)!;

        ShowDetails(model);

        return Result.Success();
    }, "Error displaying the model information.", ct);

    private void ShowDetails(ModelEntity model) {
        Output.WriteLine("[yellow]Model Information:[/]");
        Output.WriteLine($"[blue]Id:[/] {model.Key}{(model.Selected ? " [green](default)[/]" : "")}");
        Output.WriteLine($"[blue]Name:[/] {model.Name}");
        Output.WriteLine($"[blue]Provider:[/] {model.Provider!.Name}");
        Output.WriteLine($"[blue]Maximum Map Size:[/] {model.MaximumContextSize}");
        Output.WriteLine($"[blue]Maximum Output Tokens:[/] {model.MaximumOutputTokens}");
        Output.WriteLine($"[blue]Input Cost per MTok:[/] {model.InputCostPerMillionTokens:C}");
        Output.WriteLine($"[blue]Output Cost per MTok:[/] {model.OutputCostPerMillionTokens:C}");
        Output.WriteLine($"[blue]Training Date Cut-Off:[/] {model.TrainingDateCutOff:MMM yyyy}");
        Output.WriteLine();
    }
}
 
---------------------------------------------------------------------------------------- 
Models\Handlers\IModelHandler.cs 
namespace Lola.Models.Handlers;

public interface IModelHandler {
    ModelEntity[] List(uint providerKey = 0);
    ModelEntity? GetByKey(string key);
    ModelEntity? GetByName(string name);
    void Add(ModelEntity model);
    void Update(ModelEntity model);
    void Remove(string key);

    void Select(string key);
    ModelEntity? Selected { get; }
}
 
---------------------------------------------------------------------------------------- 
Models\Handlers\ModelHandler.cs 
namespace Lola.Models.Handlers;

public class ModelHandler(IApplication application, IModelDataSource dataSource, ILogger<ModelHandler> logger)
    : IModelHandler {
    private const string _applicationModelKey = "ApplicationModel";

    private ModelEntity? _selected;

    public ModelEntity? Selected {
        get => GetSelected();
        private set => SetSelected(IsNotNull(value));
    }

    private ModelEntity? GetSelected() {
        var cachedValue = application.Context.GetValueAs<ModelEntity>(_applicationModelKey);
        _selected = cachedValue ?? dataSource.GetSelected();
        if (_selected is null) return null;
        if (cachedValue is null) application.Context[_applicationModelKey] = _selected;
        return _selected; // Should only return null if the storage is empty or there is no selected model in the storage.
    }

    private void SetSelected(ModelEntity value) {
        if (value.Key == _selected?.Key) return;
        _selected = value;

        // Ensure record uniqueness in storage
        var oldSelectedModel = dataSource.FirstOrDefault(m => m.Selected);
        if (oldSelectedModel is not null && oldSelectedModel.Key != _selected.Key) {
            oldSelectedModel.Selected = false;
            dataSource.Update(oldSelectedModel);
        }
        _selected.Selected = true;
        dataSource.Update(_selected);

        // Update cached value
        application.Context[_applicationModelKey] = _selected;
    }

    public ModelEntity[] List(uint providerKey = 0)
        => [.. dataSource.GetAll(m => m.ProviderKey == 0 || m.ProviderKey == providerKey).OrderBy(m => m.Name)];

    public ModelEntity? GetByKey(string key)
        => dataSource.FindByKey(key);

    public ModelEntity? GetByName(string name)
        => dataSource.Find(i => i.Name == name);

    public void Add(ModelEntity model) {
        if (dataSource.FindByKey(model.Key) is not null)
            throw new InvalidOperationException($"A model with the key '{model.Key}' already exists.");
        if (_selected is null) model.Selected = true;
        dataSource.Add(model);
        _selected = model;
        logger.LogInformation("Added new model: {ModelKey} => {ModelName}", model.Key, model.Name);
    }

    public void Update(ModelEntity model) {
        if (dataSource.FindByKey(model.Key) == null)
            throw new InvalidOperationException($"Settings with key '{model.Key}' not found.");
        dataSource.Update(model);
        logger.LogInformation("Updated model: {ModelKey} => {ModelName}", model.Key, model.Name);
    }

    public void Remove(string key) {
        var model = dataSource.FindByKey(key, false) ?? throw new InvalidOperationException($"Settings with key '{key}' not found.");

        dataSource.Remove(key);
        logger.LogInformation("Removed model: {ModelKey} => {ModelName}", model.Key, model.Name);
    }

    public ModelEntity[] ListByProvider(uint providerKey) => dataSource.GetAll(m => m.ProviderKey == providerKey);

    public void Select(string key) {
        var model = dataSource.FindByKey(key)
                 ?? throw new InvalidOperationException($"Settings '{key}' not found.");
        Selected = model;
        logger.LogInformation("Settings '{ModelKey} => {ModelName}' selected : ", model.Key, model.Name);
    }
}
 
---------------------------------------------------------------------------------------- 
Models\Repositories\IModelDataSource.cs 
namespace Lola.Models.Repositories;

public interface IModelDataSource : IDataSource<ModelEntity, string> {
    ModelEntity? GetSelected();
    ModelEntity[] GetAll(Expression<Func<ModelEntity, bool>>? predicate = null, bool includeProviders = true);
    ModelEntity? FindByKey(string key, bool includeProvider = true);
}
 
---------------------------------------------------------------------------------------- 
Models\Repositories\IModelStorage.cs 
namespace Lola.Models.Repositories;

public interface IModelStorage
    : IStorage<ModelEntity, string>;
 
---------------------------------------------------------------------------------------- 
Models\Repositories\ModelDataSource.cs 
namespace Lola.Models.Repositories;

public class ModelDataSource(IModelStorage storage, Lazy<IProviderDataSource> providers)
    : DataSource<IModelStorage, ModelEntity, string>(storage),
      IModelDataSource {
    public ModelEntity[] GetAll(Expression<Func<ModelEntity, bool>>? predicate = null, bool includeProviders = true) {
        var models = base.GetAll(predicate);
        if (!includeProviders) return models;
        var providers1 = providers.Value.GetAll();
        foreach (var model in models)
            model.Provider = providers1.FirstOrDefault(p => p.Key == model.ProviderKey);
        return models;
    }

    public ModelEntity? GetSelected() {
        var model = Find(m => m.Selected);
        if (model is null) return null;
        model.Provider = providers.Value.FindByKey(model.ProviderKey);
        return model;
    }

    public ModelEntity? FindByKey(string key, bool includeProvider = true) {
        var model = base.FindByKey(key);
        if (model is null) return null;
        if (!includeProvider) return model;
        model.Provider = providers.Value.FindByKey(model.ProviderKey);
        return model;
    }
}
 
---------------------------------------------------------------------------------------- 
Models\Repositories\ModelEntity.cs 
using Model = DotNetToolbox.AI.Models.Model;

namespace Lola.Models.Repositories;

public class ModelEntity : Entity<ModelEntity, string> {
    public uint ProviderKey { get; set; }
    [JsonIgnore]
    public ProviderEntity? Provider { get; set; }
    public string Name { get; set; } = string.Empty;
    public uint MaximumContextSize { get; set; }
    public uint MaximumOutputTokens { get; set; }
    public decimal InputCostPerMillionTokens { get; set; }
    public decimal OutputCostPerMillionTokens { get; set; }
    public DateOnly? TrainingDateCutOff { get; set; }
    public bool Selected { get; set; }

    public override Result Validate(IMap? context = null) {
        var result = base.Validate(context);
        result += ValidateKey(Key, IsNotNull(context).GetRequiredValueAs<IModelHandler>(nameof(ModelHandler)));
        result += ValidateName(Name, IsNotNull(context).GetRequiredValueAs<IModelHandler>(nameof(ModelHandler)));
        result += ValidateProvider(ProviderKey, IsNotNull(context).GetRequiredValueAs<IProviderHandler>(nameof(ProviderHandler)));
        result += ValidateInputCost(InputCostPerMillionTokens);
        result += ValidateOutputCost(OutputCostPerMillionTokens);
        result += ValidateDateCutOff(TrainingDateCutOff);
        return result;
    }

    public static Result ValidateKey(string? key, IModelHandler handler) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(key))
            result += new ValidationError("The identifier is required.", nameof(Key));
        else if (handler.GetByKey(key) is not null)
            result += new ValidationError("A model with this identifier is already registered.", nameof(Key));
        return result;
    }

    public static Result ValidateName(string? name, IModelHandler handler) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(name))
            result += new ValidationError("The name is required.", nameof(Name));
        else if (handler.GetByName(name) is not null)
            result += new ValidationError("A model with this name is already registered.", nameof(Name));
        return result;
    }

    public static Result ValidateProvider(uint providerKey, IProviderHandler handler) {
        var result = Result.Success();
        if (handler.GetByKey(providerKey) is null)
            result += new ValidationError("The provider does not exist.", nameof(ProviderKey));
        return result;
    }

    public static Result ValidateInputCost(decimal value) {
        var result = Result.Success();
        if (value < 0)
            result += new ValidationError("The input cost per million tokens must be greater than or equal to zero.", nameof(InputCostPerMillionTokens));
        return result;
    }

    public static Result ValidateOutputCost(decimal value) {
        var result = Result.Success();
        if (value < 0)
            result += new ValidationError("The input cost per million tokens must be greater than or equal to zero.", nameof(InputCostPerMillionTokens));
        return result;
    }

    public static Result ValidateDateCutOff(DateOnly? value) {
        var result = Result.Success();
        if (value is not null && value.Value > DateOnly.FromDateTime(DateTime.UtcNow))
            result += new ValidationError("The training data cut off date must be in the past.", nameof(TrainingDateCutOff));
        if (value is not null && value.Value <= DateOnly.Parse("2021-01"))
            result += new ValidationError("The training data cut off date must be after Jan. 2021.", nameof(TrainingDateCutOff));
        return result;
    }

    public static implicit operator Model(ModelEntity entity) => new(entity.Key) {
        Provider = entity.Provider!.Name,
        Name = entity.Name,
        MaximumContextSize = entity.MaximumContextSize,
        MaximumOutputTokens = entity.MaximumOutputTokens,
        TrainingDataCutOff = entity.TrainingDateCutOff,
    };
}
 
---------------------------------------------------------------------------------------- 
Models\Repositories\ModelStorage.cs 
namespace Lola.Models.Repositories;

public class ModelStorage(IConfiguration configuration)
    : JsonFilePerTypeStorage<ModelEntity, string>("models", configuration),
      IModelStorage {
    protected override bool TryGenerateNextKey([MaybeNullWhen(false)] out string next) {
        next = default;
        return false;
    }
}
 
---------------------------------------------------------------------------------------- 
Personas\Commands\PersonaCreateCommand.cs 
using Lola.Utilities;

using Task = System.Threading.Tasks.Task;
using ValidationException = DotNetToolbox.Results.ValidationException;

namespace Lola.Personas.Commands;

public class PersonaGenerateCommand(IHasChildren parent, IPersonaHandler personaHandler)
    : Command<PersonaGenerateCommand>(parent, "Generate", n => {
        n.Aliases = ["gen"];
        n.Description = "Create a new persona.";
        n.Help = "Generate a new agent persona using AI assistance.";
    }) {
    private const int _maxQuestions = 10;

    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        try {
            Logger.LogInformation("Executing Personas->Generate command...");
            var persona = new PersonaEntity();
            await SetUpAsync(persona, lt);
            await AskAdditionalQuestions(persona, lt);
            await personaHandler.UpdateCreatedPersona(persona);

            Output.WriteLine($"[green]Agent persona '{persona.Name}' generated successfully.[/]");
            Logger.LogInformation("Persona '{PersonaKey}:{PersonaName}' generated successfully.", persona.Key, persona.Name);

            ShowResult(persona);

            var savePersona = await Input.ConfirmAsync("Are you ok with the generated Agent above?", lt);
            if (savePersona) {
                personaHandler.Add(persona);
                Logger.LogInformation("Persona '{PersonaKey}:{PersonaName}' added successfully.", persona.Key, persona.Name);
                return Result.Success();
            }

            Output.WriteLine("[yellow]Please review the provided answers and try again.[/]");
            return Result.Success();
        }
        catch (ValidationException ex) {
            var errors = string.Join("\n", ex.Errors.Select(e => $" - {e.Source}: {e.Message}"));
            Logger.LogWarning("Error generating the new persona. Validation errors:\n{Errors}", errors);
            Output.WriteLine($"[red]We found some problems while generating the new persona.\nPlease correct the following errors and try again.\n{errors}[/]");
            return Result.Invalid(ex.Errors);
        }
    }, "Error generating the new persona.", ct);

    private void ShowResult(PersonaEntity persona) {
        Output.WriteLine();
        Output.WriteLine($"[teal]Name:[/] {persona.Name}");
        Output.WriteLine($"[teal]Role:[/] {persona.Role}");
        Output.WriteLine("[teal]Goals:[/]");
        Output.WriteLine(string.Join("\n", persona.Goals.Select(i => $" - {i}")));
        Output.WriteLine("[teal]Expertise:[/] [green](auto-generated)[/]");
        Output.WriteLine(persona.Expertise);
        Output.WriteLine("[teal]Traits:[/] [green](auto-generated)[/]");
        Output.WriteLine(string.Join("\n", persona.Traits.Select(i => $" - {i}")));
        Output.WriteLine("[teal]Requirements:[/] [green](auto-generated)[/]");
        Output.WriteLine(string.Join("\n", persona.Important.Select(i => $" - {i}")));
        Output.WriteLine("[teal]Restrictions:[/] [green](auto-generated)[/]");
        Output.WriteLine(string.Join("\n", persona.Negative.Select(i => $" - {i}")));
        Output.WriteLine("[teal]Other:[/] [green](auto-generated)[/]");
        Output.WriteLine(string.Join("\n", persona.Other.Select(i => $" - {i}")));
        Output.WriteLine();
    }

    private async Task AskAdditionalQuestions(PersonaEntity persona, CancellationToken lt) {
        for (var questionCount = 0; questionCount < _maxQuestions; questionCount++) {
            Output.WriteLine("[yellow]Let me see if I have more questions...[/]");
            Output.WriteLine("[grey](You can skip the questions by typing 'proceed' at any time.)[/]");

            var queries = await personaHandler.GenerateQuestion(persona);
            if (queries.Length == 0) {
                Output.WriteLine("[green]I've gathered sufficient information to generate the agent's persona.[/]");
                break;
            }
            var proceed = false;
            foreach (var query in queries) {
                query.Answer = await Input.BuildMultilinePrompt($"Question {questionCount + 1}: {query.Question}")
                                          .ShowAsync(lt);
                if (query.Answer.Equals("proceed", StringComparison.OrdinalIgnoreCase)) {
                    proceed = true;
                    break;
                }
                persona.Questions.Add(query);
            }

            if (!proceed) continue;
            Output.WriteLine("[green]Ok. Let's proceed with the Agent's Persona generation.[/]");
            break;
        }
    }

    private async Task SetUpAsync(PersonaEntity persona, CancellationToken ct) {
        persona.Name = await Input.BuildTextPrompt<string>("How would you like to call the Agent?")
                                  .AddValidation(name => PersonaEntity.ValidateName(name, personaHandler))
                                  .ShowAsync(ct);
        persona.Role = await Input.BuildTextPrompt<string>($"What is the [white]{persona.Name}[/] primary role?")
                                  .AddValidation(PersonaEntity.ValidateRole)
                                  .ShowAsync(ct);

        var goal = await Input.BuildMultilinePrompt($"What is the Main Goal for the [white]{persona.Name}[/]?")
                              .Validate(PersonaEntity.ValidateGoal)
                              .ShowAsync(ct);
        persona.Goals.AddRange(goal.Replace("\r", "").Split("\n"));
        var addAnotherGoal = await Input.ConfirmAsync("Would you like to add another goal?", ct);
        while (addAnotherGoal) {
            goal = await Input.BuildMultilinePrompt("Additional goal: ")
                              .Validate(PersonaEntity.ValidateGoal)
                              .ShowAsync(ct);
            persona.Goals.AddRange(goal.Replace("\r", "").Split("\n"));
            addAnotherGoal = await Input.ConfirmAsync("Would you like to add another goal?", ct);
        }
    }
}
 
---------------------------------------------------------------------------------------- 
Personas\Commands\PersonaListCommand.cs 
using Lola.Utilities;

namespace Lola.Personas.Commands;

public class PersonaListCommand(IHasChildren parent, IPersonaHandler personaHandler)
    : Command<PersonaListCommand>(parent, "List", n => {
        n.Aliases = ["ls"];
        n.Description = "List personas.";
        n.Help = "List all the agent's personas.";
    }) {
    protected override Result Execute() => this.HandleCommand(() => {
        Logger.LogInformation("Executing Personas->List command...");
        var personas = personaHandler.List();

        if (personas.Length == 0) {
            Output.WriteLine("[yellow]No personas found.[/]");
            Output.WriteLine();

            return Result.Success();
        }

        var sortedList = personas.OrderBy(p => p.Name);
        ShowList(sortedList);

        return Result.Success();
    }, "Error listing personas.");

    private void ShowList(IEnumerable<PersonaEntity> personas) {
        var sortedPersonas = personas.OrderBy(m => m.Name);
        var table = new Table();
        table.Expand();
        table.AddColumn(new("[yellow]Name[/]"));
        table.AddColumn(new("[yellow]Role[/]"));
        table.AddColumn(new("[yellow]Main Goal[/]"));
        foreach (var persona in sortedPersonas)
            table.AddRow(persona.Name, persona.Role, persona.Goals.FirstOrDefault() ?? "[red][Undefined][/]");
        Output.Write(table);
    }
}
 
---------------------------------------------------------------------------------------- 
Personas\Commands\PersonasCommand.cs 
using Lola.Utilities;

namespace Lola.Personas.Commands;

public class PersonasCommand(IHasChildren parent)
    : Command<PersonasCommand>(parent, "Personas", n => {
        n.Description = "Manage AI Personas.";
        n.AddCommand<PersonaListCommand>();
        n.AddCommand<PersonaGenerateCommand>();
        //n.AddCommand<PersonaUpdateCommand>();
        //n.AddCommand<PersonaRemoveCommand>();
        //n.AddCommand<PersonaViewCommand>();
        n.AddCommand<HelpCommand>();
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        Logger.LogInformation("Executing Personas->Main command...");
        var cts = CancellationTokenSource.CreateLinkedTokenSource(lt, ct);
        var choice = await Input.BuildSelectionPrompt<string>("What would you like to do?")
                                .ConvertWith(MapTo)
                                .AddChoices(Commands.ToArray(c => c.Name))
                                .ShowAsync(cts.Token);

        var command = Commands.FirstOrDefault(i => i.Name == choice);
        return command is null
                   ? Result.Success()
                   : await command.Execute([], cts.Token);

        string MapTo(string item) => Commands.FirstOrDefault(i => i.Name == item)?.Description ?? string.Empty;
    }, "Error displaying the persona menu.", ct);
}
 
---------------------------------------------------------------------------------------- 
Personas\Handlers\IPersonaHandler.cs 
using Task = System.Threading.Tasks.Task;

namespace Lola.Personas.Handlers;

public interface IPersonaHandler {
    PersonaEntity[] List();
    PersonaEntity? GetByKey(uint key);
    PersonaEntity? GetByName(string name);
    PersonaEntity Create(Action<PersonaEntity> setUp);
    void Add(PersonaEntity persona);
    void Update(PersonaEntity persona);
    void Remove(uint key);

    Task<Query[]> GenerateQuestion(PersonaEntity persona);
    Task UpdateCreatedPersona(PersonaEntity persona);
}
 
---------------------------------------------------------------------------------------- 
Personas\Handlers\PersonaHandler.cs 
using Task = System.Threading.Tasks.Task;

namespace Lola.Personas.Handlers;

public class PersonaHandler(IServiceProvider services, ILogger<PersonaHandler> logger)
    : IPersonaHandler {
    private readonly IModelHandler _modelHandler = services.GetRequiredService<IModelHandler>();
    private readonly IUserProfileHandler _userHandler = services.GetRequiredService<IUserProfileHandler>();
    private readonly IPersonaDataSource _dataSource = services.GetRequiredService<IPersonaDataSource>();
    private readonly ITaskHandler _taskHandler = services.GetRequiredService<ITaskHandler>();
    private readonly IAgentAccessor _connectionAccessor = services.GetRequiredService<IAgentAccessor>();

    public PersonaEntity[] List() => _dataSource.GetAll();

    public PersonaEntity? GetByKey(uint key) => _dataSource.FindByKey(key);
    public PersonaEntity? GetByName(string name) => _dataSource.Find(p => p.Name.Equals(name, StringComparison.OrdinalIgnoreCase));

    public PersonaEntity Create(Action<PersonaEntity> setUp)
        => _dataSource.Create(setUp);

    public void Add(PersonaEntity persona) {
        if (_dataSource.FindByKey(persona.Key) != null)
            throw new InvalidOperationException($"A persona with the key '{persona.Key}' already exists.");

        _dataSource.Add(persona);
        logger.LogInformation("Added new persona: {PersonaKey} => {PersonaName}", persona.Name, persona.Key);
    }

    public void Update(PersonaEntity persona) {
        if (_dataSource.FindByKey(persona.Key) == null)
            throw new InvalidOperationException($"Persona with key '{persona.Key}' not found.");

        _dataSource.Update(persona);
        logger.LogInformation("Updated persona: {PersonaKey} => {PersonaName}", persona.Name, persona.Key);
    }

    public void Remove(uint key) {
        var persona = _dataSource.FindByKey(key)
                     ?? throw new InvalidOperationException($"Persona with key '{key}' not found.");

        _dataSource.Remove(key);
        logger.LogInformation("Removed persona: {PersonaKey} => {PersonaName}", persona.Name, persona.Key);
    }

    public async Task<Query[]> GenerateQuestion(PersonaEntity persona) {
        try {
            var appModel = _modelHandler.Selected ?? throw new InvalidOperationException("No default AI model selected.");
            var httpConnection = _connectionAccessor.GetFor(appModel.Provider!.Name);
            var userProfileEntity = _userHandler.CurrentUser ?? throw new InvalidOperationException("No user found.");
            var personaEntity = GetByKey(1) ?? throw new InvalidOperationException("Required persona not found. Name: 'Agent Creator'.");
            var taskEntity = _taskHandler.GetByKey(1) ?? throw new InvalidOperationException("Required task not found. Name: 'Ask Questions about the AI Agent'.");
            var context = new JobContext {
                Model = appModel,
                Agent = httpConnection,
                UserProfile = userProfileEntity,
                Persona = personaEntity,
                Task = taskEntity,
                Input = persona,
            };
            var job = new Job(context);
            job.Converters.Add(typeof(List<Query>),
                               v => {
                                   var list = (List<Query>)v;
                                   if (list.Count == 0) return string.Empty;
                                   var sb = new StringBuilder();
                                   foreach (var item in list) {
                                       sb.AppendLine($"Q: {item.Question}");
                                       sb.AppendLine($"{item.Explanation}");
                                       sb.AppendLine($"A: {item.Answer}");
                                   }
                                   return sb.ToString();
                               });
            var result = await job.Execute(CancellationToken.None);
            if (result.HasException) throw new("Failed to generate next question: " + result.Exception.Message);
            var response = context.OutputAsMap.GetList<Map>("Questions");
            return response.ToArray(i => new Query {
                Question = i.GetRequiredValueAs<string>(nameof(Query.Question)),
                Explanation = i.GetRequiredValueAs<string>(nameof(Query.Explanation)),
            });
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error generating next question for persona {PersonaName}", persona.Name);
            throw;
        }
    }

    public async Task UpdateCreatedPersona(PersonaEntity persona) {
        try {
            var appModel = _modelHandler.Selected ?? throw new InvalidOperationException("No default AI model selected.");
            var httpConnection = _connectionAccessor.GetFor(appModel.Provider!.Name);
            var userProfileEntity = _userHandler.CurrentUser ?? throw new InvalidOperationException("No user found.");
            var personaEntity = GetByKey(1) ?? throw new InvalidOperationException("Required persona not found. Name: 'Agent Creator'.");
            var taskEntity = _taskHandler.GetByKey(2) ?? throw new InvalidOperationException("Required task not found. Name: 'Ask Questions about the AI Agent'.");
            var context = new JobContext {
                Model = appModel,
                Agent = httpConnection,
                UserProfile = userProfileEntity,
                Persona = personaEntity,
                Task = taskEntity,
                Input = persona,
            };
            var job = new Job(context);
            job.Converters.Add(typeof(List<Query>),
                               v => {
                                   var list = (List<Query>)v;
                                   if (list.Count == 0) return string.Empty;
                                   var sb = new StringBuilder();
                                   foreach (var item in list) {
                                       sb.AppendLine($"Q: {item.Question}");
                                       sb.AppendLine($"{item.Explanation}");
                                       sb.AppendLine($"A: {item.Answer}");
                                   }
                                   return sb.ToString();
                               });
            var result = await job.Execute(CancellationToken.None);
            if (result.HasException) throw new("Failed to generate next question: " + result.Exception.Message);
            persona.Role = context.OutputAsMap.GetRequiredValueAs<string>(nameof(Persona.Role));
            persona.Goals = context.OutputAsMap.GetRequiredList<string>(nameof(Persona.Goals));
            persona.Expertise = context.OutputAsMap.GetRequiredValueAs<string>(nameof(Persona.Expertise));
            persona.Traits = context.OutputAsMap.GetRequiredList<string>(nameof(Persona.Traits));
            persona.Important = context.OutputAsMap.GetRequiredList<string>(nameof(Persona.Important));
            persona.Negative = context.OutputAsMap.GetRequiredList<string>(nameof(Persona.Negative));
            persona.Other = context.OutputAsMap.GetRequiredList<string>(nameof(Persona.Other));
        }
        catch (Exception ex) {
            logger.LogError(ex, "Error generating next question for persona {PersonaName}", persona.Name);
            throw;
        }
    }
}
 
---------------------------------------------------------------------------------------- 
Personas\Repositories\IPersonaDataSource.cs 
namespace Lola.Personas.Repositories;

public interface IPersonaDataSource
    : IDataSource<PersonaEntity, uint>;
 
---------------------------------------------------------------------------------------- 
Personas\Repositories\IPersonaStorage.cs 
namespace Lola.Personas.Repositories;

public interface IPersonaStorage
    : IStorage<PersonaEntity, uint>;
 
---------------------------------------------------------------------------------------- 
Personas\Repositories\PersonaDataSource.cs 
namespace Lola.Personas.Repositories;

public class PersonaDataSource(IPersonaStorage storage)
    : DataSource<IPersonaStorage, PersonaEntity, uint>(storage),
      IPersonaDataSource;
 
---------------------------------------------------------------------------------------- 
Personas\Repositories\PersonaEntity.cs 
namespace Lola.Personas.Repositories;

public class PersonaEntity
    : Entity<PersonaEntity, uint> {
    public string Name { get; set; } = string.Empty;
    public string Role { get; set; } = string.Empty;
    public List<string> Goals { get; set; } = [];

    public List<Query> Questions { get; init; } = [];

    public string Expertise { get; set; } = string.Empty;
    public List<string> Traits { get; set; } = [];
    public List<string> Important { get; set; } = [];
    public List<string> Negative { get; set; } = [];
    public List<string> Other { get; set; } = [];

    public override Result Validate(IMap? context = null) {
        var result = base.Validate(context);
        result += ValidateName(Name, IsNotNull(context).GetRequiredValueAs<IPersonaHandler>(nameof(PersonaHandler)));
        result += ValidateRole(Role);
        result += ValidateGoals(Goals);
        return result;
    }

    public static implicit operator Map(PersonaEntity entity)
        => new() {
            ["Name"] = entity.Name,
            ["Role"] = entity.Role,
            ["Goals"] = entity.Goals,
            ["Questions"] = entity.Questions,
        };

    public static implicit operator Persona(PersonaEntity entity)
        => new(entity.Key) {
            Name = entity.Name,
            Role = entity.Role,
            Goals = entity.Goals,
            Expertise = entity.Expertise,
            Traits = entity.Traits,
            Important = entity.Important,
            Negative = entity.Negative,
            Other = entity.Other,
        };

    public static Result ValidateName(string? name, IPersonaHandler handler) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(name))
            result += new ValidationError("The name is required.", nameof(Name));
        else if (handler.GetByName(name) is not null)
            result += new ValidationError("A persona with this name is already registered.", nameof(Name));
        return result;
    }

    public static Result ValidateRole(string? role) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(role))
            result += new ValidationError("The role is required.", nameof(Name));
        return result;
    }

    public static Result ValidateGoal(string? goal) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(goal))
            result += new ValidationError("The goal cannot be null or empty.", nameof(Goals));
        return result;
    }

    public static Result ValidateGoals(List<string> goals) {
        var result = Result.Success();
        if (goals.Count == 0)
            result += new ValidationError("At least one goal is required.", nameof(Goals));
        return goals.Aggregate(result, (current, goal) => current + ValidateGoal(goal));
    }
}
 
---------------------------------------------------------------------------------------- 
Personas\Repositories\PersonaStorage.cs 
namespace Lola.Personas.Repositories;

public class PersonaStorage(IConfiguration configuration)
    : JsonFilePerTypeStorage<PersonaEntity, uint>("personas", configuration),
      IPersonaStorage {
    protected override uint FirstKey { get; } = 1;

    protected override bool TryGenerateNextKey(out uint next) {
        next = LastUsedKey == default ? FirstKey : ++LastUsedKey;
        return true;
    }
}
 
---------------------------------------------------------------------------------------- 
Personas\Repositories\Query.cs 
namespace Lola.Personas.Repositories;

public class Query {
    public string Question { get; set; } = string.Empty;
    public string Explanation { get; set; } = string.Empty;
    public string Answer { get; set; } = string.Empty;
}
 
---------------------------------------------------------------------------------------- 
Providers\Commands\ProviderAddCommand.cs 
using Lola.Utilities;

using Task = System.Threading.Tasks.Task;
using ValidationException = DotNetToolbox.Results.ValidationException;

namespace Lola.Providers.Commands;

public class ProviderAddCommand(IHasChildren parent, IProviderHandler handler)
    : Command<ProviderAddCommand>(parent, "Add", n => {
        n.Aliases = ["new"];
        n.Description = "Add provider";
        n.Help = "Register a new LLM provider to use with your AI agents.";
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        try {
            Logger.LogInformation("Executing Providers->Add command...");
            var provider = new ProviderEntity();
            await SetUpAsync(provider, lt);
            handler.Add(provider);
            Output.WriteLine($"[green]Provider '{provider.Name}' added successfully.[/]");
            Logger.LogInformation("Provider '{ProviderKey}:{ProviderName}' added successfully.", provider.Key, provider.Name);
            return Result.Success();
        }
        catch (ValidationException ex) {
            var errors = string.Join("\n", ex.Errors.Select(e => $" - {e.Source}: {e.Message}"));
            Logger.LogWarning("Error adding the new provider. Validation errors:\n{Errors}", errors);
            Output.WriteLine($"[red]We found some problems while adding the provider. Please correct the following errors and try again:\n{errors}[/]");
            return Result.Invalid(ex.Errors);
        }
    }, "Error adding the new provider.", ct);

    private async Task SetUpAsync(ProviderEntity provider, CancellationToken ct)
        => provider.Name = await Input.BuildTextPrompt<string>("What is the name of the LLM provider?")
                                .AddValidation(name => ProviderEntity.ValidateName(name, handler))
                                .ShowAsync(ct);
}
 
---------------------------------------------------------------------------------------- 
Providers\Commands\ProviderListCommand.cs 
using Lola.Utilities;

namespace Lola.Providers.Commands;

public class ProviderListCommand(IHasChildren parent, IProviderHandler providerHandler)
    : Command<ProviderListCommand>(parent, "List", n => {
        n.Aliases = ["ls"];
        n.Description = "List providers";
        n.Help = "List all LLM providers.";
    }) {
    protected override Result Execute() => this.HandleCommand(() => {
        Logger.LogInformation("Executing Providers->List command...");
        var providers = providerHandler.List();
        if (providers.Length == 0) {
            Output.WriteLine("[yellow]No providers found.[/]");
            Logger.LogInformation("No providers found. List providers action cancelled.");
            return Result.Success();
        }

        var sortedList = providers.OrderBy(p => p.Name);
        ShowList(sortedList);

        Logger.LogInformation("Providers listed.");
        return Result.Success();
    }, "Error listing the providers.");

    private void ShowList(IEnumerable<ProviderEntity> providers) {
        var table = new Table();
        table.AddColumn(new("[yellow]Id[/]"));
        table.AddColumn(new("[yellow]Name[/]"));
        foreach (var provider in providers) {
            table.AddRow(provider.Key.ToString(), provider.Name);
        }

        Output.Write(table);
    }
}
 
---------------------------------------------------------------------------------------- 
Providers\Commands\ProviderRemoveCommand.cs 
using Lola.Utilities;

namespace Lola.Providers.Commands;

public class ProviderRemoveCommand(IHasChildren parent, IProviderHandler handler, IModelHandler modelHandler)
    : Command<ProviderRemoveCommand>(parent, "Remove", n => {
        n.Aliases = ["delete", "del"];
        n.Description = "Remove provider";
        n.Help = "Remove a LLM provider.";
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        Logger.LogInformation("Executing Providers->Remove command...");
        var result = await SelectProvider(handler, lt);
        if (!result.IsSuccess) return result;
        var provider = result.Value;

        var models = modelHandler.List(provider.Key);
        if (models.Length > 0) {
            Output.WriteLine("[yellow bold]The following model(s) will also be deleted.[/]");
            ShowList(models);
        }

        if (!Input.Confirm($"Are you sure you want to delete '{provider.Name}' ({provider.Key})?")) {
            Logger.LogInformation("Provider remove action cancelled.");
            return Result.Success();
        }

        handler.Remove(provider.Key);
        Output.WriteLine($"[green]Provider with key '{provider.Name}' removed successfully.[/]");
        Logger.LogInformation("Provider '{ProviderKey}:{ProviderName}' removed successfully.", provider.Key, provider.Name);
        return Result.Success();
    }, "Error removing the provider.", ct);

    private async Task<Result<ProviderEntity>> SelectProvider(IProviderHandler handler, CancellationToken lt) {
        var providers = handler.List();
        if (providers.Length == 0) {
            Output.WriteLine("[yellow]No LLM providers found.[/]");
            Logger.LogInformation("No LLM providers found.");
            return Result.Invalid<ProviderEntity>(new ValidationError("No LLM providers found."));
        }
        var provider = await this.SelectEntityAsync<ProviderEntity, uint>(providers.OrderBy(p => p.Name), m => m.Name, lt);
        if (provider is null) {
            Logger.LogInformation("No LLM provider selected.");
            return Result.Invalid<ProviderEntity>(new ValidationError("No LLM provider selected."));
        }
        return Result.Success(provider);
    }

    private void ShowList(ModelEntity[] models) {
        var table = new Table();
        table.AddColumn("Settings Key");
        table.AddColumn("Settings Name");
        foreach (var model in models) {
            table.AddRow(model.Key, model.Name);
        }
        Output.Write(table);
    }
}
 
---------------------------------------------------------------------------------------- 
Providers\Commands\ProvidersCommand.cs 
using Lola.Utilities;

namespace Lola.Providers.Commands;

public class ProvidersCommand(IHasChildren parent)
    : Command<ProvidersCommand>(parent, "Providers", n => {
        n.Description = "Manage LLM Providers.";
        n.Help = "Register, update, or remove LLM providers.";
        n.AddCommand<ProviderListCommand>();
        n.AddCommand<ProviderAddCommand>();
        n.AddCommand<ProviderViewCommand>();
        n.AddCommand<ProviderUpdateCommand>();
        n.AddCommand<ProviderRemoveCommand>();
        n.AddCommand<HelpCommand>();
        n.AddCommand<BackCommand>();
        n.AddCommand<ExitCommand>();
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        Logger.LogInformation("Showing Providers main menu...");
        var choice = await Input.BuildSelectionPrompt<string>("What would you like to do?")
                                .ConvertWith(MapTo)
                                .AddChoices(Commands.ToArray(c => c.Name))
                                .ShowAsync(lt);

        var command = Commands.FirstOrDefault(i => i.Name == choice);
        return command is null
            ? Result.Success()
            : await command.Execute([], lt);

        string MapTo(string item) => Commands.FirstOrDefault(i => i.Name == item)?.Description ?? string.Empty;
    }, "Error displaying provider's menu.", ct);
}
 
---------------------------------------------------------------------------------------- 
Providers\Commands\ProviderUpdateCommand.cs 
using Lola.Utilities;

using Task = System.Threading.Tasks.Task;
using ValidationException = DotNetToolbox.Results.ValidationException;

namespace Lola.Providers.Commands;

public class ProviderUpdateCommand(IHasChildren parent, IProviderHandler handler)
    : Command<ProviderUpdateCommand>(parent, "Update", n => {
        n.Aliases = ["edit"];
        n.Description = "Update provider";
        n.Help = "Update a LLM provider.";
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        try {
            Logger.LogInformation("Executing Providers->Update command...");
            var providers = handler.List();
            if (providers.Length == 0) {
                Output.WriteLine("[yellow]No providers found.[/]");
                Logger.LogInformation("No providers found. Remove provider action cancelled.");
                return Result.Success();
            }
            var provider = await this.SelectEntityAsync<ProviderEntity, uint>(providers.OrderBy(p => p.Name), m => m.Name, lt);
            if (provider is null) {
                Logger.LogInformation("Provider updated action cancelled.");
                return Result.Success();
            }
            await SetUpAsync(provider, lt);

            handler.Update(provider);
            Output.WriteLine($"[green]Provider '{provider.Name}' updated successfully.[/]");
            Logger.LogInformation("Provider '{ProviderKey}:{ProviderName}' updated successfully.", provider.Key, provider.Name);
            return Result.Success();
        }
        catch (ValidationException ex) {
            var errors = string.Join("\n", ex.Errors.Select(e => $" - {e.Source}: {e.Message}"));
            Logger.LogWarning("Error updating the provider. Validation errors:\n{Errors}", errors);
            Output.WriteLine($"[red]We found some problems while updating the provider. Please correct the following errors and try again:\n{errors}[/]");
            return Result.Invalid(ex.Errors);
        }
    }, "Error updating the provider.", ct);

    private async Task SetUpAsync(ProviderEntity provider, CancellationToken ct)
        => provider.Name = await Input.BuildTextPrompt<string>("Enter the new name for the provider")
                                .AddValidation(name => ProviderEntity.ValidateName(name, handler))
                                .ShowAsync(ct);
}
 
---------------------------------------------------------------------------------------- 
Providers\Commands\ProviderViewCommand.cs 
using Lola.Utilities;

namespace Lola.Providers.Commands;

public class ProviderViewCommand(IHasChildren parent, IProviderHandler handler)
    : Command<ProviderViewCommand>(parent, "Info", n => {
        n.Aliases = ["i"];
        n.Description = "View provider";
        n.Help = "Display the detailed information about a Provider.";
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        Logger.LogInformation("Executing Providers->View command...");
        var providers = handler.List();
        if (providers.Length == 0) {
            Output.WriteLine("[yellow]No providers found.[/]");
            Logger.LogInformation("No providers found. View provider action cancelled.");
            return Result.Success();
        }

        var provider = await this.SelectEntityAsync<ProviderEntity, uint>(providers.OrderBy(p => p.Name), m => m.Name, lt);
        if (provider is null) {
            Logger.LogInformation("No provider selected.");
            return Result.Success();
        }

        ShowDetails(provider);
        return Result.Success();
    }, "Error displaying the provider.", ct);

    private void ShowDetails(ProviderEntity provider) {
        Output.WriteLine("[yellow]Provider Information:[/]");
        Output.WriteLine($"[blue]Name:[/] {provider.Name}");
        Output.WriteLine($"[blue]API Key:[/] {provider.ApiKey ?? "[red]Not Set[/]"}");
    }
}
 
---------------------------------------------------------------------------------------- 
Providers\Handlers\IProviderHandler.cs 
namespace Lola.Providers.Handlers;

public interface IProviderHandler {
    ProviderEntity[] List();
    ProviderEntity? GetByKey(uint key);
    ProviderEntity? GetByName(string name);
    void Add(ProviderEntity provider);
    void Update(ProviderEntity provider);
    void Remove(uint key);
}
 
---------------------------------------------------------------------------------------- 
Providers\Handlers\ProviderHandler.cs 
using ValidationException = DotNetToolbox.Results.ValidationException;

namespace Lola.Providers.Handlers;

public class ProviderHandler(IProviderDataSource dataSource, Lazy<IModelHandler> modelHandler, ILogger<ProviderHandler> logger)
    : IProviderHandler {
    private readonly IProviderDataSource _dataSource = dataSource;
    private readonly Lazy<IModelHandler> _modelHandler = modelHandler;
    private readonly ILogger<ProviderHandler> _logger = logger;
    public ProviderEntity[] List() => _dataSource.GetAll();

    public ProviderEntity? GetByKey(uint key) => _dataSource.FindByKey(key);
    public ProviderEntity? GetByName(string name) => _dataSource.Find(p => p.Name.Equals(name, StringComparison.OrdinalIgnoreCase));

    public void Add(ProviderEntity provider) {
        if (GetByKey(provider.Key) != null)
            throw new ValidationException($"A provider with the key '{provider.Key}' already exists.");

        var context = Map.FromValue(nameof(ProviderHandler), this);
        var result = provider.Validate(context);
        if (!result.IsSuccess)
            throw new ValidationException(result.Errors);

        _dataSource.Update(provider);
        _logger.LogInformation("Added new provider: {ProviderKey} => {ProviderName}", provider.Name, provider.Key);
    }

    public void Update(ProviderEntity provider) {
        if (GetByKey(provider.Key) is null)
            throw new ValidationException($"Provider with key '{provider.Key}' not found.");

        var context = Map.FromValue(nameof(ProviderHandler), this);
        var result = provider.Validate(context);
        if (!result.IsSuccess)
            throw new ValidationException(result.Errors);

        _dataSource.Update(provider);
        _logger.LogInformation("Updated provider: {ProviderKey} => {ProviderName}", provider.Name, provider.Key);
    }

    public void Remove(uint key) {
        var provider = GetByKey(key) ?? throw new ValidationException($"Provider with key '{key}' not found.");

        var models = _modelHandler.Value.List(provider.Key);
        foreach (var model in models) {
            _modelHandler.Value.Remove(model.Key);
        }
        _logger.LogInformation("Removed all models from provider: {ProviderKey}", key);

        _dataSource.Remove(key);
        _logger.LogInformation("Removed provider: {ProviderKey} => {ProviderName}", provider.Name, provider.Key);
    }
}
 
---------------------------------------------------------------------------------------- 
Providers\Repositories\IProviderDataSource.cs 
namespace Lola.Providers.Repositories;

public interface IProviderDataSource
    : IDataSource<ProviderEntity, uint>;
 
---------------------------------------------------------------------------------------- 
Providers\Repositories\IProviderStorage.cs 
namespace Lola.Providers.Repositories;

public interface IProviderStorage
    : IStorage<ProviderEntity, uint>;
 
---------------------------------------------------------------------------------------- 
Providers\Repositories\ProviderDataSource.cs 
namespace Lola.Providers.Repositories;

public sealed class ProviderDataSource(IProviderStorage storage)
    : DataSource<IProviderStorage, ProviderEntity, uint>(storage),
      IProviderDataSource;
 
---------------------------------------------------------------------------------------- 
Providers\Repositories\ProviderEntity.cs 
namespace Lola.Providers.Repositories;

public class ProviderEntity
    : Entity<ProviderEntity, uint> {
    public string Name { get; set; } = string.Empty;
    public string? ApiKey { get; set; }

    public override Result Validate(IMap? context = null) {
        var result = base.Validate(context);
        result += ValidateName(Name, IsNotNull(context).GetRequiredValueAs<IProviderHandler>(nameof(ProviderHandler)));
        return result;
    }

    public static Result ValidateName(string? name, IProviderHandler handler) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(name))
            result += new ValidationError("The name is required.", nameof(Name));
        else if (handler.GetByName(name) is not null)
            result += new ValidationError("A provider with this name is already registered.", nameof(Name));
        return result;
    }

    public static Result ValidateApiKey(string? apiKey) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(apiKey))
            result += new ValidationError("The API Key is required.", nameof(Name));
        return result;
    }
}
 
---------------------------------------------------------------------------------------- 
Providers\Repositories\ProviderStorage.cs 
namespace Lola.Providers.Repositories;

public sealed class ProviderStorage(IConfiguration configuration)
    : JsonFilePerTypeStorage<ProviderEntity, uint>("providers", configuration),
      IProviderStorage {
    protected override uint FirstKey { get; } = 1;

    protected override bool TryGenerateNextKey(out uint next) {
        next = LastUsedKey == default ? FirstKey : ++LastUsedKey;
        return true;
    }
}
 
---------------------------------------------------------------------------------------- 
saved\agents.json 
[] 
---------------------------------------------------------------------------------------- 
saved\models.json 
[
  {
    "ProviderKey": 1,
    "Name": "GPT-4o",
    "MaximumContextSize": 128000,
    "MaximumOutputTokens": 4096,
    "InputCostPerMillionTokens": 5,
    "OutputCostPerMillionTokens": 15,
    "TrainingDataCutOff": "2023-10-01",
    "Selected": false,
    "Key": "gpt-4o"
  },
  {
    "ProviderKey": 2,
    "Name": "Claude 3.5 Sonnet",
    "MaximumContextSize": 200000,
    "MaximumOutputTokens": 8192,
    "InputCostPerMillionTokens": 3,
    "OutputCostPerMillionTokens": 15,
    "TrainingDataCutOff": "2024-04-01",
    "Selected": true,
    "Key": "claude-3-5-sonnet-20240620"
  }
] 
---------------------------------------------------------------------------------------- 
saved\personas.json 
[
  {
    "Name": "Agent Creator",
    "Role": "AI Agent Description Specialist",
    "Goals": [
      "create detailed, accurate, and tailored descriptions for various AI agents"
    ],
    "Questions": [],
    "Expertise": "AI capabilities, roles, and effective prompt engineering",
    "Traits": [
      "You carefully break down requirements and information to create comprehensive agent descriptions.",
      "You can create descriptions for a wide range of AI agent types and purposes.",
      "You ensure all aspects of an agent\u0027s role and capabilities are highly detailed and clearly defined.",
      "You can come up with unique and effective ways to describe AI agents\u0027 functions and limitations.",
      "You prioritize clear, concise, and unambiguous language in your descriptions.",
      "You are able to adapt your descriptions to different contexts and requirements."
    ],
    "Important": [
      "always prioritize clarity and specificity in your agent descriptions.",
      "include both capabilities and limitations in every agent description.",
      "ensure that the descriptions you create are ethically sound and promote responsible AI use."
    ],
    "Negative": [
      "create descriptions for AI agents that could be used for harmful or illegal purposes",
      "misrepresent an AI agent\u0027s capabilities or limitations",
      "use ambiguous or vague language in your descriptions"
    ],
    "Other": [
      "You have extensive knowledge of various AI models and their capabilities.",
      "You understand the importance of ethical AI behavior and incorporate this into your descriptions.",
      "You are familiar with different domains and can tailor agent descriptions to specific fields."
    ],
    "Key": 1
  },
  {
    "Name": "Master Coder",
    "Role": "Senior .NET C# Full-Stack Developer",
    "Goals": [
      "Produce high-quality software according to the USER\u0027s requirements using the best coding practices."
    ],
    "Questions": [
      {
        "Question": "What specific areas of .NET and C# development should Master Coder specialize in? (e.g., ASP.NET Core, WPF, Xamarin, Entity Framework, etc.)",
        "Explanation": "This will help define the agent\u0027s expertise within the .NET ecosystem and ensure it can provide targeted assistance in relevant technologies.",
        "Answer": "All of them. He should have expertise in all of the C# .Net platform."
      }
    ],
    "Expertise": "You are an expert in all aspects of the C# .NET platform, including but not limited to ASP.NET Core, WPF, Xamarin, Entity Framework, and other related technologies.",
    "Traits": [
      "Versatile: You are proficient in multiple technologies within the .NET ecosystem, allowing you to tackle diverse programming challenges.",
      "Detail-oriented: You pay close attention to code quality, structure, and performance optimizations.",
      "Problem-solver: You excel at breaking down complex software requirements into manageable components and finding effective solutions.",
      "Continuous learner: You stay updated with the latest developments in .NET and C# technologies to maintain your expertise."
    ],
    "Important": [
      "**IMPORTANT,** You MUST always prioritize writing clean, maintainable, and efficient code.",
      "**IMPORTANT,** ALWAYS adhere to best coding practices and design patterns appropriate for .NET and C# development.",
      "**IMPORTANT,** You MUST provide clear explanations and justifications for your code design decisions.",
      "**IMPORTANT,** ALWAYS consider scalability, security, and performance in your software solutions."
    ],
    "Negative": [
      "**NEVER, IN ANY CIRCUMSTANCE,** produce code that is insecure, inefficient, or fails to meet the USER\u0027s requirements.",
      "**NEVER, IN ANY CIRCUMSTANCE,** ignore or dismiss best practices in software development and .NET programming.",
      "**NEVER, IN ANY CIRCUMSTANCE,** provide outdated or deprecated solutions without explicitly mentioning their status.",
      "**NEVER, IN ANY CIRCUMSTANCE,** skip proper error handling and input validation in your code examples or suggestions."
    ],
    "Other": [
      "Familiar with agile development methodologies",
      "Capable of providing guidance on software architecture and system design",
      "Knowledgeable about database design and optimization for .NET applications",
      "Experienced in integrating third-party APIs and services into .NET applications"
    ],
    "Key": 2
  }
] 
---------------------------------------------------------------------------------------- 
saved\providers.json 
[
  {
    "Name": "OpenAI",
    "Key": 1
  },
  {
    "Name": "Anthropic",
    "Key": 2
  }
] 
---------------------------------------------------------------------------------------- 
saved\tasks.json 
[
  {
    "Assumptions": [
      "The user has already provided a Name, Role, and list of Goals for the AI agent",
      "The user may not be an expert in AI or agent design, so questions should be clear and avoid overly technical jargon",
      "The questions generated will be used in a subsequent step to create a full agent description",
      "The Agent is an AI agent so, it is limited to the capabilities of a AI agent.",
      "The Agent will only interact with the USER and the tools he have available to execute the task."
    ],
    "Constraints": [
      "make assumptions about the agent's capabilities beyond what is explicitly stated in the provided information",
      "generate questions about technical implementation details that the average user wouldn't be able to answer",
      "include questions that have already been answered by the provided Name, Role, and Goals",
      "include questions that were already answered by the user in a previous interaction"
    ],
    "Examples": [
      "Input:\nName: EcoAdvise\nRole: Environmental Sustainability Consultant\nGoals:\n1. Provide personalized advice on reducing carbon footprint\n2. Educate users on environmental issues\n3. Suggest eco-friendly alternatives for daily activities\n\nResponse:\n{\"Questions\":[{\"Question\":\"What level of expertise should EcoAdvise have? (e.g., general knowledge, academic-level, or industry-expert level)\",\"Explanation\":\"This will help determine the depth and complexity of advice the agent can provide.\"}]}",
      "Input:\nName: CodeCraft\nRole: Programming Assistant\nGoals:\n1. Help users debug their code\n2. Explain programming concepts\n3. Suggest optimizations for code efficiency\nPrevious Questions:\nQ: What programming languages should CodeCraft be proficient in?\nThis will define the scope of the agent's expertise and ensure it can assist with relevant languages.\nA: C# .NET\n\nResponse:\n{\"Questions\":[{\"Question\":\"Should CodeCraft be able to generate code snippets or complete functions, or only provide guidance?\",\"Explanation\":\"This will clarify the extent of the agent's coding capabilities and set appropriate user expectations.\"}]}"
    ],
    "Guidelines": [
      "Begin by carefully analyzing the provided Name, Role, and Goals to understand the general direction of the agent.",
      "Generate questions that cover different aspects of the agent, such as:\n- Specific capabilities within the given role;\n- Intended user interaction style;\n- Ethical guidelines and limitations;\n- Knowledge base and areas of expertise; and\n- Personality traits or communication style;",
      "Ensure questions are open-ended to encourage detailed responses.",
      "Frame questions in a way that helps users think deeply about their agent's design.",
      "Include a mix of questions about both capabilities and limitations."
    ],
    "Goals": [
      "generate insightful and relevant questions that will help users further define the characteristics, capabilities, and limitations of the AI agent they want to create",
      "analyze the provided Name, Role, and Goals of the prospective AI agent",
      "identify areas where more information is needed to create a comprehensive agent description",
      "generate clear, specific questions that will elicit useful information from the user",
      "ensure that the questions cover a wide range of agent characteristics, including capabilities, limitations, ethical considerations, and interaction style",
      "adapt the questions based on the context provided by the initial input"
    ],
    "InputTemplate": "Name: <<Name>>\nMain Role: <<Role>>\nGoals:\n<<Goals>>\nPrevious Questions:\n<<Questions>>\n",
    "Internal": true,
    "Key": 1,
    "Name": "Ask Questions about the AI Agent",
    "Scope": [
      "generating questions based solely on the Name, Role, and Goals provided by the user",
      "focusing on aspects of the agent that are not fully clear from the initial information",
      "covering various aspects of agent design, including but not limited to: knowledge base, interaction style, ethical guidelines, specific capabilities, and limitations"
    ],
    "Requirements": [
      "generate ONE question per request",
      "generate questions directly relevant to the provided Name, Role, and Goals",
      "generate questions designed to elicit specific, actionable information for agent creation",
      "generate an output that is a valid JSON file following strictly the schema defined in the prompt"
    ],
    "ResponseSchema": "{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"Questions\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"Question\":{\"type\":\"string\"},\"Explanation\":{\"type\":\"string\"}},\"required\":[\"Explanation\",\"Question\"]}}}}",
    "ResponseType": "Json",
    "Validations": [
      "Ensuring each question is directly relevant to the provided Name, Role, and Goals",
      "Checking that the set of questions covers a diverse range of agent characteristics",
      "Verifying that each question is clear, concise, and likely to elicit useful information",
      "Confirming that the questions do not make unwarranted assumptions about the agent",
      "Reviewing the brief explanations to ensure they clearly convey why each question is important"
    ]
  },
  {
    "Assumptions": [
      "The user has provided a Name, Role, and list of Goals for the AI agent",
      "The user has answered additional questions about the AI agent",
      "All provided information is relevant to the Persona creation",
      "The Agent is an AI agent so, it is limited to the capabilities of a AI agent.",
      "The Agent will only interact with the USER and the tools he have available to execute the task."
    ],
    "Constraints": [
      "introduce new information that isn't derived from the user's input or question responses",
      "generate properties that contradict the provided Name, Role, Goals or Answered Questions",
      "include traits in multiple categories (e.g., a trait shouldn't appear in both Traits and Important lists)"
    ],
    "Examples": [
      "Input:\nName: EcoAdvise\nRole: Environmental Sustainability Consultant\nGoals:\n1. Provide personalised advice at reducing carbon footprint\n2. Educate the users on environmental issues\n3. Suggest eco-friendly alternative for daiyl activities\nQuestions:\nQ: What level of expertise should EcoAdvise have?\nThis question will help identify the scope and depth of the knowledge that the agent have.\nA: EcoAdvise should have industry-expert level knowledge.\nQ: How should EcoAdvise balance between providing scientific facts and motivating users?\nThis question will help define the type of answer the user is expecting.\nA: EcoAdvise should use a 70-30 split, with 70% focus on scientific facts and 30% on motivation.\n\nOutput:\n{\"Role\":\"Environmental Sustainability Consultant\",\"Goals\":[\"Provide personalized advice on reducing carbon footprint\",\"Educate the user on environmental issues\",\"Suggest eco-friendly alternatives for daily activities\"],\"Expertise\":\"Advanced environmental science with a focus on sustainability and carbon footprint reduction\",\"Traits\":[\"Broadly Knowlegeable: Knowledgeable about global and local environmental issues\",\"Excellent Communicator: Able to communicate complex scientific concepts clearly\",\"Data-Driven: Data-driven in approach to sustainability\"],\"Important\":[\"You MUST provide accurate, up-to-date environmental information\",\"ALWAYS respects user privacy when handling location data\",\"You MUST balances scientific facts with motivational encouragement\"],\"Negative\":[\"be alarmist or overly pessimistic about environmental issues\",\"recommend unsustainable or unethical practices\",\"ignore local context in sustainability advice\"],\"Other\":[\"Uses a 70-30 split between scientific facts and motivation in communications\",\"Capable of tailoring advice to specific geographic locations\",\"Stays updated on the latest environmental research and sustainability practices\"]}\n"
    ],
    "Guidelines": [
      "Begin by carefully analyzing all provided information: Name, Role, Goals, and question responses",
      "For Expertise, identify the core area of knowledge or skill central to the Persona's role and goals",
      "For Traits, identify characteristics that support the Persona's role and goals but aren't crucial",
      "For Important, identify crucial characteristics without which the Persona couldn't fulfill its role or achieve its goals",
      "For Negative, identify traits or behaviors that would hinder the Persona's effectiveness or contradict its purpose",
      "For Other, include any relevant information that doesn't fit into the above categories but adds depth to the Persona",
      "Ensure all generated properties align with the Persona's Name, Role, and Goals",
      "Provide clear, concise explanations for each generated property"
    ],
    "Goals": [
      "generate the Expertise, Traits, Important, Negative, and Other properties of the Persona",
      "ensure that the generated properties are consistent with the initial input and question responses",
      "create a comprehensive and coherent Persona description",
      "provide explanations for each generated property to justify its relevance to the Persona"
    ],
    "InputTemplate": "Name: <<Name>>\nMain Role: <<Role>>\nGoals:\n<<Goals>>\nQuestions:\n<<Questions>>\n",
    "Internal": true,
    "Key": 2,
    "Name": "Generate AI Agent Persona",
    "Scope": [
      "generating the Expertise, Traits, Important, Negative, and Other properties based solely on the provided information",
      "ensuring all generated properties align with the Persona's Name, Role, and Goals",
      "focusing on creating a well-rounded and consistent Persona description"
    ],
    "Requirements": [
      "generate all five properties: Expertise, Traits, Important, Negative, and Other",
      "rewrite the Role and Goals properties with correct English without changing their intended contents",
      "ensure the Role property is a text that is a continuation of: 'You are a highly capable and versatile {Role}'",
      "ensure that each Goal is a simple phrase that is a continuation of: 'Your goal is {Goal}'",
      "ensure the Expertise property is a text describing list of skills the agent and is a continuation of 'You are an expert in {Expertise}'",
      "ensure the Traits, Important, Negative, and Other properties are lists of strings",
      "ensure that each Trait also include a short explanation of their intent. For example:\n Highly Analytical: You meticulously break down complex programming problems and user requirements to provide comprehensive solutions and explanations.\n Excellent Communicator: You explain complex technical concepts and code structures in clear, accessible language tailored to the USER's level of understanding.",
      "ensure that the Important and Negative lists do not contradict each other",
      "ensure that each Important item is written in an imperative way as continuation of the text: '**IMPORTANT, ** {Important_Item}'. They should normally start with 'You MUST ' or 'ALWAYS '.",
      "ensure that each Negative item is written as their POSITIVE version as a continuation of the text: '**NEVER, IN ANY CIRCUMSTANCE, ** {Negative_Item}'",
      "provide a brief explanation for each generated property, justifying its relevance to the Persona"
    ],
    "ResponseSchema": "{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"type\":\"object\",\"properties\":{\"Role\":{\"type\":\"string\"},\"Goals\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Expertise\":{\"type\":\"string\"},\"Traits\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Important\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Negative\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}},\"Other\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"Role\",\"Goals\",\"Expertise\",\"Traits\",\"Important\",\"Negative\",\"Other\"]}",
    "ResponseType": "Json",
    "Validations": [
      "ensuring each generated property is directly relevant to and consistent with the provided information",
      "checking that the Expertise aligns closely with the Role and Goals",
      "verifying that Traits and Important lists contain distinct items that don't contradict each other",
      "confirming that Negative traits are genuinely detrimental to the Persona's purpose",
      "reviewing the Other list to ensure it adds value without redundancy",
      "validating that clear, concise explanations are provided for each generated property"
    ]
  }
]
 
---------------------------------------------------------------------------------------- 
saved\users.json 
[
  {
    "Internal": true,
    "Name": "User",
    "Key": 0
  },
  {
    "Internal": false,
    "Name": "Argus",
    "Key": 1
  }
] 
---------------------------------------------------------------------------------------- 
Tasks\Commands\TaskListCommand.cs 
using Lola.Utilities;

namespace Lola.Tasks.Commands;

public class TaskListCommand(IHasChildren parent, ITaskHandler taskHandler)
    : Command<TaskListCommand>(parent, "List", n => {
        n.Aliases = ["ls"];
        n.Description = "List the existing tasks.";
    }) {
    protected override Result Execute() => this.HandleCommand(() => {
        Logger.LogInformation("Executing Tasks->List command...");
        var tasks = taskHandler.List();
        if (tasks.Length == 0) {
            Output.WriteLine("[yellow]No tasks found.[/]");
            return Result.Success();
        }

        var sortedTasks = tasks.OrderBy(m => m.Name);
        ShowList(sortedTasks);

        return Result.Success();
    }, "Error listing the tasks.");

    private void ShowList(IOrderedEnumerable<TaskEntity> sortedTasks) {
        var table = new Table();
        table.Expand();
        table.AddColumn(new("[yellow]Name[/]"));
        table.AddColumn(new("[yellow]Main Goal[/]"));
        foreach (var task in sortedTasks)
            table.AddRow(task.Name, task.Goals.FirstOrDefault() ?? "[red][Undefined][/]");
        Output.Write(table);
    }
}
 
---------------------------------------------------------------------------------------- 
Tasks\Commands\TasksCommand.cs 
using Lola.Utilities;

namespace Lola.Tasks.Commands;

public class TasksCommand(IHasChildren parent)
    : Command<TasksCommand>(parent, "Tasks", n => {
        n.Description = "Manage AI Tasks.";
        n.AddCommand<TaskListCommand>();
        //n.AddCommand<TaskCreateCommand>();
        //n.AddCommand<TaskUpdateCommand>();
        //n.AddCommand<TaskRemoveCommand>();
        //AddCommand<TaskViewCommand>();
        n.AddCommand<HelpCommand>();
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        Logger.LogInformation("Executing Tasks command...");
        var choice = await Input.BuildSelectionPrompt<string>("What would you like to do?")
                                .ConvertWith(MapTo)
                                .AddChoices(Commands.ToArray(c => c.Name))
                                .ShowAsync(lt);

        var command = Commands.FirstOrDefault(i => i.Name == choice);
        return command is null
            ? Result.Success()
            : await command.Execute([], lt);

        string MapTo(string item) => Commands.FirstOrDefault(i => i.Name == item)?.Description ?? string.Empty;
    }, "Error displaying the tasks menu.", ct);
}
 
---------------------------------------------------------------------------------------- 
Tasks\Handlers\ITaskHandler.cs 
namespace Lola.Tasks.Handlers;

public interface ITaskHandler {
    TaskEntity[] List();
    TaskEntity? GetByKey(uint key);
    TaskEntity? GetByName(string name);
    TaskEntity Create(Action<TaskEntity> setUp);
    void Add(TaskEntity task);
    void Update(TaskEntity task);
    void Remove(uint key);
}
 
---------------------------------------------------------------------------------------- 
Tasks\Handlers\TaskHandler.cs 
namespace Lola.Tasks.Handlers;

public class TaskHandler(ITaskDataSource dataSource, ILogger<TaskHandler> logger) : ITaskHandler {
    private readonly ITaskDataSource _dataSource = dataSource;
    private readonly ILogger<TaskHandler> _logger = logger;

    public TaskEntity[] List() => _dataSource.GetAll();

    public TaskEntity? GetByKey(uint key) => _dataSource.FindByKey(key);
    public TaskEntity? GetByName(string name) => _dataSource.Find(p => p.Name.Equals(name, StringComparison.OrdinalIgnoreCase));

    public TaskEntity Create(Action<TaskEntity> setUp)
        => _dataSource.Create(setUp);

    public void Add(TaskEntity task) {
        if (_dataSource.FindByKey(task.Key) != null)
            throw new InvalidOperationException($"A task with the key '{task.Key}' already exists.");

        _dataSource.Add(task);
        _logger.LogInformation("Added new task: {TaskKey} => {TaskName}", task.Name, task.Key);
    }

    public void Update(TaskEntity task) {
        if (_dataSource.FindByKey(task.Key) == null)
            throw new InvalidOperationException($"Task with key '{task.Key}' not found.");

        _dataSource.Update(task);
        _logger.LogInformation("Updated task: {TaskKey} => {TaskName}", task.Name, task.Key);
    }

    public void Remove(uint key) {
        var task = _dataSource.FindByKey(key)
                     ?? throw new InvalidOperationException($"Task with key '{key}' not found.");

        _dataSource.Remove(key);
        _logger.LogInformation("Removed task: {TaskKey} => {TaskName}", task.Name, task.Key);
    }
}
 
---------------------------------------------------------------------------------------- 
Tasks\Repositories\ITaskDataSource.cs 
namespace Lola.Tasks.Repositories;

public interface ITaskDataSource
    : IDataSource<TaskEntity, uint>;
 
---------------------------------------------------------------------------------------- 
Tasks\Repositories\ITaskStorage.cs 
namespace Lola.Tasks.Repositories;

public interface ITaskStorage
    : IStorage<TaskEntity, uint>;
 
---------------------------------------------------------------------------------------- 
Tasks\Repositories\TaskDataSource.cs 
namespace Lola.Tasks.Repositories;

public class TaskDataSource(ITaskStorage storage)
    : DataSource<ITaskStorage, TaskEntity, uint>(storage),
      ITaskDataSource;
 
---------------------------------------------------------------------------------------- 
Tasks\Repositories\TaskEntity.cs 
using Task = DotNetToolbox.AI.Jobs.Task;

namespace Lola.Tasks.Repositories;

public class TaskEntity
    : Entity<TaskEntity, uint> {
    public string Name { get; init; } = string.Empty;
    public List<string> Goals { get; init; } = [];
    public List<string> Scope { get; init; } = [];
    public List<string> Requirements { get; init; } = [];
    public List<string> Assumptions { get; init; } = [];
    public List<string> Constraints { get; init; } = [];
    public List<string> Examples { get; init; } = [];
    public List<string> Guidelines { get; init; } = [];
    public List<string> Validations { get; init; } = [];

    public string InputTemplate { get; init; } = string.Empty;
    public TaskResponseType ResponseType { get; init; }
    public string ResponseSchema { get; init; } = string.Empty;

    public override Result Validate(IMap? context = null) {
        var result = base.Validate(context);
        if (string.IsNullOrWhiteSpace(Name)) result += new ValidationError("The name is required.", nameof(Name));
        if (Goals.Count == 0) result += new ValidationError("At least one goal is required.", nameof(Goals));
        return result;
    }

    public static implicit operator Task(TaskEntity entity)
        => new(entity.Key) {
            Name = entity.Name,
            Goals = entity.Goals,
            Scope = entity.Scope,
            Requirements = entity.Requirements,
            Assumptions = entity.Assumptions,
            Constraints = entity.Constraints,
            Examples = entity.Examples,
            Guidelines = entity.Guidelines,
            Validations = entity.Validations,
            InputTemplate = entity.InputTemplate,
            ResponseType = entity.ResponseType,
            ResponseSchema = entity.ResponseSchema,
        };
}
 
---------------------------------------------------------------------------------------- 
Tasks\Repositories\TaskStorage.cs 
namespace Lola.Tasks.Repositories;

public class TaskStorage(IConfiguration configuration)
    : JsonFilePerTypeStorage<TaskEntity, uint>("tasks", configuration),
      ITaskStorage {
    protected override uint FirstKey { get; } = 1;

    protected override bool TryGenerateNextKey(out uint next) {
        next = LastUsedKey == default ? FirstKey : ++LastUsedKey;
        return true;
    }
}
 
---------------------------------------------------------------------------------------- 
UserProfile\Commands\UserProfileCommand.cs 
using Lola.Utilities;

namespace Lola.UserProfile.Commands;

public class UserProfileCommand(IHasChildren parent)
    : Command<UserProfileCommand>(parent, "UserProfile", n => {
        n.Description = "Manage User Profile.";
        n.AddCommand<UserProfileSetCommand>();
        n.AddCommand<HelpCommand>();
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        Logger.LogInformation("Executing UserProfile command...");
        var choice = await Input.BuildSelectionPrompt<string>("What would you like to do?")
                                .ConvertWith(MapTo)
                                .AddChoices(Commands.ToArray(c => c.Name))
                                .ShowAsync(lt);

        var command = Commands.FirstOrDefault(i => i.Name == choice);
        return command is null
            ? Result.Success()
            : await command.Execute([], lt);

        string MapTo(string item) => Commands.FirstOrDefault(i => i.Name == item)?.Description ?? string.Empty;
    }, "Error displaying the user profile menu.", ct);
}
 
---------------------------------------------------------------------------------------- 
UserProfile\Commands\UserProfileSetCommand.cs 
using Lola.Utilities;

using Task = System.Threading.Tasks.Task;
using ValidationException = DotNetToolbox.Results.ValidationException;

namespace Lola.UserProfile.Commands;

public class UserProfileSetCommand(IHasChildren parent, IUserProfileHandler handler)
    : Command<UserProfileSetCommand>(parent, "Change", n => {
        n.Aliases = ["set"];
        n.Description = "Update your profile.";
        n.Description = "Change the current user profile.";
    }) {
    protected override Task<Result> ExecuteAsync(CancellationToken ct = default) => this.HandleCommandAsync(async lt => {
        try {
            Logger.LogInformation("Executing UserProfile->Set command...");
            var user = handler.CurrentUser ?? handler.Create();
            await SetUpAsync(user, lt);
            handler.Set(user);

            Output.WriteLine("[green]User profile set successfully.[/]");
            Logger.LogInformation("User profile set successfully.");
            return Result.Success();
        }
        catch (ValidationException ex) {
            var errors = string.Join("\n", ex.Errors.Select(e => $" - {e.Source}: {e.Message}"));
            Logger.LogWarning("Error setting the your user profile. Validation errors:\n{Errors}", errors);
            Output.WriteLine($"[red]We found some problems while setting your user profile. Please correct the following errors and try again:\n{errors}[/]");
            return Result.Invalid(ex.Errors);
        }
    }, "Error setting the user profile.", ct);

    private async Task SetUpAsync(UserProfileEntity user, CancellationToken ct)
        => user.Name = await Input.BuildTextPrompt<string>("How would you like me to call you?")
                                  .AddValidation(UserProfileEntity.ValidateName)
                                  .ShowAsync(ct);
}
 
---------------------------------------------------------------------------------------- 
UserProfile\Commands\UserProfileViewCommand.cs 
using Lola.Utilities;

namespace Lola.UserProfile.Commands;

public class UserProfileViewCommand(IHasChildren parent, IUserProfileHandler handler)
    : Command<UserProfileViewCommand>(parent, "Info", n => {
        n.Aliases = ["i"];
        n.Description = "Display the User Profile.";
    }) {
    protected override Result Execute() => this.HandleCommand(() => {
        Logger.LogInformation("Executing UserProfile->View command...");
        var user = handler.CurrentUser;
        if (user is null) {
            Logger.LogInformation("No user selected.");
            return Result.Success();
        }

        ShowDetails(user);
        return Result.Success();
    }, "Error displaying the user profile.");

    private void ShowDetails(UserProfileEntity user) {
        Output.WriteLine("[yellow]User Information:[/]");
        Output.WriteLine($"[blue]Name:[/] {user.Name}");
        Output.WriteLine($"[blue]Preferred Language:[/] {user.Language}");
    }
}
 
---------------------------------------------------------------------------------------- 
UserProfile\Handlers\IUserProfileHandler.cs 
namespace Lola.UserProfile.Handlers;

public interface IUserProfileHandler {
    UserProfileEntity Create(Action<UserProfileEntity>? setUp = null);
    UserProfileEntity? CurrentUser { get; }
    void Set(UserProfileEntity user);
}
 
---------------------------------------------------------------------------------------- 
UserProfile\Handlers\UserProfileHandler.cs 
namespace Lola.UserProfile.Handlers;

public class UserProfileHandler(IUserProfileDataSource dataSource, ILogger<UserProfileHandler> logger)
    : IUserProfileHandler {
    private readonly IUserProfileDataSource _dataSource = dataSource;
    private readonly ILogger<UserProfileHandler> _logger = logger;
    private UserProfileEntity? _currentUser;

    public UserProfileEntity Create(Action<UserProfileEntity>? setUp = null)
        => _dataSource.Create(setUp);
    public UserProfileEntity? CurrentUser
        => _currentUser ??= _dataSource.FirstOrDefault(i => !i.Internal);
    public void Set(UserProfileEntity user) {
        if (_dataSource.Any()) _dataSource.Update(user);
        else _dataSource.Add(user);
        _logger.LogInformation("User profile set.");
    }
}
 
---------------------------------------------------------------------------------------- 
UserProfile\Repositories\IUserProfileDataSource.cs 
namespace Lola.UserProfile.Repositories;

public interface IUserProfileDataSource
    : IDataSource<UserProfileEntity, uint>;
 
---------------------------------------------------------------------------------------- 
UserProfile\Repositories\IUserProfileStorage.cs 
namespace Lola.UserProfile.Repositories;

public interface IUserProfileStorage
    : IStorage<UserProfileEntity, uint>;
 
---------------------------------------------------------------------------------------- 
UserProfile\Repositories\UserProfileDataSource.cs 
namespace Lola.UserProfile.Repositories;

public class UserProfileDataSource(IUserProfileStorage storage)
    : DataSource<IUserProfileStorage, UserProfileEntity, uint>(storage),
      IUserProfileDataSource;
 
---------------------------------------------------------------------------------------- 
UserProfile\Repositories\UserProfileEntity.cs 
using AIUserProfile = DotNetToolbox.AI.Jobs.UserProfile;

namespace Lola.UserProfile.Repositories;

public class UserProfileEntity
    : Entity<UserProfileEntity, uint> {
    public bool Internal { get; init; }
    public string Name { get; set; } = string.Empty;
    public string Language { get; set; } = "English";
    public List<string> Facts { get; } = [];

    public override Result Validate(IMap? context = null) {
        var result = base.Validate(context);
        result += ValidateName(Name);
        return result;
    }

    public static implicit operator AIUserProfile(UserProfileEntity entity)
        => new(entity.Key) {
            Name = entity.Name,
            Language = entity.Language,
            Facts = entity.Facts,
        };

    public static Result ValidateName(string? name) {
        var result = Result.Success();
        if (string.IsNullOrWhiteSpace(name))
            result += new ValidationError("Soory yout name cannot be empty or only white spaces.", nameof(Name));
        return result;
    }
}
 
---------------------------------------------------------------------------------------- 
UserProfile\Repositories\UserProfileStorage.cs 
namespace Lola.UserProfile.Repositories;

public class UserProfileStorage(IConfiguration configuration)
    : JsonFilePerTypeStorage<UserProfileEntity, uint>("users", configuration),
      IUserProfileStorage {
    protected override uint FirstKey { get; } = 1;

    protected override bool TryGenerateNextKey(out uint next) {
        next = LastUsedKey == default ? FirstKey : LastUsedKey + 1;
        LastUsedKey = next;
        return true;
    }
}
 
---------------------------------------------------------------------------------------- 
Utilities\CommandHelpers.cs 
namespace Lola.Utilities;

internal sealed class ListItem<TItem, TKey>(TKey key, string text, TItem? item)
    where TItem : class, IEntity<TKey>
    where TKey : notnull {
    public TKey Key { get; } = key;
    public string Text { get; } = text;
    public TItem? Item { get; } = item;
}

public static class CommandHelpers {
    public static async Task<TItem?> SelectEntityAsync<TItem, TKey>(this ICommand command,
                                                                    IEnumerable<TItem> entities,
                                                                    Func<TItem, string> mapText,
                                                                    CancellationToken ct = default)
        where TItem : class, IEntity<TKey>
        where TKey : notnull {
        var items = IsNotNull(entities).ToArray();
        if (items.Length == 0) {
            command.Output.WriteLine("[yellow]No items found.[/]");
            return null;
        }

        var choices = items.ToList(e => new ListItem<TItem, TKey>(e.Key, IsNotNull(mapText)(e), e));
        var cancelOption = new ListItem<TItem, TKey>(default!, "Cancel", null);
        choices.Add(cancelOption);

        const string prompt = "Select an item or cancel to return:";
        return (await command.Input.BuildSelectionPrompt<ListItem<TItem, TKey>>(prompt)
                                   .AddChoices([.. choices])
                                   .ConvertWith(e => e.Item is null ? $"[yellow bold]{e.Text}[/]" : e.Text)
                                   .ShowAsync(ct)).Item;
    }

    public static Result HandleCommand(this ICommand command, Func<Result> execute, string errorMessage) {
        try {
            var result = execute();
            command.Output.WriteLine();
            return result;
        }
        catch (Exception ex) {
            return command.HandleException(ex, errorMessage);
        }
    }

    public static async Task<Result> HandleCommandAsync(this ICommand command, Func<CancellationToken, Task<Result>> execute, string errorMessage, CancellationToken ct = default) {
        try {
            var result = await execute(ct);
            command.Output.WriteLine();
            return result;
        }
        catch (Exception ex) {
            return command.HandleException(ex, errorMessage);
        }
    }

    private static Result HandleException(this INode command, Exception ex, [StringSyntax("CompositeFormat")] string message, params object[] args) {
#pragma warning disable CA2254
        command.Logger.LogError(ex, message, args);
#pragma warning restore CA2254
        command.Output.WriteError(ex, string.Format(message, args));
        command.Output.WriteLine();
        return Result.Error(ex);
    }
}
 
---------------------------------------------------------------------------------------- 
Utilities\EncryptionHelper.cs 
namespace Lola.Utilities;

public interface IEncryptionHelper {
    string? Encrypt(string? plainText);
    string? Decrypt(string? cipherText);
}

public sealed class EncryptionHelper : IEncryptionHelper {
    private static IEncryptionHelper? _instance;
    private readonly byte[] _secretKey;
    private readonly byte[] _initVector;

    private EncryptionHelper(IConfiguration configuration) {
        _secretKey = Convert.FromBase64String(IsNotNull(configuration["Encryption:SecretKey"]));
        _initVector = Convert.FromBase64String(IsNotNull(configuration["Encryption:InitVector"]));
    }

    public static void Initialize(IConfiguration configuration) {
        if (_instance != null) return;
        _instance = new EncryptionHelper(configuration);
    }

    public static IEncryptionHelper Instance
        => _instance
        ?? throw new InvalidOperationException("EncryptionHelper has not been initialized.");

    public string? Encrypt(string? plainText) {
        if (plainText is null) return null;
        if (plainText.Length == 0) return string.Empty;
        using var aesAlg = Aes.Create();
        aesAlg.Key = _secretKey;
        aesAlg.IV = _initVector;

        var encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);

        using var msEncrypt = new MemoryStream();
        using var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
        using var swEncrypt = new StreamWriter(csEncrypt);
        swEncrypt.Write(plainText);

        return Convert.ToBase64String(msEncrypt.ToArray());
    }

    public string? Decrypt(string? cipherText) {
        try {
            if (cipherText is null) return null;
            if (cipherText.Length == 0) return string.Empty;
            var cipherBytes = Convert.FromBase64String(cipherText);

            using var aesAlg = Aes.Create();
            aesAlg.Key = _secretKey;
            aesAlg.IV = _initVector;

            var decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

            using var msDecrypt = new MemoryStream(cipherBytes);
            using var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read);
            using var srDecrypt = new StreamReader(csDecrypt);

            return srDecrypt.ReadToEnd();
        }
        catch (FormatException) {
            return null;
        }
    }
}
 
---------------------------------------------------------------------------------------- 
Utilities\JsonSchemaGenerator.cs 
namespace Lola.Utilities;

public static class JsonSchemaGenerator {
    public static string GenerateSchemaFor<T>()
        where T : class
        => GenerateSchema(typeof(T));

    private static readonly JsonSerializerOptions _jsonOptions = new() { WriteIndented = true };

    public static string GenerateSchema(Type type) {
        var schema = new Dictionary<string, object> {
            ["$schema"] = "https://json-schema.org/draft/2020-12/schema",
            ["type"] = GetJsonType(type)
        };

        if (GetJsonType(type) == "object") {
            schema["properties"] = GenerateProperties(type);
            var requiredProperties = GetRequiredProperties(type);
            if (requiredProperties.Count != 0) {
                schema["required"] = requiredProperties;
            }
        }
        else if (GetJsonType(type) == "array") {
            schema["items"] = GenerateArrayItems(type);
        }

        return JsonSerializer.Serialize(schema, _jsonOptions);
    }

    private static Dictionary<string, object> GenerateArrayItems(Type type) {
        var elementType = type.GetElementType() ?? type.GetGenericArguments().FirstOrDefault();
        return elementType == null
            ? new() { ["type"] = "object" }
            : GenerateSchemaForType(elementType);
    }

    private static string GetJsonType(Type type) => type switch {
        not null when type == typeof(string) => "string",
        not null when type == typeof(DateTime)
                   || type == typeof(DateTimeOffset)
                   || type == typeof(TimeSpan)
                   || type == typeof(Guid)
                   || type == typeof(Uri)
                   || type == typeof(Version) => "string",
        not null when type.IsEnum => "string",
        not null when type == typeof(int)
                   || type == typeof(long)
                   || type == typeof(float)
                   || type == typeof(double)
                   || type == typeof(decimal)
                   || type == typeof(short)
                   || type == typeof(ushort)
                   || type == typeof(uint)
                   || type == typeof(ulong)
                   || type == typeof(byte)
                   || type == typeof(sbyte) => "number",
        not null when type == typeof(bool) => "boolean",
        not null when type.IsArray
                   || (type.IsGenericType && (type.GetGenericTypeDefinition() == typeof(List<>)
                                           || type.GetGenericTypeDefinition() == typeof(IEnumerable<>))) => "array",
        not null when type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>) => GetJsonType(Nullable.GetUnderlyingType(type)!),
        not null when type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Dictionary<,>) => "object",
        _ => "object",
    };
    private static Dictionary<string, object> GenerateProperties(Type type) {
        var properties = new Dictionary<string, object>();

        foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance)) {
            properties[prop.Name] = GenerateSchemaForType(prop.PropertyType);
            AddAttributeInfo((Dictionary<string, object>)properties[prop.Name], prop);
        }

        return properties;
    }

    private static Dictionary<string, object> GenerateSchemaForType(Type type) {
        var schema = new Dictionary<string, object> {
            ["type"] = GetJsonType(type)
        };

        if (type.IsEnum) {
            schema["enum"] = Enum.GetNames(type);
        }
        else if (GetJsonType(type) == "object") {
            schema["properties"] = GenerateProperties(type);
            var requiredProperties = GetRequiredProperties(type);
            if (requiredProperties.Count != 0) {
                schema["required"] = requiredProperties;
            }
        }
        else if (GetJsonType(type) == "array") {
            schema["items"] = GenerateArrayItems(type);
        }

        return schema;
    }

    private static void AddAttributeInfo(Dictionary<string, object> schema, PropertyInfo prop) {
        var descriptionAttribute = prop.GetCustomAttribute<DescriptionAttribute>();
        if (descriptionAttribute != null) {
            schema["description"] = descriptionAttribute.Description;
        }

        if (prop.PropertyType == typeof(DateTime) || prop.PropertyType == typeof(DateTimeOffset)) {
            schema["format"] = "date-time";
        }
        else if (prop.PropertyType == typeof(Guid)) {
            schema["format"] = "uuid";
        }

        var rangeAttribute = prop.GetCustomAttribute<RangeAttribute>();
        if (rangeAttribute != null) {
            schema["minimum"] = rangeAttribute.Minimum;
            schema["maximum"] = rangeAttribute.Maximum;
        }

        var stringLengthAttribute = prop.GetCustomAttribute<StringLengthAttribute>();
        if (stringLengthAttribute != null) {
            if (stringLengthAttribute.MinimumLength > 0)
                schema["minLength"] = stringLengthAttribute.MinimumLength;
            schema["maxLength"] = stringLengthAttribute.MaximumLength;
        }

        var regexAttribute = prop.GetCustomAttribute<RegularExpressionAttribute>();
        if (regexAttribute != null) {
            schema["pattern"] = regexAttribute.Pattern;
        }
    }

    private static List<string> GetRequiredProperties(Type type)
        => type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
               .Where(p => (Nullable.GetUnderlyingType(p.PropertyType) == null
                        && p.PropertyType.IsValueType
                     && !IsNullableReferenceType(p))
                     || p.GetCustomAttribute<RequiredAttribute>() != null)
            .Select(p => p.Name)
            .ToList();

    private static bool IsNullableReferenceType(PropertyInfo prop)
        => !prop.PropertyType.IsValueType &&
            prop.GetCustomAttribute<NullableAttribute>()?.NullableFlags[0] == 2;
}
 
---------------------------------------------------------------------------------------- 
Utilities\HttpConnection\Handlers\HttpConnectionHandler.cs 
namespace Lola.Utilities.HttpConnection.Handlers;

public class HttpConnectionHandler(IModelHandler modelHandler, IAgentAccessor httpConnectionAccessor)
    : IHttpConnectionHandler {
    public IAgent GetInternal() {
        var model = modelHandler.Selected ?? throw new InvalidOperationException("No internal model found.");
        return httpConnectionAccessor.GetFor(model.Provider!.Name);
    }

    public IAgent Get(string modelKey) {
        var model = modelHandler.GetByKey(modelKey) ?? throw new InvalidOperationException("Model not found.");
        return httpConnectionAccessor.GetFor(model.Provider!.Name);
    }
}
 
---------------------------------------------------------------------------------------- 
Utilities\HttpConnection\Handlers\IHttpConnectionHandler.cs 
namespace Lola.Utilities.HttpConnection.Handlers;

public interface IHttpConnectionHandler {
    IAgent GetInternal();
    IAgent Get(string modelKey);
}
 
