-------------------------------------------------------------------
[AnthropicCompletionRequest.cs]
namespace DotNetToolbox.AI.Anthropic.DataModels;
public class AnthropicCompletionRequest {
    [JsonPropertyName("model")]
    public string Model { get; set; } = "claude-v1";

    [JsonPropertyName("prompt")]
    public string Prompt { get; set; } = string.Empty;

    [JsonPropertyName("max_tokens_to_sample")]
    public int? MaxTokensToSample { get; set; }

    [JsonPropertyName("stop_sequences")]
    public List<string>? StopSequences { get; set; }

    // Add other properties as needed
}

public class AnthropicCompletionResponse {
    [JsonPropertyName("completion")]
    public string Completion { get; set; } = string.Empty;

    [JsonPropertyName("stop_reason")]
    public string StopReason { get; set; } = string.Empty;

    // Add other properties as needed
}
-------------------------------------------------------------------
[Chat.cs]
namespace DotNetToolbox.AI.Chats;

public abstract class Chat<TOptions>
    : IChat<TOptions>
    where TOptions : ChatOptions, new() {
    protected Chat(string userName, TOptions? options = null) {
        UserName = userName;
        Options = options ?? Options;
    }

    public string Id { get; } = Guid.NewGuid().ToString();
    public string UserName { get; }
    public TOptions Options { get; } = new();
    public int TotalNumberOfTokens { get; set; }
}
-------------------------------------------------------------------
[ChatHandler.cs]
namespace DotNetToolbox.AI.Chats;

internal abstract class ChatHandler<THandler, TChat, TOptions>(IChatRepository<TChat> repository, IHttpClientProvider httpClientProvider, ILogger<THandler> logger)
    : IChatHandler<TChat, TOptions>
    where TChat : IChat<TOptions>
    where TOptions : ChatOptions, new() {

    protected IChatRepository<TChat> Repository { get; } = repository;
    protected HttpClient HttpClient { get; } = httpClientProvider.GetHttpClient();
    protected ILogger<THandler> Logger { get; } = logger;

    public abstract Task<TChat[]> List(CancellationToken ct = default);
    public Task<TChat> Start(string userName, CancellationToken ct = default) => Start(userName, _ => { }, ct);
    public abstract Task<TChat> Start(string userName, Action<TOptions> configure, CancellationToken ct = default);
    public abstract Task<TResponse> SendMessage<TRequest, TResponse>(TChat chat, TRequest request, CancellationToken ct = default)
        where TRequest : class
        where TResponse : class;
    public abstract Task Terminate(TChat chat, CancellationToken ct = default);
}
-------------------------------------------------------------------
[ChatOptions.cs]
namespace DotNetToolbox.AI.Chats;

public record ChatOptions : IValidatable {
    public virtual Result Validate(IDictionary<string, object?>? context = null) => Result.Success();
}
-------------------------------------------------------------------
[IChat.cs]
namespace DotNetToolbox.AI.Chats;

public interface IChat {
    string Id { get; }
    string UserName { get; }
    public int TotalNumberOfTokens { get; set; }
}

public interface IChat<out TOptions> : IChat
    where TOptions : ChatOptions, new() {
    TOptions Options { get; }
}
-------------------------------------------------------------------
[IChatFactory.cs]
namespace DotNetToolbox.AI.Chats;

public interface IChatFactory {
    Task<TChat> Create<TChat, TBuilder, TOptions, TMessage>(string userName, Action<TBuilder> configure, CancellationToken ct = default)
        where TChat : IChat<TOptions>
        where TOptions : ChatOptions, new()
        where TMessage : Message;
}
-------------------------------------------------------------------
[IChatHandler.cs]
namespace DotNetToolbox.AI.Chats;

public interface IChatHandler<TChat, out TOptions>
    where TChat : IChat<TOptions>
    where TOptions : ChatOptions, new() {
    Task<TChat[]> List(CancellationToken ct = default);
    Task<TChat> Start(string userName, CancellationToken ct = default);
    Task<TChat> Start(string userName, Action<TOptions> configure, CancellationToken ct = default);
    Task<TResponse> SendMessage<TRequest, TResponse>(TChat chat, TRequest request, CancellationToken ct = default)
        where TRequest : class
        where TResponse : class;
    Task Terminate(TChat chat, CancellationToken ct = default);
}
-------------------------------------------------------------------
[IChatRepository.cs]
namespace DotNetToolbox.AI.Chats;

internal interface IChatRepository<TChat>
    : IDisposable
    where TChat : IChat {
    Task<TChat[]> Get(CancellationToken ct = default);
    Task<TChat?> GetById(string id, CancellationToken ct = default);
    Task Add(TChat chat, CancellationToken ct = default);
    Task Update(string id, TChat chat, CancellationToken ct = default);
    Task Delete(string id, CancellationToken ct = default);
}
-------------------------------------------------------------------
[Message.cs]
namespace DotNetToolbox.AI.Chats;

public class Message;
-------------------------------------------------------------------
[MessageType.cs]
namespace DotNetToolbox.AI.Chats;

public enum MessageType {
    System = 0,
    User = 1,
    Assistant = 2,
    Tool = 3,
    Error = 99,
}
-------------------------------------------------------------------
[ToolResult.cs]
namespace DotNetToolbox.AI.Chats;

public record ToolResult(string Id, string Value);
-------------------------------------------------------------------
[ServiceCollectionExtensions.cs]
namespace DotNetToolbox.AI.Extensions;

public static class ServiceCollectionExtensions {
    public static IServiceCollection AddOpenAI(this IServiceCollection services, IConfiguration configuration) {
        services.AddHttpClientProvider<IHttpClientProvider, OpenAIHttpClientProvider>(configuration);
        services.TryAddSingleton<IChatRepository<OpenAIChat>, InMemoryChatRepository<OpenAIChat>>();
        services.TryAddSingleton<IModelsHandler, ModelsHandler>();
        services.TryAddSingleton<IChatHandler<OpenAIChat, OpenAIChatOptions>, OpenAIChatHandler>();
        return services;
    }

    public static IServiceCollection AddClaude(this IServiceCollection services, IConfiguration configuration) {
        // TODO
        return services;
    }
}
-------------------------------------------------------------------
[OpenAIHttpClientOptions.cs]
namespace DotNetToolbox.AI.HttpProvider;

public class OpenAIHttpClientOptions : HttpClientOptions {
    public override Uri? BaseAddress { get; set; } = new("https://api.openai.com/v1/");
}
-------------------------------------------------------------------
[OpenAIHttpClientProvider.cs]
namespace DotNetToolbox.AI.HttpProvider;

public class OpenAIHttpClientProvider(IHttpClientFactory clientFactory, IConfiguration configuration, IOptions<OpenAIHttpClientOptions> options)
    : HttpClientProvider(clientFactory, options) {
    protected override HttpClient CreateHttpClient() {
        var builder = new HttpClientOptionsBuilder(Options);
        var key = IsNotNull(configuration["OpenAI:ApiKey"]);
        var organization = IsNotNull(configuration["OpenAI:Organization"]);
        builder.UseSimpleTokenAuthentication(opt => {
            opt.Scheme = AuthenticationScheme.Bearer;
            opt.Token = key;
        });
        builder.AddCustomHeader("OpenAI-Organization", organization);
        Options = builder.Build();
        return base.CreateHttpClient();
    }
}
-------------------------------------------------------------------
[IModelsHandler.cs]
namespace DotNetToolbox.AI.Models;

/// <summary>
/// This class contains methods for handling models using OpenAI.
/// </summary>
/// <remarks>
/// This class is responsible for handling models using OpenAI. It contains methods for getting a list of models, getting a model by ID, and deleting a model. It also includes a detailed XML documentation for each method.
/// </remarks>
public interface IModelsHandler {
    /// <summary>
    /// Gets a list of models of the specified type.
    /// </summary>
    /// <param name="type">The type of the models to get.</param>
    /// <returns>An array of models of the specified type.</returns>
    /// <remarks>
    /// This method gets a list of models of the specified type from the OpenAI API.
    /// </remarks>
    Task<Model[]> Get(ModelType type = ModelType.Chat);

    /// <summary>
    /// Gets the model with the specified ID.
    /// </summary>
    /// <param name="id">The ID of the model to get.</param>
    /// <returns>The model with the specified ID.</returns>
    /// <remarks>
    /// This method gets the model with the specified ID from the OpenAI API.
    /// </remarks>
    Task<Model?> GetById(string id);

    /// <summary>
    /// Deletes the model with the specified ID.
    /// </summary>
    /// <param name="id">The ID of the model to delete.</param>
    /// <returns>A boolean indicating whether the model was deleted successfully.</returns>
    /// <remarks>
    /// This method deletes the model with the specified ID from the OpenAI API.
    /// </remarks>
    Task<bool> Delete(string id);
}
-------------------------------------------------------------------
[Model.cs]
namespace DotNetToolbox.AI.Models;

public record Model {
    public required string Id { get; init; }
    public required string Name { get; init; }
    public bool IsFineTuned { get; init; }
    public ModelType Type { get; init; }
    public DateTimeOffset CreatedOn { get; init; }
    public string? OwnedBy { get; init; }
}
-------------------------------------------------------------------
[ModelsHandler.cs]
namespace DotNetToolbox.AI.Models;

internal class ModelsHandler(IHttpClientProvider httpClientProvider, ILogger<ModelsHandler> logger)
        : IModelsHandler {
    private readonly HttpClient _httpClient = httpClientProvider.GetHttpClient();

    public async Task<Model[]> Get(ModelType type = ModelType.Chat) {
        try {
            logger.LogDebug("Getting list of models...");
            var models = await GetModelsAsync().ConfigureAwait(false);
            var result = models
                .Where(m => m.Type == type)
                .Select(ToModel).OfType<Model>().ToArray();
            logger.LogDebug("A list of {numberOfModels} models was found.", result.Length);
            return result;
        }
        catch (Exception ex) {
            logger.LogError(ex, "Failed to get list of models.");
            throw;
        }
    }

    public async Task<Model?> GetById(string id) {
        try {
            logger.LogDebug("Getting model '{id}' details...", id);
            var model = await GetModelByIdAsync(id).ConfigureAwait(false);
            var result = ToModel(model);
            // ReSharper disable once ConvertIfStatementToConditionalTernaryExpression
            if (result is null) logger.LogDebug("The model '{id}' was not found.", id);
            else logger.LogDebug("The model '{id}' was found.", id);
            return result;
        }
        catch (Exception ex) {
            logger.LogError(ex, "Failed to get the model '{id}' details.", id);
            throw;
        }
    }

    public async Task<bool> Delete(string id) {
        try {
            logger.LogDebug("Deleting the model '{id}'...", id);
            var result = await DeleteModelAsync(id).ConfigureAwait(false);
            logger.LogDebug("The model '{id}' was deleted.", id);
            return result;
        }
        catch (Exception ex) {
            logger.LogError(ex, "Failed to delete the model '{id}'.", id);
            throw;
        }
    }

    private async Task<OpenAiModel[]> GetModelsAsync() {
        var response = await _httpClient.GetAsync("models").ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
        var result = await response.Content.ReadFromJsonAsync<ModelsResponse>().ConfigureAwait(false);
        return result!.Data;
    }

    private async Task<OpenAiModel?> GetModelByIdAsync(string id) {
        var response = await _httpClient.GetAsync($"models/{id}").ConfigureAwait(false);
        if (response.StatusCode == HttpStatusCode.NotFound)
            return null;
        response.EnsureSuccessStatusCode();
        var result = await response.Content.ReadFromJsonAsync<OpenAiModel>().ConfigureAwait(false);
        return result;
    }

    private async Task<bool> DeleteModelAsync(string id) {
        var response = await _httpClient.DeleteAsync($"models/{id}").ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
        var result = await response.Content.ReadFromJsonAsync<DeleteResponse>().ConfigureAwait(false);
        return result!.Deleted;
    }

    [return: NotNullIfNotNull(nameof(input))]
    private static Model? ToModel(OpenAiModel? input)
        => input is null
               ? null
               : new() {
                   Id = input.Id,
                   Name = input.IsFineTuned ? input.Id[3..] : input.Id,
                   IsFineTuned = input.IsFineTuned,
                   Type = input.Type,
                   CreatedOn = DateTimeOffset.FromUnixTimeSeconds(input.Created),
                   OwnedBy = input.OwnedBy,
               };
}
-------------------------------------------------------------------
[ModelType.cs]
namespace DotNetToolbox.AI.Models;

public enum ModelType {
    Chat,
    DallE,
    Whisper,
    TextToSpeech,
    Moderation,
    Embedding,
}
-------------------------------------------------------------------
[.NETCoreApp,Version=v8.0.AssemblyAttributes.cs]
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
-------------------------------------------------------------------
[DotNetToolbox.AI.AssemblyInfo.cs]
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("D0tN3tC0d3r5")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("© Andre Vianna 2023")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("DotNetToolbox.Core: A comprehensive utility library for interacting with AI chat " +
    "models.")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("8.0.5")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("8.0.5-rc1+683561f106676e86908e01aff041d899edb4104f")]
[assembly: System.Reflection.AssemblyProductAttribute("DotNetToolbox.AI")]
[assembly: System.Reflection.AssemblyTitleAttribute("DotNetToolbox.AI")]
[assembly: System.Reflection.AssemblyVersionAttribute("8.0.5.*")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"DotNetToolbox.AI.UnitTests, PublicKey=00240000048000009400000006020000002400005253413100040000010001003d1638cec9e06e22b1e23f1d95d51a425705c4148223b9907aea57442c94edbac4002079cb033dac4db6fe167d36f0a2674bbd95b729eb3130456a967859a5f7b12aa661f1e91f7106524560014fbe3744d5aaba8102cf396bb3ff4481bf7f4b13dfc4259342e76d306dae2ebcd8df7bc170309cd9d69277090e05f513681daf")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"DynamicProxyGenAssembly2, PublicKey=0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7")]

// Generated by the MSBuild WriteCodeFragment class.

-------------------------------------------------------------------
[DotNetToolbox.AI.GlobalUsings.g.cs]
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
-------------------------------------------------------------------
[DotNetToolbox.OpenAI.AssemblyInfo.cs]
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("D0tN3tC0d3r5")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("© Andre Vianna 2023")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("DotNetToolbox.Core: A comprehensive utility library for interacting with OpenAI c" +
    "hat models.")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("8.0.5")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("8.0.5-rc1+683561f106676e86908e01aff041d899edb4104f")]
[assembly: System.Reflection.AssemblyProductAttribute("DotNetToolbox.OpenAI")]
[assembly: System.Reflection.AssemblyTitleAttribute("DotNetToolbox.OpenAI")]
[assembly: System.Reflection.AssemblyVersionAttribute("8.0.5.*")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"DotNetToolbox.OpenAI.UnitTests, PublicKey=00240000048000009400000006020000002400005253413100040000010001003d1638cec9e06e22b1e23f1d95d51a425705c4148223b9907aea57442c94edbac4002079cb033dac4db6fe167d36f0a2674bbd95b729eb3130456a967859a5f7b12aa661f1e91f7106524560014fbe3744d5aaba8102cf396bb3ff4481bf7f4b13dfc4259342e76d306dae2ebcd8df7bc170309cd9d69277090e05f513681daf")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"DynamicProxyGenAssembly2, PublicKey=0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7")]

// Generated by the MSBuild WriteCodeFragment class.

-------------------------------------------------------------------
[DotNetToolbox.OpenAI.GlobalUsings.g.cs]
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
-------------------------------------------------------------------
[Choice.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

internal record Choice {
    public int Index { get; init; }
    public string? FinishReason { get; init; }
}
-------------------------------------------------------------------
[Completion.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

public class Completion {
    public virtual Role Role { get; set; }
    public virtual string? Content { get; set; }
    public virtual string? Name { get; set; }
    public virtual ToolCall[]? ToolCalls { get; set; }
    public virtual string? ToolCallId { get; set; }
    public virtual string? FinishReason { get; set; }
}
-------------------------------------------------------------------
[CompletionRequest.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

internal record CompletionRequest() {
    public required string Model { get; init; }
    public Completion[] Messages { get; set; } = [];
    public decimal? FrequencyPenalty { get; set; }
    public decimal? PresencePenalty { get; set; }
    public decimal? Temperature { get; set; }
    [JsonPropertyName("max_tokens")]
    public int? MaximumTokensPerMessage { get; set; }
    [JsonPropertyName("n")]
    public int? NumberOfChoices { get; set; }
    [JsonPropertyName("stop")]
    public string[]? StopSignals { get; set; }
    [JsonPropertyName("top_p")]
    public decimal? TopProbability { get; set; }
    [JsonPropertyName("stream")]
    public bool? UseStreaming { get; set; }
    public Tool[]? Tools { get; set; }
    public JsonElement? ToolChoice { get; set; }
    public JsonElement? ResponseFormat { get; set; }
}
-------------------------------------------------------------------
[CompletionResponse.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

[JsonPolymorphic(TypeDiscriminatorPropertyName = "object")]
[JsonDerivedType(typeof(MessageResponse), typeDiscriminator: "chat.completion")]
[JsonDerivedType(typeof(DeltaResponse), typeDiscriminator: "chat.completion.chunk")]
internal record CompletionResponse {
    public required string Id { get; init; }
    public string? Model { get; init; }
    public int Created { get; init; }
    public string? SystemFingerprint { get; init; }
    public Usage? Usage { get; init; }
}
-------------------------------------------------------------------
[DeleteResponse.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

internal record DeleteResponse {
    public required string Id { get; init; }
    public bool Deleted { get; init; }
}
-------------------------------------------------------------------
[DeltaChoice.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

internal record DeltaChoice : Choice {
    public required Message Delta { get; init; }
}
-------------------------------------------------------------------
[DeltaResponse.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

internal record DeltaResponse : CompletionResponse {
    public DeltaChoice[] Choices { get; init; } = [];
}
-------------------------------------------------------------------
[MessageChoice.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

internal record MessageChoice : Choice {
    public required Completion Message { get; init; }
}
-------------------------------------------------------------------
[MessageResponse.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

internal record MessageResponse : CompletionResponse {
    public MessageChoice[] Choices { get; init; } = [];
}
-------------------------------------------------------------------
[Model.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

internal record Model {
    public required string Id { get; init; }
    public long Created { get; init; }
    public string? OwnedBy { get; init; }
    public bool IsFineTuned => Id.StartsWith("ft:");
    public ModelType Type {
        get {
            var name = IsFineTuned ? Id[3..] : Id;
            return name switch {
                _ when name.StartsWith("dall-e") => ModelType.DallE,
                _ when name.StartsWith("whisper") => ModelType.Whisper,
                _ when name.StartsWith("tts") => ModelType.TextToSpeech,
                _ when name.StartsWith("text-embedding") => ModelType.Embedding,
                _ when name.StartsWith("text-moderation") => ModelType.Moderation,
                _ => ModelType.Chat,
            };
        }
    }
}
-------------------------------------------------------------------
[ModelsResponse.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

internal record ModelsResponse {
    public required OpenAiModel[] Data { get; init; }
}
-------------------------------------------------------------------
[ResponseFormat.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

internal enum ResponseFormat {
    Text,
    Json,
}
-------------------------------------------------------------------
[Role.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

public enum Role {
    System = 0,
    User = 1,
    Assistant = 2,
    Tool = 3,
}
-------------------------------------------------------------------
[Usage.cs]
namespace DotNetToolbox.AI.OpenAI.DataModels;

internal record Usage {
    public int PromptTokens { get; init; }
    public int CompletionTokens { get; init; }
    public int TotalTokens { get; init; }
}
-------------------------------------------------------------------
[IOpenAIChatHandler.cs]
namespace DotNetToolbox.AI.OpenAI;

public interface IOpenAIChatHandler : IChatHandler<OpenAIChat, OpenAIChatOptions> {
    Task<OpenAIMessage> SendMessage(OpenAIChat chat, string message, CancellationToken ct = default);
    Task<OpenAIMessage> SendToolResult(OpenAIChat chat, ToolResult[] results, CancellationToken ct = default);
}
-------------------------------------------------------------------
[OpenAIChat.cs]
namespace DotNetToolbox.AI.OpenAI;

public class OpenAIChat(string userName, OpenAIChatOptions? options = null)
    : Chat<OpenAIChatOptions>(userName, options) {
    public List<OpenAIMessage> Messages { get; } = [];
}
-------------------------------------------------------------------
[OpenAIChatHandler.cs]
namespace DotNetToolbox.AI.OpenAI;

internal class OpenAIChatHandler(IChatRepository<OpenAIChat> repository, IHttpClientProvider httpClientProvider, ILogger<OpenAIChatHandler> logger)
    : ChatHandler<OpenAIChatHandler, OpenAIChat, OpenAIChatOptions>(repository, httpClientProvider, logger),
      IOpenAIChatHandler {
    private static readonly JsonSerializerOptions _jsonSerializerOptions = new() {
        WriteIndented = true,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,
        Converters = { new JsonStringEnumConverter(JsonNamingPolicy.SnakeCaseLower) },
    };

    public override Task<OpenAIChat[]> List(CancellationToken ct = default) => throw new NotImplementedException();
    public override Task Terminate(OpenAIChat chat, CancellationToken ct = default) => throw new NotImplementedException();

    public override async Task<OpenAIChat> Start(string userName, Action<OpenAIChatOptions> configure, CancellationToken ct = default) {
        try {
            Logger.LogDebug("Creating new chat...");
            var options = new OpenAIChatOptions();
            IsNotNull(configure)(options);
            var chat = new OpenAIChat(userName, options);
            chat.Messages.Add(new(MessageType.System) { Content = OpenAIChatOptions.DefaultSystemMessage });
            await Repository.Add(chat, ct).ConfigureAwait(false);
            Logger.LogDebug("Chat '{id}' created.", chat.Id);
            return chat;
        }
        catch (Exception ex) {
            Logger.LogError(ex, "Failed to create a new chat.");
            throw;
        }
    }

    public async Task<OpenAIMessage> SendMessage(OpenAIChat chat, string message, CancellationToken ct = default) {
        try {
            var userMessage = new OpenAIMessage(MessageType.User) {
                Name = chat.UserName,
                Content = message,
            };
            chat.Messages.Add(userMessage);
            var request = CreateCompletionRequest(chat);
            var response = await SendMessage<CompletionRequest, OpenAIMessage>(chat, request, ct).ConfigureAwait(false);
            Logger.LogDebug("Reply for chat '{id}' received.", chat.Id);
            return response;
        }
        catch (Exception ex) {
            Logger.LogError(ex, "Failed to send a completion to '{id}'.", chat.Id);
            throw;
        }
    }

    public async Task<OpenAIMessage> SendToolResult(OpenAIChat chat, ToolResult[] results, CancellationToken ct = default) {
        try {
            foreach (var toolResult in results) {
                var message = new OpenAIMessage(MessageType.Tool) {
                    ToolCallId = toolResult.Id,
                    Content = toolResult.Value,
                };
                chat.Messages.Add(message);
            }
            var request = CreateCompletionRequest(chat);
            var response = await SendMessage<CompletionRequest, OpenAIMessage>(chat, request, ct).ConfigureAwait(false);
            Logger.LogDebug("Reply for chat '{id}' received.", chat.Id);
            return response;
        }
        catch (Exception ex) {
            Logger.LogError(ex, "Failed to send a completion to '{id}'.", chat.Id);
            throw;
        }
    }

    public override async Task<TResponse> SendMessage<TRequest, TResponse>(OpenAIChat chat, TRequest request, CancellationToken ct = default)
        where TRequest : class
        where TResponse : class {
        var content = JsonContent.Create(request, null, _jsonSerializerOptions);
        var response = await HttpClient.PostAsync("chat/completions", content, ct).ConfigureAwait(false);
        try {
            response.EnsureSuccessStatusCode();
            var json = await response.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
            var reply = JsonSerializer.Deserialize<MessageResponse>(json, _jsonSerializerOptions)!;
            chat.TotalNumberOfTokens = reply.Usage!.TotalTokens;
            var completion = reply.Choices[0].Message;
            var message = new OpenAIMessage(MessageType.Assistant) {
                Content = completion.Content,
                ToolCallId = completion.ToolCallId,
                ToolCalls = completion.ToolCalls,
                Name = completion.Name,
                FinishReason = completion.FinishReason,
            };
            chat.Messages.Add(message);
            return (message as TResponse)!;
        }
        catch (Exception ex) {
            var error = await response.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
            return (new OpenAIMessage(MessageType.Error) {
                Content = $"""
                           StatusCode: {response.StatusCode};
                           Content: {error};
                           Error: {ex};
                           """,
            } as TResponse)!;
        }
    }

    private static CompletionRequest CreateCompletionRequest(OpenAIChat chat)
            => new() {
                Model = chat.Options.Model,
                Temperature = chat.Options.Temperature,
                MaximumTokensPerMessage = (int?)chat.Options.MaximumTokensPerMessage,
                FrequencyPenalty = chat.Options.FrequencyPenalty,
                PresencePenalty = chat.Options.PresencePenalty,
                NumberOfChoices = chat.Options.NumberOfChoices,
                StopSignals = chat.Options.StopSignals.Count == 0 ? null : [.. chat.Options.StopSignals],
                TopProbability = chat.Options.TopProbability,
                UseStreaming = chat.Options.UseStreaming,
                Tools = chat.Options.Tools.Count == 0 ? null : [.. chat.Options.Tools],
                Messages = chat.Messages.Select(i => new Completion {
                    Role = (Role)i.Type,
                    Name = i.Name,
                    Content = i.Content,
                    FinishReason = i.FinishReason,
                    ToolCallId = i.ToolCallId,
                    ToolCalls = i.ToolCalls,
                }).ToArray(),
            };
}
-------------------------------------------------------------------
[OpenAIChatOptions.cs]
namespace DotNetToolbox.AI.OpenAI;

public record OpenAIChatOptions() : ChatOptions() {
    public const string DefaultSystemMessage = "You are a helpful agent.";
    public const string DefaultChatModel = "gpt-4-turbo-preview";
    public const byte DefaultFrequencyPenalty = 0;
    public const sbyte MinimumFrequencyPenalty = -2;
    public const byte MaximumFrequencyPenalty = 2;
    public const byte DefaultPresencePenalty = 0;
    public const sbyte MinimumPresencePenalty = -2;
    public const byte MaximumPresencePenalty = 2;
    public const uint DefaultMaximumTokensPerMessage = 8192;
    public const uint MinimumTokensPerMessage = 1024;
    public const byte DefaultNumberOfChoices = 1;
    public const byte MinimumNumberOfChoices = 1;
    public const byte MaximumNumberOfChoices = 5;
    public const byte MaximumNumberOfStopSignals = 4;
    public const byte DefaultTemperature = 1;
    public const byte MinimumTemperature = 0;
    public const byte MaximumTemperature = 2;
    public const byte DefaultTopProbability = 1;
    public const byte MinimumTopProbability = 0;
    public const byte MaximumTopProbability = 1;

    public virtual string Model { get; set; } = DefaultChatModel;
    public virtual uint? MaximumTokensPerMessage { get; set; }
    public virtual byte? NumberOfChoices { get; set; }
    public virtual decimal? FrequencyPenalty { get; set; }
    public virtual decimal? PresencePenalty { get; set; }
    public virtual HashSet<string> StopSignals { get; set; } = [];
    public virtual decimal? Temperature { get; set; }
    public virtual decimal? TopProbability { get; set; }
    public virtual HashSet<Tool> Tools { get; set; } = [];
    public virtual bool UseStreaming => false;

    public override Result Validate(IDictionary<string, object?>? context = null) {
        var result = base.Validate(context);
        if (MaximumTokensPerMessage < MinimumTokensPerMessage)
            result += new ValidationError($"Value must be greater than {MinimumTokensPerMessage}. Found: {MaximumTokensPerMessage}", nameof(MaximumTokensPerMessage));

        if (NumberOfChoices is < MinimumNumberOfChoices or > MaximumNumberOfChoices)
            result += new ValidationError($"Value must be between {MinimumNumberOfChoices} and {MaximumNumberOfChoices}. Found: {NumberOfChoices}", nameof(NumberOfChoices));

        if (FrequencyPenalty is < MinimumFrequencyPenalty or > MaximumFrequencyPenalty)
            result += new ValidationError($"Value must be between {MinimumFrequencyPenalty} and {MaximumFrequencyPenalty}. Found: {FrequencyPenalty}", nameof(FrequencyPenalty));

        if (PresencePenalty is < MinimumPresencePenalty or > MaximumPresencePenalty)
            result += new ValidationError($"Value must be between {MinimumPresencePenalty} and {MaximumPresencePenalty}. Found: {PresencePenalty}", nameof(PresencePenalty));

        if (StopSignals?.Count > MaximumNumberOfStopSignals)
            result += new ValidationError($"The maximum number of stop signals is {MaximumNumberOfStopSignals}. Found: {StopSignals.Count}.", nameof(StopSignals));

        if (StopSignals?.Count > 0 && StopSignals.Any(string.IsNullOrWhiteSpace))
            result += new ValidationError("Stop signals cannot be null, empty, or contain only whitespace.", nameof(StopSignals));

        if (Temperature is < MinimumTemperature or > MaximumTemperature)
            result += new ValidationError($"Value must be between {MinimumTemperature} and {MinimumTemperature}. Found: {Temperature}", nameof(Temperature));

        if (TopProbability is < MinimumTopProbability or > MaximumTopProbability)
            result += new ValidationError($"Value must be between {MinimumTopProbability} and {MaximumTopProbability}. Found: {TopProbability}", nameof(TopProbability));

        return result;
    }
}
-------------------------------------------------------------------
[OpenAIMessage.cs]
namespace DotNetToolbox.AI.OpenAI;

public class OpenAIMessage(MessageType type)
    : Message {
    public virtual MessageType Type { get; } = type;
    public virtual string? Content { get; set; }
    public virtual string? Name { get; set; }
    public virtual ToolCall[]? ToolCalls { get; set; }
    public virtual string? ToolCallId { get; set; }
    public virtual string? FinishReason { get; set; }
}
-------------------------------------------------------------------
[InMemoryChatRepository.cs]
namespace DotNetToolbox.AI.Repositories;

internal sealed class InMemoryChatRepository<TChat>(ILogger<InMemoryChatRepository<TChat>>? logger = null)
    : IChatRepository<TChat>
    where TChat : IChat {
    private readonly ILogger<InMemoryChatRepository<TChat>> _logger = logger ?? NullLogger<InMemoryChatRepository<TChat>>.Instance;
    private readonly ConcurrentDictionary<string, TChat> _chats = new();

    public void Dispose()
        => _chats.Clear();

    public Task<TChat[]> Get(CancellationToken ct = default) {
        _logger.LogTrace("Getting all chats...");
        return Task.FromResult(_chats.Values.ToArray());
    }

    public Task<TChat?> GetById(string id, CancellationToken ct = default) {
        _logger.LogTrace("Getting chat '{id}'...", id);
        return Task.FromResult(_chats.GetValueOrDefault(id));
    }

    public Task Add(TChat chat, CancellationToken ct = default) {
        _logger.LogTrace("Adding chat '{id}'...", chat.Id);
        _chats.TryAdd(chat.Id, chat);
        return Task.CompletedTask;
    }

    public async Task Update(string id, TChat chat, CancellationToken ct = default) {
        _logger.LogTrace("Adding chat '{id}'...", chat.Id);
        var original = await GetById(id, ct);
        if (original != null) _chats.TryUpdate(id, chat, original);
    }

    public Task Delete(string id, CancellationToken ct = default) {
        _logger.LogTrace("Removing chat '{id}'...", id);
        _chats.TryRemove(id, out _);
        return Task.CompletedTask;
    }
}
-------------------------------------------------------------------
[Function.cs]
namespace DotNetToolbox.AI.Tools;

public record Function {
    public required string Name { get; init; }
    public required string Description { get; init; }
    public ParameterList? Parameters { get; init; }
}
-------------------------------------------------------------------
[FunctionCall.cs]
namespace DotNetToolbox.AI.Tools;

public record FunctionCall {
    public required string Name { get; init; }
    public string? Arguments { get; init; }
}
-------------------------------------------------------------------
[Parameter.cs]
namespace DotNetToolbox.AI.Tools;

public record Parameter {
    public required string Type { get; init; }
    public string? Description { get; init; }
    public string[]? Enum { get; init; }
}
-------------------------------------------------------------------
[ParameterList.cs]
namespace DotNetToolbox.AI.Tools;

public record ParameterList {
    public Dictionary<string, Parameter> Properties { get; init; } = [];
    public string[] Required { get; init; } = [];
}
-------------------------------------------------------------------
[Tool.cs]
namespace DotNetToolbox.AI.Tools;

public record Tool(Function Function) {
    public ToolType Type { get; init; } = ToolType.Function;
}
-------------------------------------------------------------------
[ToolCall.cs]
namespace DotNetToolbox.AI.Tools;

public record ToolCall {
    public required string Id { get; init; }
    public required ToolType Type { get; init; }
    public required FunctionCall Function { get; init; }
}
-------------------------------------------------------------------
[ToolType.cs]
namespace DotNetToolbox.AI.Tools;

public enum ToolType {
    Function,
}
-------------------------------------------------------------------
[GlobalUsings.cs]
// Global using directives

global using System.Collections.Concurrent;
global using System.Diagnostics.CodeAnalysis;
global using System.Net;
global using System.Net.Http.Json;
global using System.Text.Json;
global using System.Text.Json.Serialization;

global using DotNetToolbox.AI.Chats;
global using DotNetToolbox.AI.HttpProvider;
global using DotNetToolbox.AI.Models;
global using DotNetToolbox.AI.OpenAI;
global using DotNetToolbox.AI.OpenAI.DataModels;
global using DotNetToolbox.AI.Repositories;
global using DotNetToolbox.AI.Tools;
global using DotNetToolbox.Http;
global using DotNetToolbox.Http.Extensions;
global using DotNetToolbox.Http.Options;
global using DotNetToolbox.Results;

global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.DependencyInjection.Extensions;
global using Microsoft.Extensions.Logging;
global using Microsoft.Extensions.Logging.Abstractions;
global using Microsoft.Extensions.Options;

global using static DotNetToolbox.Ensure;

global using OpenAiModel = DotNetToolbox.AI.OpenAI.DataModels.Model;
