---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\GlobalUsings.cs 
// Global using directives

global using System.Linq;
global using System.Net.Http.Json;
global using System.Text.Json;
global using System.Text.Json.Serialization;

global using DotNetToolbox.AI.Anthropic;
global using DotNetToolbox.AI.Anthropic.Chats;
global using DotNetToolbox.AI.Chats;
global using DotNetToolbox.AI.Models;
global using DotNetToolbox.AI.OpenAI;
global using DotNetToolbox.AI.OpenAI.Chats;
global using DotNetToolbox.AI.OpenAI.Models;
global using DotNetToolbox.Collections.Generic;
global using DotNetToolbox.Http;
global using DotNetToolbox.Http.Extensions;
global using DotNetToolbox.Http.Options;
global using DotNetToolbox.Results;

global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.DependencyInjection.Extensions;
global using Microsoft.Extensions.Logging;
global using Microsoft.Extensions.Options;

global using static DotNetToolbox.Ensure;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Agent\Agent.cs 
﻿namespace DotNetToolbox.AI.Agent;

public class Agent
    : IAgent {
    private readonly Queue<Package> _receivedRequests = [];
    private readonly Queue<Package> _receivedResponses = [];

    public string Id { get; } = Guid.NewGuid().ToString();

    public async Task Start(CancellationToken ct) {
        while (!ct.IsCancellationRequested) {
            if (_receivedRequests.TryDequeue(out var request))
                await ProcessReceivedRequest(request, ct);
            if (_receivedResponses.TryDequeue(out var response))
                await ProcessReceivedResponse(response, ct);
            await Task.Delay(100, ct);
        }
    }

    public CancellationTokenSource AddRequest(IAgent source, IChat chat) {
        var tokenSource = new CancellationTokenSource();
        var request = new Package(source, chat, tokenSource.Token);
        _receivedRequests.Enqueue(request);
        return tokenSource;
    }

    public void AddResponse(Package request) {
        if (request.Agent.Id != Id) return;
        _receivedResponses.Enqueue(request);
    }

    // Do something with the response from the processing agent.
    private async Task ProcessReceivedRequest(Package request, CancellationToken ct) {
        var ts = CancellationTokenSource.CreateLinkedTokenSource(request.Token, ct);
        if (ts.IsCancellationRequested) return;
        var result = await request.Chat.Submit(ts.Token);
        if (!result.IsOk) return;
        var isFinished = false;
        while (!isFinished)
            isFinished = await ProcessSubmissionResult(request, ct);
        request.Agent.AddResponse(request);
    }

    private Task ProcessReceivedResponse(Package response, CancellationToken ct)
        => Task.CompletedTask;

    private Task<bool> ProcessSubmissionResult(Package request, CancellationToken ct)
        => Task.FromResult(true);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Agent\IAgent.cs 
﻿namespace DotNetToolbox.AI.Agent;

public interface IAgent {
    string Id { get; }
    Task Start(CancellationToken ct);
    CancellationTokenSource AddRequest(IAgent source, IChat chat);
    void AddResponse(Package request);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Agent\Package.cs 
﻿namespace DotNetToolbox.AI.Agent;

public class Package(IAgent agent, IChat chat, CancellationToken token) {
    public string Id { get; } = Guid.NewGuid().ToString();
    public IAgent Agent { get; } = agent;
    public IChat Chat { get; } = chat;
    public CancellationToken Token { get; } = token;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\AnthropicHttpClientOptions.cs 
﻿namespace DotNetToolbox.AI.Anthropic;

public class AnthropicHttpClientOptions : HttpClientOptions {
    public override Uri? BaseAddress { get; set; } = new("https://api.anthropic.com");
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\AnthropicHttpClientProvider.cs 
﻿namespace DotNetToolbox.AI.Anthropic;

public class AnthropicHttpClientProvider(IHttpClientFactory clientFactory, IConfiguration configuration, IOptions<AnthropicHttpClientOptions> options)
    : HttpClientProvider(clientFactory, options) {
    protected override HttpClient CreateHttpClient() {
        var builder = new HttpClientOptionsBuilder(Options);
        var apiKey = IsNotNull(configuration["Anthropic:ApiKey"]);
        builder.UseApiKeyAuthentication(apiKey);
        builder.AddCustomHeader("AnthropicMessageContent-Role", "application/json");
        Options = builder.Build();
        return base.CreateHttpClient();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\Chats\AnthropicChat.cs 
﻿namespace DotNetToolbox.AI.Anthropic.Chats;

public class AnthropicChat(IHttpClientProvider httpClientProvider, AnthropicChatOptions? options = null)
    : Chat<AnthropicChat, AnthropicChatOptions, AnthropicChatRequest, AnthropicChatResponse>(httpClientProvider, options) {
    protected override AnthropicChatRequest CreateRequest() => new() {
        Model = Options.Model,
        Temperature = Options.Temperature,
        MaximumTokensPerMessage = (int)Options.MaximumTokensPerMessage,
        StopSequences = Options.StopSequences.Count == 0 ? null : [.. Options.StopSequences],
        MinimumTokenProbability = Options.MinimumTokenProbability,
        UseStreaming = Options.UseStreaming,
        Messages = Messages.ToArray(o => new AnthropicRequestMessage(o)),
    };

    protected override Message CreateMessage(AnthropicChatResponse response) {
        TotalNumberOfTokens += response.Usage.InputTokens + response.Usage.OutputTokens;
        return new("assistant", response.Completion.ToArray(i => new Content(i.Type, ((object?)i.Text ?? i.Image)!)));
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\Chats\AnthropicChatFactory.cs 
﻿namespace DotNetToolbox.AI.Anthropic.Chats;

public class AnthropicChatFactory(IHttpClientProvider httpClientProvider, ILogger<AnthropicChatFactory> logger)
    : ChatFactory<AnthropicChatFactory, AnthropicChat, AnthropicChatOptions, AnthropicChatRequest, AnthropicChatResponse>(httpClientProvider, logger);
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\Chats\AnthropicChatMetadata.cs 
﻿namespace DotNetToolbox.AI.Anthropic.Chats;

public class AnthropicChatMetadata {
    [JsonPropertyName("user_id")]
    public string? UserId { get; set; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\Chats\AnthropicChatOptions.cs 
﻿namespace DotNetToolbox.AI.Anthropic.Chats;

public class AnthropicChatOptions
    : IChatOptions {
    public const string DefaultApiEndpoint = "v1/messages";
    public const string DefaultChatModel = "claude-2.1";
    public const string DefaultSystemMessage = "You are a helpful agent.";
    public const uint MinimumTokensPerMessage = 1024;
    public const byte MinimumTemperature = 0;
    public const byte MaximumTemperature = 2;
    public const byte MinimumTopProbability = 0;
    public const byte MaximumTopProbability = 1;

    public string ApiEndpoint { get; set; } = DefaultApiEndpoint;
    public string Model { get; set; } = DefaultChatModel;
    public string SystemMessage { get; set; } = DefaultSystemMessage;
    public uint MaximumTokensPerMessage { get; set; }
    public decimal? Temperature { get; set; }
    public decimal? MinimumTokenProbability { get; set; }
    public HashSet<string> StopSequences { get; set; } = [];
    public bool UseStreaming { get; set; }

    public uint? MaximumTokensToSample { get; set; }

    public Result Validate(IDictionary<string, object?>? context = null) {
        var result = Result.Success();
        if (MaximumTokensPerMessage < MinimumTokensPerMessage)
            result += new ValidationError($"Value must be greater than {MinimumTokensPerMessage}. Found: {MaximumTokensPerMessage}", nameof(MaximumTokensPerMessage));

        if (StopSequences.Count > 0 && StopSequences.Any(string.IsNullOrWhiteSpace))
            result += new ValidationError("Stop signals cannot be null, empty, or contain only whitespace.", nameof(StopSequences));

        if (Temperature is < MinimumTemperature or > MaximumTemperature)
            result += new ValidationError($"Value must be between {MinimumTemperature} and {MinimumTemperature}. Found: {Temperature}", nameof(Temperature));

        if (MinimumTokenProbability is < MinimumTopProbability or > MaximumTopProbability)
            result += new ValidationError($"Value must be between {MinimumTopProbability} and {MaximumTopProbability}. Found: {MinimumTokenProbability}", nameof(MinimumTokenProbability));

        return result;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\Chats\AnthropicChatRequest.cs 
﻿namespace DotNetToolbox.AI.Anthropic.Chats;
public class AnthropicChatRequest {
    [JsonPropertyName("model")]
    public required string Model { get; init; }
    [JsonPropertyName("messages")]
    public required AnthropicRequestMessage[] Messages { get; init; }
    [JsonPropertyName("max_tokens")]
    public required int MaximumTokensPerMessage { get; init; }
    [JsonPropertyName("system")]
    public string? System { get; set; }
    [JsonPropertyName("metadata")]
    public AnthropicChatMetadata? Metadata { get; set; }
    [JsonPropertyName("stop_sequences")]
    public string[]? StopSequences { get; set; }
    [JsonPropertyName("stream")]
    public bool? UseStreaming { get; set; }
    [JsonPropertyName("temperature")]
    public decimal? Temperature { get; set; }
    [JsonPropertyName("top_p")]
    public decimal? MinimumTokenProbability { get; set; }

    [JsonPropertyName("top_k")]
    public decimal? MaximumTokenSamples { get; set; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\Chats\AnthropicChatResponse.cs 
﻿namespace DotNetToolbox.AI.Anthropic.Chats;

public class AnthropicChatResponse {
    [JsonPropertyName("id")]
    public required string Id { get; init; }
    [JsonPropertyName("model")]
    public string? Model { get; init; }
    [JsonPropertyName("completion")]
    public required AnthropicMessageContent[] Completion { get; set; }
    [JsonPropertyName("stop_reason")]
    public required string StopReason { get; init; }
    [JsonPropertyName("stop_sequence")]
    public required string StopSequence { get; init; }
    [JsonPropertyName("usage")]
    public required AnthropicChatUsage Usage { get; init; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\Chats\AnthropicChatUsage.cs 
﻿namespace DotNetToolbox.AI.Anthropic.Chats;

public record AnthropicChatUsage {
    [JsonPropertyName("input_tokens")]
    public int InputTokens { get; init; }
    [JsonPropertyName("output_tokens")]
    public int OutputTokens { get; init; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\Chats\AnthropicImageData.cs 
﻿namespace DotNetToolbox.AI.Anthropic.Chats;

public class AnthropicImageData {
    [JsonPropertyName("type")]
    public required string Type { get; init; }

    [JsonPropertyName("media_type")]
    public required string MediaType { get; init; }

    [JsonPropertyName("data")]
    public required string Data { get; init; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\Chats\AnthropicMessageContent.cs 
﻿namespace DotNetToolbox.AI.Anthropic.Chats;

public class AnthropicMessageContent {
    public AnthropicMessageContent(object value) {
        Text = value as string;
        Image = value as AnthropicImageData;
        Type = Text is null ? "image" : "text";
    }

    [JsonPropertyName("type")]
    public string Type { get; init; }
    [JsonPropertyName("text")]
    public string? Text { get; init; }
    [JsonPropertyName("image")]
    public AnthropicImageData? Image { get; init; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\Chats\AnthropicRequestMessage.cs 
﻿namespace DotNetToolbox.AI.Anthropic.Chats;

public class AnthropicRequestMessage {
    public AnthropicRequestMessage(object content) {
        switch (content) {
            case Message c:
                Role = c.Role;
                Content = c.Parts.ToArray(p => new AnthropicMessageContent(p));
                break;
            default:
                throw new NotSupportedException();
        }
    }
    [JsonPropertyName("role")]
    public string Role { get; init; }
    [JsonPropertyName("content")]
    public object Content { get; init; }
    [JsonPropertyName("finish_reason")]
    public string? StopReason { get; set; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Anthropic\Chats\AnthropicResponseMessage.cs 
﻿namespace DotNetToolbox.AI.Anthropic.Chats;

public class AnthropicResponseMessage {
    [JsonPropertyName("content")]
    public required AnthropicMessageContent[] Content { get; set; } = [];

    [JsonPropertyName("finish_reason")]
    public string StopReason { get; set; } = string.Empty;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Chats\Chat.cs 
﻿
using System.Net;

namespace DotNetToolbox.AI.Chats;

public abstract class Chat<TChat, TOptions, TRequest, TResponse>
    : IChat
    where TChat : Chat<TChat, TOptions, TRequest, TResponse>
    where TOptions : class, IChatOptions, new() {
    private readonly IHttpClientProvider _httpClientProvider;

    protected Chat(IHttpClientProvider httpClientProvider, TOptions? options) {
        _httpClientProvider = httpClientProvider;
        Options = options ?? Options;
    }

    public string Id { get; } = Guid.NewGuid().ToString();
    public int TotalNumberOfTokens { get; set; }

    IChatOptions IChat.Options => Options;
    public TOptions Options { get; } = new();
    public List<Message> Messages { get; } = [];

    public virtual async Task<HttpResult> Submit(CancellationToken ct = default) {
        var request = CreateRequest();
        var content = JsonContent.Create(request, options: IChatOptions.SerializerOptions);
        var httpClient = _httpClientProvider.GetHttpClient();
        var httpResult = await httpClient.PostAsync(Options.ApiEndpoint, content, ct).ConfigureAwait(false);
        try {
            httpResult.EnsureSuccessStatusCode();
            var json = await httpResult.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
            var response = JsonSerializer.Deserialize<TResponse>(json, IChatOptions.SerializerOptions)!;
            Messages.Add(CreateMessage(response));
            return HttpResult.Ok();
        }
        catch (Exception ex) {
            switch (httpResult.StatusCode) {
                case HttpStatusCode.BadRequest:
                    var response = await httpResult.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
                    var errorMessage = $"""
                                        Package: {JsonSerializer.Serialize(request, IChatOptions.SerializerOptions)}
                                        ResponseContent: {response};
                                        """;
                    return HttpResult.BadRequest(errorMessage);
                case HttpStatusCode.Unauthorized:
                case HttpStatusCode.Forbidden:
                    return HttpResult.Unauthorized();
                case HttpStatusCode.NotFound:
                    return HttpResult.NotFound();
                default:
                    return HttpResult.InternalError(ex);
            }
        }
    }

    protected abstract TRequest CreateRequest();
    protected abstract Message CreateMessage(TResponse response);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Chats\ChatFactory.cs 
﻿namespace DotNetToolbox.AI.Chats;

public abstract class ChatFactory<THandler, TChat, TOptions, TRequest, TResponse>(IHttpClientProvider httpClientProvider, ILogger<THandler> logger)
    : IChatFactory
    where THandler : ChatFactory<THandler, TChat, TOptions, TRequest, TResponse>
    where TChat : class, IChat
    where TOptions : class, IChatOptions, new()
    where TRequest : class
    where TResponse : class {

    IChat IChatFactory.Create(Action<IChatOptions>? configure)
        => Create(o => configure?.Invoke(o));

    public TChat Create(Action<TOptions>? configure = null) {
        try {
            logger.LogDebug("Creating new chat...");
            var options = new TOptions();
            configure?.Invoke(options);
            var chat = CreateInstance.Of<TChat>(httpClientProvider, options);
            logger.LogDebug("Chat '{id}' started.", chat.Id);
            return chat;
        }
        catch (Exception ex) {
            logger.LogError(ex, "Failed to create a new chat.");
            throw;
        }
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Chats\Content.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class Content(string type, object value) {
    public string Type { get; set; } = type;
    public object Value { get; set; } = value;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Chats\IChat.cs 
﻿namespace DotNetToolbox.AI.Chats;

public interface IChat {
    string Id { get; }
    List<Message> Messages { get; }
    IChatOptions Options { get; }
    public int TotalNumberOfTokens { get; set; }
    Task<HttpResult> Submit(CancellationToken ct = default);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Chats\IChatFactory.cs 
﻿namespace DotNetToolbox.AI.Chats;

public interface IChatFactory {
    IChat Create(Action<IChatOptions>? configure = null);
    //Task<Message> SendMessage(IChat chat, Message input, CancellationToken ct = default);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Chats\IChatOptions.cs 
﻿namespace DotNetToolbox.AI.Chats;

public interface IChatOptions : IValidatable {
    public static readonly JsonSerializerOptions SerializerOptions = new() {
        WriteIndented = true,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,
        Converters = { new JsonStringEnumConverter(JsonNamingPolicy.SnakeCaseLower) },
    };

    string ApiEndpoint { get; set; }
    string SystemMessage { get; set; }
    string Model { get; set; }
    uint MaximumTokensPerMessage { get; }
    decimal? Temperature { get; }
    decimal? MinimumTokenProbability { get; }
    bool UseStreaming { get; }
    HashSet<string> StopSequences { get; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Chats\Message.cs 
﻿namespace DotNetToolbox.AI.Chats;

public class Message(string source, Content[] parts) {
    public string Role { get; set; } = source;
    public Content[] Parts { get; set; } = parts;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Extensions\ServiceCollectionExtensions.cs 
﻿namespace DotNetToolbox.AI.Extensions;

public static class ServiceCollectionExtensions {
    public static IServiceCollection AddOpenAI(this IServiceCollection services, IConfiguration configuration) {
        services.AddHttpClientProvider<IHttpClientProvider, OpenAIHttpClientProvider>(configuration);
        services.TryAddScoped<IChatFactory, OpenAIChatFactory>();
        services.TryAddScoped<IModelsHandler, OpenAIModelsHandler>();
        return services;
    }

    public static IServiceCollection AddAnthropic(this IServiceCollection services, IConfiguration configuration) {
        services.AddHttpClientProvider<IHttpClientProvider, AnthropicHttpClientProvider>(configuration);
        services.TryAddScoped<IChatFactory, AnthropicChatFactory>();
        return services;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\Models\IModelsHandler.cs 
﻿namespace DotNetToolbox.AI.Models;

public interface IModelsHandler
    : IModelsHandler<string>;

/// <summary>
/// This class contains methods for handling models using OpenAI.
/// </summary>
/// <remarks>
/// This class is responsible for handling models using OpenAI. It contains methods for getting a list of models, getting a model by ID, and deleting a model. It also includes a detailed XML documentation for each method.
/// </remarks>
public interface IModelsHandler<TModel> {
    /// <summary>
    /// Gets a list of models ids of the specified type.
    /// </summary>
    /// <param name="type">The type of the models to get.</param>
    /// <returns>An array of strings with the ids of models of the specified type.</returns>
    /// <remarks>
    /// This method gets a list of model's id of the specified type from the OpenAI API.
    /// </remarks>
    Task<string[]> GetIds(string? type = null);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\OpenAIHttpClientOptions.cs 
﻿namespace DotNetToolbox.AI.OpenAI;

public class OpenAIHttpClientOptions : HttpClientOptions {
    public override Uri? BaseAddress { get; set; } = new("https://api.openai.com");
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\OpenAIHttpClientProvider.cs 
﻿namespace DotNetToolbox.AI.OpenAI;

public class OpenAIHttpClientProvider(IHttpClientFactory clientFactory, IConfiguration configuration, IOptions<OpenAIHttpClientOptions> options)
    : HttpClientProvider(clientFactory, options) {
    protected override HttpClient CreateHttpClient() {
        var builder = new HttpClientOptionsBuilder(Options);
        var key = IsNotNull(configuration["OpenAI:ApiKey"]);
        var organization = IsNotNull(configuration["OpenAI:Organization"]);
        builder.UseSimpleTokenAuthentication(opt => {
            opt.Scheme = AuthenticationScheme.Bearer;
            opt.Token = key;
        });
        builder.AddCustomHeader("OpenAI-Organization", organization);
        Options = builder.Build();
        return base.CreateHttpClient();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChat.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChat
    : Chat<OpenAIChat, OpenAIChatOptions, OpenAIChatRequest, OpenAIChatResponse> {
    public OpenAIChat(IHttpClientProvider httpClientProvider, OpenAIChatOptions? options = null)
        : base(httpClientProvider, options) {
        Messages.Add(new("system", [new("text", Options.SystemMessage)]));
    }

    protected override OpenAIChatRequest CreateRequest()
        => new() {
            Model = Options.Model,
            Temperature = Options.Temperature,
            MaximumTokensPerMessage = (int)Options.MaximumTokensPerMessage,
            FrequencyPenalty = Options.FrequencyPenalty,
            PresencePenalty = Options.PresencePenalty,
            NumberOfChoices = Options.NumberOfChoices,
            StopSequences = Options.StopSequences.Count == 0 ? null : [.. Options.StopSequences],
            MinimumTokenProbability = Options.MinimumTokenProbability,
            UseStreaming = Options.UseStreaming,
            Tools = Options.Tools.Count == 0 ? null : Options.Tools.ToArray(ToRequestToolCall),
            Messages = Messages.ToArray(o => new OpenAIChatRequestMessage(o) { Name = Options.AgentName }),
        };

    protected override Message CreateMessage(OpenAIChatResponse response) {
        TotalNumberOfTokens = response.Usage?.TotalTokens ?? TotalNumberOfTokens;
        return response.Choices[0].Message.Content switch {
            OpenAIChatResponseToolCall[] tcs => new("assistant", [new("tool_calls", tcs)]),
            _ => new("assistant", [new("text", response.Choices[0].Message.Content.ToString()!)]),
        };
    }

    private static OpenAIChatRequestToolCall ToRequestToolCall(OpenAIChatTool toolCall)
        => new(toolCall.Id, new(toolCall.Name, CreateParameterList(toolCall), toolCall.Description));
    private static OpenAIChatRequestToolCallFunctionParameters? CreateParameterList(OpenAIChatTool toolCall) {
        var parameters = GetParameters(toolCall);
        var required = GetRequiredParameters(toolCall);
        return parameters is null && required is null ? null : new(parameters, required);
    }

    private static Dictionary<string, OpenAIChatRequestToolCallFunctionParameter>? GetParameters(OpenAIChatTool toolCall) {
        var result = toolCall.Parameters.ToDictionary(k => k.Key, ToParameter);
        return result.Count == 0 ? null : result;
    }

    private static string[]? GetRequiredParameters(OpenAIChatTool toolCall) {
        var result = toolCall.Parameters.Where(p => p.Value.IsRequired).ToArray(p => p.Key);
        return result.Length == 0 ? null : result;
    }

    private static OpenAIChatRequestToolCallFunctionParameter ToParameter(KeyValuePair<string, OpenAIChatToolParameter> parameter)
        => new(parameter.Value.Type, parameter.Value.Options, parameter.Value.Description);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatFactory.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatFactory(IHttpClientProvider httpClientProvider, ILogger<OpenAIChatFactory> logger)
    : ChatFactory<OpenAIChatFactory, OpenAIChat, OpenAIChatOptions, OpenAIChatRequest, OpenAIChatResponse>(httpClientProvider, logger) {
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatOptions.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatOptions
    : IChatOptions {
    public const string DefaultApiEndpoint = "v1/chat/completions";
    public const string DefaultChatModel = "gpt-3.5-turbo-0125";
    public const string DefaultSystemMessage = "You are a helpful agent.";
    public const byte DefaultFrequencyPenalty = 0;
    public const sbyte MinimumFrequencyPenalty = -2;
    public const byte MaximumFrequencyPenalty = 2;
    public const byte DefaultPresencePenalty = 0;
    public const sbyte MinimumPresencePenalty = -2;
    public const byte MaximumPresencePenalty = 2;
    public const uint DefaultMaximumTokensPerMessage = 4096;
    public const uint MinimumTokensPerMessage = 1024;
    public const byte DefaultNumberOfChoices = 1;
    public const byte MinimumNumberOfChoices = 1;
    public const byte MaximumNumberOfChoices = 5;
    public const byte MaximumNumberOfStopSignals = 4;
    public const byte DefaultTemperature = 1;
    public const byte MinimumTemperature = 0;
    public const byte MaximumTemperature = 2;
    public const byte DefaultTopProbability = 1;
    public const byte MinimumTopProbability = 0;
    public const byte MaximumTopProbability = 1;

    public string ApiEndpoint { get; set; } = DefaultApiEndpoint;
    public string Model { get; set; } = DefaultChatModel;
    public string SystemMessage { get; set; } = DefaultSystemMessage;
    public uint MaximumTokensPerMessage { get; set; } = DefaultMaximumTokensPerMessage;
    public decimal? Temperature { get; set; }
    public decimal? MinimumTokenProbability { get; set; }
    public HashSet<string> StopSequences { get; set; } = [];
    public bool UseStreaming { get; set; }

    public string? AgentName { get; set; }
    public byte? NumberOfChoices { get; set; }
    public decimal? FrequencyPenalty { get; set; }
    public decimal? PresencePenalty { get; set; }
    public HashSet<OpenAIChatTool> Tools { get; set; } = [];

    public Result Validate(IDictionary<string, object?>? context = null) {
        var result = Result.Success();
        if (MaximumTokensPerMessage < MinimumTokensPerMessage)
            result += new ValidationError($"Value must be greater than {MinimumTokensPerMessage}. Found: {MaximumTokensPerMessage}", nameof(MaximumTokensPerMessage));

        if (NumberOfChoices is < MinimumNumberOfChoices or > MaximumNumberOfChoices)
            result += new ValidationError($"Value must be between {MinimumNumberOfChoices} and {MaximumNumberOfChoices}. Found: {NumberOfChoices}", nameof(NumberOfChoices));

        if (FrequencyPenalty is < MinimumFrequencyPenalty or > MaximumFrequencyPenalty)
            result += new ValidationError($"Value must be between {MinimumFrequencyPenalty} and {MaximumFrequencyPenalty}. Found: {FrequencyPenalty}", nameof(FrequencyPenalty));

        if (PresencePenalty is < MinimumPresencePenalty or > MaximumPresencePenalty)
            result += new ValidationError($"Value must be between {MinimumPresencePenalty} and {MaximumPresencePenalty}. Found: {PresencePenalty}", nameof(PresencePenalty));

        if (StopSequences.Count > MaximumNumberOfStopSignals)
            result += new ValidationError($"The maximum number of stop signals is {MaximumNumberOfStopSignals}. Found: {StopSequences.Count}.", nameof(StopSequences));

        if (StopSequences.Count > 0 && StopSequences.Any(string.IsNullOrWhiteSpace))
            result += new ValidationError("Stop signals cannot be null, empty, or contain only whitespace.", nameof(StopSequences));

        if (Temperature is < MinimumTemperature or > MaximumTemperature)
            result += new ValidationError($"Value must be between {MinimumTemperature} and {MinimumTemperature}. Found: {Temperature}", nameof(Temperature));

        if (MinimumTokenProbability is < MinimumTopProbability or > MaximumTopProbability)
            result += new ValidationError($"Value must be between {MinimumTopProbability} and {MaximumTopProbability}. Found: {MinimumTokenProbability}", nameof(MinimumTokenProbability));

        return result;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatRequest.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatRequest {
    [JsonPropertyName("model")]
    public required string Model { get; init; }
    [JsonPropertyName("messages")]
    public OpenAIChatRequestMessage[] Messages { get; init; } = [];
    [JsonPropertyName("frequency_penalty")]
    public decimal? FrequencyPenalty { get; set; }
    [JsonPropertyName("presence_penalty")]
    public decimal? PresencePenalty { get; set; }
    [JsonPropertyName("temperature")]
    public decimal? Temperature { get; set; }
    [JsonPropertyName("max_tokens")]
    public int MaximumTokensPerMessage { get; set; }
    [JsonPropertyName("n")]
    public int? NumberOfChoices { get; set; }
    [JsonPropertyName("stop")]
    public string[]? StopSequences { get; set; }
    [JsonPropertyName("top_p")]
    public decimal? MinimumTokenProbability { get; set; }
    [JsonPropertyName("stream")]
    public bool? UseStreaming { get; set; }
    [JsonPropertyName("tools")]
    public OpenAIChatRequestToolCall[]? Tools { get; set; }
    [JsonPropertyName("tool_choice")]
    public OpenAIChatRequestForceToolCall? ForceToolCall { get; set; }
    [JsonPropertyName("response_format")]
    public OpenAIChatRequestResponseFormat? ResponseFormat { get; set; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatRequestForceToolCall.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatRequestForceToolCall(string name) {
    [JsonPropertyName("type")]
    public string Type { get; set; } = "function";
    [JsonPropertyName("name")]
    public string Name { get; set; } = name;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatRequestMessage.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatRequestMessage {
    public OpenAIChatRequestMessage(object content) {
        switch (content) {
            case Message { Parts.Length: 1 } c:
                Role = c.Role;
                Content = (string)c.Parts[0].Value;
                break;
            case Message c:
                Role = c.Role;
                Content = c.Parts.ToArray(p => new OpenAIChatRequestMessageContent(p.Value));
                break;
            case OpenAIChatRequestMessageToolCallResult c:
                Role = "tool";
                Content = c.Value;
                ToolCallId = c.CallId;
                break;
            case OpenAIChatResponseToolCall[] c:
                Role = "assistant";
                ToolCalls = c;
                break;
            default:
                throw new NotSupportedException();
        }
    }
    [JsonPropertyName("role")]
    public string Role { get; init; }
    [JsonPropertyName("content")]
    public object? Content { get; init; }
    [JsonPropertyName("name")]
    public string? Name { get; set; }
    [JsonPropertyName("tool_calls")]
    public OpenAIChatResponseToolCall[]? ToolCalls { get; set; }
    [JsonPropertyName("tool_call_id")]
    public string? ToolCallId { get; set; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatRequestMessageContent.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatRequestMessageContent {
    public OpenAIChatRequestMessageContent(object value) {
        Text = value as string;
        Image = value as OpenAIChatRequestMessageContentImageData;
        Type = Text is null ? "image_url" : "text";
    }

    [JsonPropertyName("type")]
    public string Type { get; init; }
    [JsonPropertyName("text")]
    public string? Text { get; init; }
    [JsonPropertyName("image_url")]
    public OpenAIChatRequestMessageContentImageData? Image { get; init; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatRequestMessageContentImageData.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatRequestMessageContentImageData {
    public required string Url { get; set; }
    public string? Detail { get; set; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatRequestMessageToolCallResult.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatRequestMessageToolCallResult(string toolCallId, string value) {
    public string CallId { get; set; } = toolCallId;
    public string? Value { get; set; } = value;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatRequestResponseFormat.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatRequestResponseFormat(string type) {
    [JsonPropertyName("type")]
    public string Type { get; set; } = type;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatRequestToolCall.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatRequestToolCall(string id, OpenAIChatRequestToolCallFunction function) {
    [JsonPropertyName("id")]
    public string Id { get; set; } = id;

    [JsonPropertyName("type")]
    public string Type { get; set; } = "function";
    [JsonPropertyName("function")]
    public OpenAIChatRequestToolCallFunction Function { get; set; } = function;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatRequestToolCallFunction.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatRequestToolCallFunction(string name, OpenAIChatRequestToolCallFunctionParameters? parameters = null, string? description = null) {
    [JsonPropertyName("name")]
    public string Name { get; set; } = name;
    [JsonPropertyName("parameters")]
    public OpenAIChatRequestToolCallFunctionParameters? Parameters { get; set; } = parameters;
    [JsonPropertyName("description")]
    public string? Description { get; set; } = description;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatRequestToolCallFunctionParameter.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatRequestToolCallFunctionParameter(string type, string[]? options = null, string? description = null) {
    [JsonPropertyName("type")]
    public string Type { get; set; } = type;
    [JsonPropertyName("description")]
    public string? Description { get; set; } = description;
    [JsonPropertyName("enum")]
    public string[]? Options { get; set; } = options;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatRequestToolCallFunctionParameters.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatRequestToolCallFunctionParameters(Dictionary<string, OpenAIChatRequestToolCallFunctionParameter>? properties, string[]? required) {
    [JsonPropertyName("properties")]
    public Dictionary<string, OpenAIChatRequestToolCallFunctionParameter>? Properties { get; set; } = properties;
    [JsonPropertyName("required")]
    public string[]? Required { get; set; } = required;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatResponse.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatResponse {
    [JsonPropertyName("id")]
    public required string Id { get; init; }
    [JsonPropertyName("model")]
    public string? Model { get; init; }
    [JsonPropertyName("choices")]
    public OpenAIChatResponseChoice[] Choices { get; init; } = [];
    [JsonPropertyName("created")]
    public int Created { get; init; }
    [JsonPropertyName("system_fingerprint")]
    public string? SystemFingerprint { get; init; }
    [JsonPropertyName("usage")]
    public OpenAIChatResponseUsage? Usage { get; init; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatResponseChoice.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatResponseChoice {
    [JsonPropertyName("index")]
    public int Index { get; set; }
    [JsonPropertyName("finish_reason")]
    public string? StopReason { get; set; }
    [JsonPropertyName("message")]
    public OpenAIChatResponseMessage Message { get; set; } = default!;
    [JsonPropertyName("delta")]
    public OpenAIChatResponseMessage? Delta { set => Message = value ?? Message; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatResponseMessage.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatResponseMessage {
    [JsonPropertyName("content")]
    public required object Content { get; set; } = default!;

    [JsonPropertyName("tool_calls")]
    public OpenAIChatResponseToolCall[]? ToolCalls { set => Content = (object?)value ?? Content; }

    public object ToContent()
        => Content switch {
            OpenAIChatResponseToolCall[] => Content,
            string txt => new Message("assistant", [new("text", txt)]),
            _ => throw new NotSupportedException(),
        };
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatResponseToolCall.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatResponseToolCall(string id, string type, OpenAIChatResponseToolCallFunction function) {
    [JsonPropertyName("id")]
    public string Id { get; set; } = id;
    [JsonPropertyName("type")]
    public string Type { get; set; } = type;
    [JsonPropertyName("function")]
    public OpenAIChatResponseToolCallFunction Function { get; set; } = function;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatResponseToolCallFunction.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatResponseToolCallFunction(string name, string? arguments) {
    [JsonPropertyName("name")]
    public string Name { get; set; } = name;

    [JsonPropertyName("arguments")]
    public string? Arguments { get; set; } = arguments;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatResponseUsage.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public record OpenAIChatResponseUsage {
    [JsonPropertyName("prompt_tokens")]
    public int PromptTokens { get; init; }
    [JsonPropertyName("completion_tokens")]
    public int CompletionTokens { get; init; }
    [JsonPropertyName("total_tokens")]
    public int TotalTokens { get; init; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatTool.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatTool(string id, string name, Dictionary<string, OpenAIChatToolParameter>? parameters = null, string? description = null) {
    public string Id { get; set; } = id;
    public string Name { get; set; } = name;
    public Dictionary<string, OpenAIChatToolParameter> Parameters { get; set; } = parameters ?? [];
    public string? Description { get; set; } = description;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Chats\OpenAIChatToolParameter.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Chats;

public class OpenAIChatToolParameter(string type, string[]? options = null, bool isRequired = false, string? description = null) {
    public required string Type { get; set; } = type;
    public string? Description { get; set; } = description;
    public string[]? Options { get; set; } = options;
    public bool IsRequired { get; set; } = isRequired;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Models\OpenAIModel.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Models;

internal record OpenAIModel {
    public required string Id { get; init; }
    public long Created { get; init; }
    public string? OwnedBy { get; init; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Models\OpenAIModelsHandler.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Models;

internal class OpenAIModelsHandler(IHttpClientProvider httpClientProvider, ILogger<OpenAIModelsHandler> logger)
        : IModelsHandler {
    private readonly HttpClient _httpClient = httpClientProvider.GetHttpClient();

    public async Task<string[]> GetIds(string? type = null) {
        try {
            logger.LogDebug("Getting list of models...");
            var models = await GetModelsAsync().ConfigureAwait(false);
            var result = models
                        .Where(m => GetModelType(m.Id) == (type ?? "chat"))
                        .Select(m => m.Id)
                        .ToArray();
            logger.LogDebug("A list of {numberOfModels} models was found.", result.Length);
            return result;
        }
        catch (Exception ex) {
            logger.LogError(ex, "Failed to get list of models.");
            throw;
        }
    }

    private async Task<OpenAIModel[]> GetModelsAsync() {
        var response = await _httpClient.GetAsync("models").ConfigureAwait(false);
        response.EnsureSuccessStatusCode();
        var result = await response.Content.ReadFromJsonAsync<OpenAIModelsResponse>().ConfigureAwait(false);
        return result!.Data;
    }

    public static string GetModelType(string id) {
        var name = id.StartsWith("ft:") ? id[3..] : id;
        return name switch {
            _ when name.StartsWith("dall-e") => "image",
            _ when name.StartsWith("whisper") => "stt",
            _ when name.StartsWith("tts") => "tts",
            _ when name.StartsWith("text-embedding") => "embedding",
            _ when name.StartsWith("text-moderation") => "moderation",
            _ => "chat",
        };
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Models\OpenAIModelsResponse.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Models;

internal record OpenAIModelsResponse {
    public required OpenAIModel[] Data { get; init; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI\OpenAI\Models\OpenAIModelType.cs 
﻿namespace DotNetToolbox.AI.OpenAI.Models;

public enum OpenAIModelType {
    Chat,
    DallE,
    Whisper,
    TextToSpeech,
    Moderation,
    Embedding,
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI.Sophia\GlobalUsings.cs 
global using System.Text.Json;
global using System.Text.Json.Serialization;

global using DotNetToolbox.AI.Chats;
global using DotNetToolbox.AI.Extensions;
global using DotNetToolbox.AI.OpenAI.Chats;
global using DotNetToolbox.Collections.Generic;
global using DotNetToolbox.ConsoleApplication;
global using DotNetToolbox.ConsoleApplication.Application;
global using DotNetToolbox.ConsoleApplication.Questions;
global using DotNetToolbox.Results;
global using DotNetToolbox.Sophia;
global using DotNetToolbox.Sophia.Agents;
global using DotNetToolbox.Sophia.Skills;

global using static DotNetToolbox.Sophia.StateMachine;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI.Sophia\Program.cs 
﻿var app = Sophia.Create(args, builder => {
    builder.AddAppSettings()
           .AddUserSecrets<Program>();

    builder.Services.AddOpenAI(builder.Configuration);
});

await app.RunAsync();
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI.Sophia\Sophia.cs 
﻿namespace DotNetToolbox.Sophia;

public class Sophia : ShellApplication<Sophia> {
    private readonly StateMachine _stateMachine;

    public Sophia(string[] args, IServiceProvider services, IChatFactory chatFactory)
        : base(args, services) {
        AllowMultiLine = true;
        _stateMachine = new(this, (OpenAIChatFactory)chatFactory);
    }

    protected override string GetPrePromptText() => $"[{TotalNumberOfTokens}] ";

    private int TotalNumberOfTokens => _stateMachine.Chat?.TotalNumberOfTokens ?? 0;

    protected override async Task<Result> OnStart(CancellationToken ct) {
        await _stateMachine.Start(1, ct);
        return await base.OnStart(ct);
    }

    protected override async Task<Result> ExecuteDefault(CancellationToken ct) {
        await _stateMachine.Process(string.Empty, ct);
        return _stateMachine.CurrentState != Idle ? Result.Success() : await base.ExecuteDefault(ct);
    }

    protected override async Task<Result> ProcessFreeText(string[] lines, CancellationToken ct) {
        _stateMachine.CurrentState = 6;
        await _stateMachine.Process(string.Join('\n', lines), ct);
        return Result.Success();
    }

    public override void Exit(int code = IApplication.DefaultExitCode) {
        if (_stateMachine.CurrentState == 5) base.Exit(code);
        _stateMachine.CurrentState = 1;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI.Sophia\StateMachine.cs 
﻿namespace DotNetToolbox.Sophia;

public class StateMachine {
    private readonly IOutput _out;
    private readonly IFileSystem _io;
    private readonly IPromptFactory _promptFactory;
    private readonly IApplication _app;
    private readonly OpenAIChatFactory _chatFactory;
    private readonly MultipleChoicePrompt _mainMenu;

    private static readonly JsonSerializerOptions _fileSerializationOptions = new() {
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        WriteIndented = true,
        Converters = { new JsonStringEnumConverter() },
        IgnoreReadOnlyProperties = true,
    };

    private const string _chatsFolder = "Chats";
    private const string _agentsFolder = "Agents";
    private const string _skillsFolder = "Skills";

    public StateMachine(IApplication app, IChatFactory chatFactory) {
        _app = app;
        _chatFactory = (OpenAIChatFactory)chatFactory;
        _io = app.Environment.FileSystem;
        _out = app.Environment.Output;
        _promptFactory = app.PromptFactory;
        _io.CreateFolder(_chatsFolder);
        _mainMenu = _promptFactory.CreateMultipleChoiceQuestion("What do you want to do?", opt => {
            opt.AddChoice(2, "Create a new chat");
            opt.AddChoice(3, "Continue a existing chat");
            opt.AddChoice(4, "Delete an existing chat");
            opt.AddChoice(5, "Exit");
        });
    }

    public const uint Idle = 0;

    public OpenAIChat? Chat { get; set; }
    public uint CurrentState { get; set; }

    internal Task Start(uint initialState, CancellationToken ct) {
        CurrentState = initialState;
        return Process(string.Empty, ct);
    }

    internal Task Process(string input, CancellationToken ct) {
        switch (CurrentState) {
            case 1: return ShowMainMenu(ct);
            case 2: return Start(ct);
            case 3: return Resume(ct);
            case 4: Terminate(); break;
            case 5: _app.Exit(); break;
            case 6: return SendMessage(input, ct);
        }

        return Task.CompletedTask;
    }

    private Task ShowMainMenu(CancellationToken ct) {
        CurrentState = _mainMenu.Ask();
        return Process(string.Empty, ct);
    }

    private async Task Start(CancellationToken ct) {
        try {
            var agent = await LoadAgentProfile("TimeKeeper");
            Chat = _chatFactory.Create(opt => {
                opt.Model = "gpt-3.5-turbo-0125";
                opt.Tools = agent.Skills.ToHashSet(LoadSkill);
                opt.AgentName = agent.Name;
            });
            _io.CreateFolder($"{_chatsFolder}/{Chat.Id}");
            await SaveAgentData(Chat.Id, ct);
            _out.WriteLine($"Chat '{Chat.Id}' started.");
            CurrentState = Idle;
        }
        catch (Exception ex) {
            Console.WriteLine(ex);
            throw;
        }
    }

    private async Task Resume(CancellationToken ct) {
        var folders = _io.GetFolders(_chatsFolder).ToArray();
        if (folders.Length == 0) {
            _out.WriteLine("No chat found.");
            CurrentState = 1;
            return;
        }

        var chatId = SelectChat("Select a chat to resume:", folders);
        if (chatId == string.Empty) {
            CurrentState = 1;
            return;
        }

        Chat = await LoadAgentData(chatId, ct);
        _out.WriteLine($"Resuming chat '{chatId}'.");
        CurrentState = Idle;
    }

    private void Terminate() {
        var folders = _io.GetFolders(_chatsFolder).ToArray();
        if (folders.Length == 0) {
            _out.WriteLine("No chat found.");
            CurrentState = 1;
            return;
        }

        var chatId = SelectChat("Select a chat to cancel:", folders);
        if (chatId == string.Empty) {
            CurrentState = 1;
            return;
        }

        _io.DeleteFolder($"{_chatsFolder}/{chatId}", true);
        _out.WriteLine($"chat '{chatId}' cancelled.");
        CurrentState = 1;
    }

    private string SelectChat(string question, string[] folders) {
        var chats = _promptFactory.CreateMultipleChoiceQuestion<string>(question, opt => {
            foreach (var folder in folders) opt.AddChoice(folder, folder);
            opt.AddChoice(string.Empty, "Back to the main menu.");
        });
        var chatId = chats.Ask();
        return chatId;
    }

    private async Task SendMessage(string input, CancellationToken ct) {
        _out.Write("- ");
        Chat!.Messages.Add(new("user", [new("text", input)]));
        if (!await Submit(ct)) _out.WriteLine("Error!");
        else foreach (var part in Chat.Messages[^1].Parts) _out.WriteLine(part.Value);
        CurrentState = Idle;
    }

    private async Task<bool> Submit(CancellationToken ct) {
        var isFinished = false;
        while (!isFinished) {
            var result = await Chat!.Submit(ct);
            if (!result.IsOk) return false;
            isFinished = await CheckIfIsFinished(ct);
        }
        return true;
    }

    private Task<bool> CheckIfIsFinished(CancellationToken ct)
        => Task.FromResult(ct.IsCancellationRequested);

    private async Task SaveAgentData(string chatId, CancellationToken ct) {
        await using var chatFile = _io.OpenOrCreateFile($"{_chatsFolder}/{chatId}/agent.json");
        await JsonSerializer.SerializeAsync(chatFile, Chat, _fileSerializationOptions, ct);
    }

    private async Task<OpenAIChat?> LoadAgentData(string chatId, CancellationToken ct) {
        await using var agentFile = _io.OpenFileAsReadOnly($"{_chatsFolder}/{chatId}/agent.json");
        return await JsonSerializer.DeserializeAsync<OpenAIChat>(agentFile, _fileSerializationOptions, cancellationToken: ct);
    }

    private OpenAIChatTool LoadSkill(string name) {
        using var skillFile = _io.OpenOrCreateFile($"{_skillsFolder}/{name}.json");
        return JsonSerializer.Deserialize<OpenAIChatTool>(skillFile, _fileSerializationOptions)!;
    }

    private async Task<Agent> LoadAgentProfile(string profileName) {
        await using var agentFile = _io.OpenOrCreateFile($"{_agentsFolder}/{profileName}.json");
        return JsonSerializer.Deserialize<Agent>(agentFile, _fileSerializationOptions)!;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI.Sophia\Agents\Agent.cs 
﻿namespace DotNetToolbox.Sophia.Agents;
internal record Agent {
    public required string Name { get; init; }
    public required string Description { get; init; }
    public required string Profile { get; init; }
    public required string[] Skills { get; init; }
    public decimal? FrequencyPenalty { get; init; }
    public decimal? PresencePenalty { get; init; }
    public string[]? StopSignals { get; init; }
    public decimal? Temperature { get; init; }
    public uint? MaximumTokensPerMessage { get; init; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI.Sophia\Skills\Skill.cs 
﻿namespace DotNetToolbox.Sophia.Skills;
internal record Skill {
    public required string Name { get; set; }
    public required string Description { get; set; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI.UnitTests\GlobalUsings.cs 
global using System.Net;

global using DotNetToolbox.AI.Utilities;
global using DotNetToolbox.Http;
global using DotNetToolbox.Results;
global using DotNetToolbox.TestUtilities.Logging;

global using FluentAssertions;

global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.Logging;

global using NSubstitute;

global using Xunit;

global using static System.Text.Json.JsonSerializer;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI.UnitTests\Chats\ChatHandlerTests.cs 
using DotNetToolbox.AI.OpenAI.Chats;

using static DotNetToolbox.AI.OpenAI.Chats.OpenAIChatOptions;

namespace DotNetToolbox.AI.Chats;

public class OpenAIChatFactoryTests {
    private readonly OpenAIChatFactory _chatFactory;
    private readonly FakeHttpMessageHandler _httpMessageHandler;
    private readonly ILogger<OpenAIChatFactory> _logger;

    public OpenAIChatFactoryTests() {
        var configurationSection = Substitute.For<IConfigurationSection>();
        configurationSection.Value.Returns("SomeAPIKey");
        var httpClientProvider = Substitute.For<IHttpClientProvider>();
        _httpMessageHandler = new();
        var httpClient = new HttpClient(_httpMessageHandler, true) {
            BaseAddress = new("https://somehost.com/"),
        };
        httpClientProvider.GetHttpClient(Arg.Any<string?>(),
                                         Arg.Any<Action<HttpClientOptionsBuilder>?>())
                          .Returns(httpClient);
        _logger = new TrackedNullLogger<OpenAIChatFactory>();
        _chatFactory = new(httpClientProvider, _logger);
    }

    [Fact]
    public void Start_ReturnsChatId() {
        // Act
        var result = _chatFactory.Create();

        // Assert
        var chat = result.Should().BeOfType<OpenAIChat>().Subject;
        chat.Id.Should().NotBeNullOrEmpty();
        chat.Options.FrequencyPenalty.Should().Be(DefaultFrequencyPenalty);
        chat.Options.PresencePenalty.Should().Be(DefaultPresencePenalty);
        chat.Options.MaximumTokensPerMessage.Should().Be(DefaultMaximumTokensPerMessage);
        chat.Options.NumberOfChoices.Should().Be(DefaultNumberOfChoices);
        chat.Options.Temperature.Should().Be(DefaultTemperature);
        chat.Options.MinimumTokenProbability.Should().Be(DefaultTopProbability);
        chat.Options.UseStreaming.Should().BeTrue();
        chat.Options.StopSequences.Should().BeEmpty();
        chat.Options.Tools.Should().BeEmpty();
        _logger.Should().Contain(LogLevel.Debug, "Creating new chat...");
        _logger.Should().Contain(LogLevel.Debug, $"Chat '{chat.Id}' started.");
    }

    [Fact]
    public void Start_WithConfiguration_ReturnsChatId() {
        // Act
        var result = _chatFactory.Create(opt => {
            opt.FrequencyPenalty = 1.5m;
            opt.PresencePenalty = 1.1m;
            opt.MaximumTokensPerMessage = 100000;
            opt.NumberOfChoices = 2;
            opt.Temperature = 0.7m;
            opt.MinimumTokenProbability = 0.5m;
            opt.StopSequences.Add("Abort!");
            opt.StopSequences.Add("Stop!");
            opt.Tools.Add(new("tool1", "MyFunction1", description: "This is my first custom function"));
            opt.Tools.Add(new("tool2", "MyFunction2", description: "This is my second custom function"));
        });

        // Assert
        var chat = result.Should().BeOfType<OpenAIChat>().Subject;
        chat.Id.Should().NotBeNullOrEmpty();
        chat.Options.FrequencyPenalty.Should().Be(1.5m);
        chat.Options.PresencePenalty.Should().Be(1.1m);
        chat.Options.MaximumTokensPerMessage.Should().Be(100000);
        chat.Options.NumberOfChoices.Should().Be(2);
        chat.Options.Temperature.Should().Be(0.7m);
        chat.Options.MinimumTokenProbability.Should().Be(0.5m);
        chat.Options.UseStreaming.Should().BeTrue();
        chat.Options.StopSequences.Should().BeEquivalentTo("Abort!", "Stop!");
        chat.Options.Tools.Should().HaveCount(2);
        _logger.Should().Contain(LogLevel.Debug, "Creating new chat...");
        _logger.Should().Contain(LogLevel.Debug, $"Chat '{chat.Id}' started.");
    }

    [Fact]
    public void Start_WithInvalidConfiguration_Throws() {
        // Act
        var result = () => _chatFactory.Create(opt => {
            opt.FrequencyPenalty = 2.5m;
            opt.PresencePenalty = 2.1m;
            opt.NumberOfChoices = 10;
            opt.MaximumTokensPerMessage = 100;
            opt.Temperature = 2.7m;
            opt.MinimumTokenProbability = 1.5m;
            opt.StopSequences.Add("Abort1!");
            opt.StopSequences.Add("");
            opt.StopSequences.Add(null!);
            opt.StopSequences.Add("  ");
            opt.StopSequences.Add("Abort5!");
        });

        // Assert
        result.Should().Throw<ValidationException>();
        _logger.Should().Contain(LogLevel.Debug, "Creating new chat...");
        _logger.Should().Contain(LogLevel.Error, "Failed to Create a new chat.");
    }

    [Fact]
    public void Start_WithFaultyRepository_Throws() {
        // Act
        var result = () => _chatFactory.Create();

        // Assert
        result.Should().Throw<InvalidOperationException>();
        _logger.Should().Contain(LogLevel.Debug, "Creating new chat...");
        _logger.Should().Contain(LogLevel.Error, "Failed to Create a new chat.");
    }

    [Fact]
    public async Task SendMessage_WithInvalidChatId_ReturnsReply() {
        // Act
        await _chatFactory.SendMessage(default!, new("user", [new("text", "testMessage")]));

        // Assert
        _logger.Should().Contain(LogLevel.Debug, "Sending message to chat 'testId'...");
        _logger.Should().Contain(LogLevel.Debug, "Chat 'testId' not found.");
    }

    [Fact]
    public async Task SendMessage_ReturnsReply() {
        // Arrange
        var options = new OpenAIChatOptions {
            FrequencyPenalty = 1.5m,
            PresencePenalty = 1.1m,
            MaximumTokensPerMessage = 100000,
            NumberOfChoices = 2,
            Temperature = 0.7m,
            MinimumTokenProbability = 0.5m,
        };
        options.StopSequences.Add("Abort!");
        options.StopSequences.Add("Stop!");
        options.Tools.Add(new("tool1", "MyFunction1", description: "This is my first custom function"));
        options.Tools.Add(new("tool2", "MyFunction2", description: "This is my second custom function"));

        var chat = new OpenAIChat(options);
        var message = new OpenAIChatResponseMessage {
            Content = "testReply",
        };
        var choice = new OpenAIChatResponseChoice {
            Message = message,
        };
        var response = new OpenAIChatResponse {
            Id = "testId",
            Choices = [choice],
        };
        _httpMessageHandler.SetOkResponse(response);
        chat.Messages.Add(new("user", [new("text", "testMessage")]));

        // Act
        await chat.Submit();

        // Assert
        chat.Options.Model.Should().Be(DefaultChatModel);
        chat.Messages.Should().HaveCount(2);
        _logger.Should().Contain(LogLevel.Debug, "Sending message to chat 'testId'...");
        _logger.Should().Contain(LogLevel.Debug, "Reply for chat 'testId' received.");
    }

    [Fact]
    public async Task SendMessage_ReturnsInvalidReply() {
        // Arrange
        var chat = new OpenAIChat();
        var choice = new OpenAIChatResponseChoice {
            Message = null!,
        };
        var response = new OpenAIChatResponse {
            Id = "testId",
            Choices = [choice],
        };
        _httpMessageHandler.SetOkResponse(response);

        // Act
        await _chatFactory.SendMessage(chat, new("user", [new("text", "testMessage")]));

        // Assert
        chat.Options.Model.Should().Be(DefaultChatModel);
        chat.Messages.Should().HaveCount(2);
        _logger.Should().Contain(LogLevel.Debug, "Sending message to chat 'testId'...");
        _logger.Should().Contain(LogLevel.Debug, "Invalid reply received for chat 'testId'.");
    }

    [Fact]
    public async Task SendMessage_ReturnsDelta() {
        // Arrange
        var chat = new OpenAIChat();
        var message = new OpenAIChatResponseMessage {
            Content = "testReply",
        };
        var choice = new OpenAIChatResponseChoice {
            Delta = message,
        };
        var response = new OpenAIChatResponse {
            Id = "testId",
            Choices = [choice],
        };
        _httpMessageHandler.SetOkResponse(response);

        // Act
        await _chatFactory.SendMessage(chat, new("user", [new("text", "testMessage")]));

        // Assert
        chat.Options.Model.Should().Be(DefaultChatModel);
        chat.Messages.Should().HaveCount(2);
        _logger.Should().Contain(LogLevel.Debug, "Sending message to chat 'testId'...");
        _logger.Should().Contain(LogLevel.Debug, "Reply for chat 'testId' received.");
    }

    [Fact]
    public async Task SendMessage_WithEmptyReply_ReturnsEmptyString() {
        // Arrange
        var chat = new OpenAIChat();
        var response = new OpenAIChatResponse {
            Id = "testId",
        };
        _httpMessageHandler.SetOkResponse(response);

        // Act
        await _chatFactory.SendMessage(chat, new("user", [new("text", "testMessage")]));

        // Assert
        chat.Options.Model.Should().Be("some-model");
        chat.Messages.Should().ContainSingle();
        _logger.Should().Contain(LogLevel.Debug, "Sending message to chat 'testId'...");
        _logger.Should().Contain(LogLevel.Debug, "Invalid reply received for chat 'testId'.");
    }

    [Fact]
    public async Task SendMessage_WithFaultyConnection_Throws() {
        // Arrange
        var chat = new OpenAIChat();
        _httpMessageHandler.ForceException(new InvalidOperationException("Break!"));

        // Act
        var result = () => _chatFactory.SendMessage(chat, new("user", [new("text", "testMessage")]));

        // Assert
        chat.Options.Model.Should().Be("gpt-3.5-turbo-1106");
        await result.Should().ThrowAsync<InvalidOperationException>();
        _logger.Should().Contain(LogLevel.Debug, "Sending message to chat 'testId'...");
        _logger.Should().Contain(LogLevel.Error, "Failed to send a message to 'testId'.");
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI.UnitTests\Models\ModelsHandlerTests.cs 
using DotNetToolbox.AI.OpenAI.Models;

namespace DotNetToolbox.AI.Models;

public class ModelsHandlerTests {
    private readonly OpenAIModelsHandler _modelsHandler;
    private readonly ILogger<OpenAIModelsHandler> _logger;
    private readonly FakeHttpMessageHandler _httpMessageHandler;

    public ModelsHandlerTests() {
        var configurationSection = Substitute.For<IConfigurationSection>();
        configurationSection.Value.Returns("SomeAPIKey");
        var httpClientProvider = Substitute.For<IHttpClientProvider>();
        _httpMessageHandler = new();
        var httpClient = new HttpClient(_httpMessageHandler, true) {
            BaseAddress = new("https://somehost.com/"),
        };
        httpClientProvider.GetHttpClient(Arg.Any<string?>(),
                                         Arg.Any<Action<HttpClientOptionsBuilder>?>())
                          .Returns(httpClient);
        _logger = new TrackedNullLogger<OpenAIModelsHandler>();
        _modelsHandler = new(httpClientProvider, _logger);
    }

    [Fact]
    public async Task Get_ReturnsModels() {
        // Arrange
        var response = new OpenAIModelsResponse {
            Data = [
                new() {
                    Id = "ft:model1",
                    Created = DateTimeOffset.Parse("2020-01-01 12:34:56").ToUnixTimeSeconds(),
                    OwnedBy = "user1",
                },
                new() {
                    Id = "model2",
                    Created = DateTimeOffset.Parse("2020-01-01 12:34:56").ToUnixTimeSeconds(),
                    OwnedBy = "user1",
                },
            ],
        };
        _httpMessageHandler.SetOkResponse(response);

        // Act
        var result = await _modelsHandler.GetIds();

        // Assert
        result.Should().HaveCount(2);
        result[0].Should().Be("ft:model1");
        result[1].Should().Be("model2");
        _logger.Should().Contain(LogLevel.Debug, "Getting list of models...");
        _logger.Should().Contain(LogLevel.Debug, "A list of 2 models was found.");
    }

    [Fact]
    public async Task Get_WithFaultyConnection_Throws() {
        // Arrange
        _httpMessageHandler.ForceException(new InvalidOperationException("Break!"));

        // Act
        var result = () => _modelsHandler.GetIds();

        // Assert
        await result.Should().ThrowAsync<InvalidOperationException>();
        _logger.Should().Contain(LogLevel.Debug, "Getting list of models...");
        _logger.Should().Contain(LogLevel.Error, "Failed to get list of models.");
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\AI.UnitTests\Utilities\FakeHttpMessageHandler.cs 
namespace DotNetToolbox.AI.Utilities;

internal class FakeHttpMessageHandler
    : HttpMessageHandler {
    private Exception? _exception;
    private HttpStatusCode _statusCode = HttpStatusCode.InternalServerError;
    private string _response = string.Empty;

    public void ForceException<TException>(TException exception)
        where TException : Exception
        => _exception = exception;

    public void SetOkResponse<TData>(TData data) {
        _response = Serialize(data);
        _statusCode = HttpStatusCode.OK;
    }

    public void SetNotFoundResponse() {
        _response = string.Empty;
        _statusCode = HttpStatusCode.NotFound;
    }

    protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request,
                                                           CancellationToken cancellationToken)
        => _exception is not null
               ? Task.FromException<HttpResponseMessage>(_exception)
               : Task.FromResult(new HttpResponseMessage() {
                   StatusCode = _statusCode,
                   Content = new StringContent(_response),
               });
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Azure\AzureSecretReader.cs 
﻿namespace DotNetToolbox;

public sealed class AzureSecretReader
    : IAzureSecretReader {
    private readonly SecretClient? _client;

    public AzureSecretReader(IConfiguration configuration) {
        if (configuration.GetValue("UseLocalSecrets", false)) {
            return;
        }

        var keyVaultUrl = IsNotNull(configuration["KeyVaultUrl"]);
        var credential = new DefaultAzureCredential();
        var keyVaultUri = new Uri(keyVaultUrl);
        _client = new(keyVaultUri, credential);
    }

    public TValue? GetSecretOrDefault<TValue>(string key, TValue? defaultValue = default) {
        IsNotNull(key);
        if (_client is null) {
            return defaultValue;
        }

        try {
            var secret = _client.GetSecret(key).Value;
            return (TValue)Convert.ChangeType(secret.Value, typeof(TValue));
        }
        catch (Exception) {
            return defaultValue;
        }
    }

    public string GetSecretOrKey(string key)
        => GetSecretOrDefault(key, key)!;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Azure\GlobalUsings.cs 
// Global using directives

global using Azure.Identity;
global using Azure.Security.KeyVault.Secrets;

global using DotNetToolbox.Azure;

global using Microsoft.Extensions.Configuration;

global using static DotNetToolbox.Ensure;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Azure\IAzureSecretReader.cs 
﻿namespace DotNetToolbox.Azure;

public interface IAzureSecretReader {
    TValue? GetSecretOrDefault<TValue>(string key, TValue? defaultValue = default);
    string GetSecretOrKey(string key);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Azure.UnitTests\AzureSecretReaderTests.cs 
namespace DotNetToolbox.Azure;

public class AzureSecretReaderTests {
    private SecretClient? _secretClient;

    private AzureSecretReader CreateAzureSecretReader(bool useLocalSecrets) {
        var configuration = Substitute.For<IConfiguration>();
        var configurationSection = Substitute.For<IConfigurationSection>();
        configurationSection.Value.Returns(useLocalSecrets.ToString());
        configuration.GetSection("UseLocalSecrets").Returns(configurationSection);
        configuration["KeyVaultUrl"].Returns("https://keyVaultName.vault.azure.net/");

        var reader = new AzureSecretReader(configuration);

        if (useLocalSecrets) {
            return reader;
        }

        _secretClient = Substitute.For<SecretClient>();
        var clientField = typeof(AzureSecretReader).GetField(
            "_client",
            System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)!;

        clientField.SetValue(reader, _secretClient);

        return reader;
    }

    [Fact]
    public void GetSecretOrDefault_WhenUsingLocalSecrets_ReturnsDefault() {
        // Arrange
        const string secretName = "SecretName";
        const string defaultValue = "This is a secret value";
        var azureSecretReader = CreateAzureSecretReader(true);

        // Act
        var result = azureSecretReader.GetSecretOrDefault(secretName, defaultValue);

        // Assert
        result.Should().Be(defaultValue);
    }

    [Fact]
    public void GetSecretOrDefault_WhenValueExists_ReturnsValue() {
        // Arrange
        const string secretName = "SecretName";
        const string secretValue = "This is a secret value";
        var azureSecretReader = CreateAzureSecretReader(false);

        var secret = new KeyVaultSecret(secretName, secretValue);
        var response = Substitute.For<global::Azure.Response<KeyVaultSecret>>();
        response.Value.Returns(secret);
        _secretClient!.GetSecret(secretName).Returns(response);

        // Act
        var result = azureSecretReader.GetSecretOrDefault<string>(secretName);

        // Assert
        result.Should().Be(secretValue);
    }

    [Fact]
    public void GetSecretOrDefault_WhenValueDoesNotExist_ReturnsDefaultValue() {
        // Arrange
        const string secretName = "SecretName";
        const string defaultValue = "This is a default value";
        var azureSecretReader = CreateAzureSecretReader(false);
        _secretClient!.GetSecret(secretName).Throws<Exception>();

        // Act
        var result = azureSecretReader.GetSecretOrDefault(secretName, defaultValue);

        // Assert
        result.Should().Be(defaultValue);
    }

    [Fact]
    public void GetSecretOrKey_WhenUsingLocalSecrets_ReturnsKey() {
        // Arrange
        const string secretName = "SecretName";
        var azureSecretReader = CreateAzureSecretReader(true);

        // Act
        var result = azureSecretReader.GetSecretOrKey(secretName);

        // Assert
        result.Should().Be(secretName);
    }

    [Fact]
    public void GetSecretOrKey_WhenValueExists_ReturnsValue() {
        // Arrange
        const string secretName = "SecretName";
        const string secretValue = "This is a secret value";
        var azureSecretReader = CreateAzureSecretReader(false);

        var secret = new KeyVaultSecret(secretName, secretValue);
        var response = Substitute.For<global::Azure.Response<KeyVaultSecret>>();
        response.Value.Returns(secret);
        _secretClient!.GetSecret(secretName).Returns(response);

        // Act
        var result = azureSecretReader.GetSecretOrKey(secretName);

        // Assert
        result.Should().Be(secretValue);
    }

    [Fact]
    public void GetSecretOrKey_WhenValueDoesNotExist_ReturnsKey() {
        // Arrange
        const string secretName = "SecretName";
        var azureSecretReader = CreateAzureSecretReader(false);

        _secretClient!.GetSecret(secretName).Throws<Exception>();

        // Act
        var result = azureSecretReader.GetSecretOrKey(secretName);

        // Assert
        result.Should().Be(secretName);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Azure.UnitTests\GlobalUsings.cs 
global using Azure.Security.KeyVault.Secrets;

global using FluentAssertions;

global using Microsoft.Extensions.Configuration;

global using NSubstitute;
global using NSubstitute.ExceptionExtensions;

global using Xunit;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\GlobalUsings.cs 
global using System.Reflection;
global using System.Text;
global using System.Text.Json;
global using System.Text.RegularExpressions;

global using DotNetToolbox.Collections.Generic;
global using DotNetToolbox.ConsoleApplication.Application;
global using DotNetToolbox.ConsoleApplication.Arguments;
global using DotNetToolbox.ConsoleApplication.Exceptions;
global using DotNetToolbox.ConsoleApplication.Nodes;
global using DotNetToolbox.ConsoleApplication.Questions;
global using DotNetToolbox.ConsoleApplication.Utilities;
global using DotNetToolbox.DependencyInjection;
global using DotNetToolbox.Results;

global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.Configuration.Json;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.FileProviders;
global using Microsoft.Extensions.Logging;

global using static System.ConsoleKey;
global using static System.ConsoleModifiers;
global using static System.Text.RegularExpressions.RegexOptions;
global using static DotNetToolbox.ConsoleApplication.Utilities.OutputFormatter;
global using static DotNetToolbox.Ensure;
global using static DotNetToolbox.Results.Result;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\RunOnceApplication.cs 
﻿namespace DotNetToolbox.ConsoleApplication;

public sealed class RunOnceApplication
    : RunOnceApplication<RunOnceApplication> {
    internal RunOnceApplication(string[] args, IServiceProvider services)
        : base(args, services) {
    }
}

public abstract class RunOnceApplication<TApplication>(string[] args, IServiceProvider services)
    : RunOnceApplication<TApplication, RunOnceApplicationBuilder<TApplication>>(args, services)
    where TApplication : RunOnceApplication<TApplication>;

public abstract class RunOnceApplication<TApplication, TBuilder>(string[] args, IServiceProvider services) : ApplicationBase<TApplication, TBuilder>(args, services), IRunOnce
    where TApplication : RunOnceApplication<TApplication, TBuilder>
    where TBuilder : RunOnceApplicationBuilder<TApplication, TBuilder> {
    internal sealed override async Task Run(CancellationToken ct) {
        if (Arguments.Length == 0) {
            await ShowHelp(ct).ConfigureAwait(false);
            return;
        }

        var result = await ExecuteDefault(ct).ConfigureAwait(false);
        ProcessResult(result);
    }

    protected virtual Task<Result> ExecuteDefault(CancellationToken ct) => SuccessTask();

    private Task<Result> ShowHelp(CancellationToken ct) {
        var help = new HelpCommand(this);
        return help.Execute(ct);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\RunOnceApplicationBuilder.cs 
﻿namespace DotNetToolbox.ConsoleApplication;

public class RunOnceApplicationBuilder<TApplication>
    : RunOnceApplicationBuilder<TApplication, RunOnceApplicationBuilder<TApplication>>
    where TApplication : RunOnceApplication<TApplication> {
    internal RunOnceApplicationBuilder(string[] args)
        : base(args) {
    }
}

public abstract class RunOnceApplicationBuilder<TApplication, TBuilder>(string[] args)
    : ApplicationBuilder<TApplication, TBuilder>(args)
    where TApplication : RunOnceApplication<TApplication, TBuilder>
    where TBuilder : RunOnceApplicationBuilder<TApplication, TBuilder>;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\ShellApplication.cs 
﻿namespace DotNetToolbox.ConsoleApplication;

public sealed class ShellApplication
    : ShellApplication<ShellApplication> {
    internal ShellApplication(string[] args, IServiceProvider services)
        : base(args, services) {
    }
}

public abstract class ShellApplication<TApplication>(string[] args, IServiceProvider services)
    : ShellApplication<TApplication, ShellApplicationBuilder<TApplication>>(args, services)
    where TApplication : ShellApplication<TApplication>;

public abstract class ShellApplication<TApplication, TBuilder>
    : ApplicationBase<TApplication, TBuilder>, IRunAsShell
    where TApplication : ShellApplication<TApplication, TBuilder>
    where TBuilder : ShellApplicationBuilder<TApplication, TBuilder> {

    protected ShellApplication(string[] args, IServiceProvider services)
        : base(args, services) {
        AddCommand<ExitCommand>();
        AddCommand<ClearScreenCommand>();
        AddCommand<HelpCommand>();
    }
    protected bool AllowMultiLine { get; set; }

    internal sealed override async Task Run(CancellationToken ct) {
        Output.WriteLine(FullName);
        var result = await OnStart(ct).ConfigureAwait(false);
        ProcessResult(result);
        if (!result.IsSuccess) {
            Exit();
            return;
        }

        while (IsRunning && !ct.IsCancellationRequested)
            await ExecuteDefault(ct).ConfigureAwait(false);
    }

    protected virtual Task<Result> OnStart(CancellationToken ct) => SuccessTask();

    protected virtual string GetPrePromptText() => string.Empty;

    private async Task<Result> ProcessInput(string input, CancellationToken ct) {
        var lines = input.Split(Output.NewLine, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
        if (AllowMultiLine && lines.Length > 1)
            return await ProcessFreeText(lines, ct).ConfigureAwait(false);
        var tokens = UserInputParser.Parse(input);
        return StartsWithCommand(tokens.FirstOrDefault())
                   ? await ProcessCommand(tokens, ct).ConfigureAwait(false)
                   : await ProcessFreeText(lines, ct).ConfigureAwait(false);
    }

    protected virtual Task<Result> ProcessFreeText(string[] lines, CancellationToken ct)
        => SuccessTask();

    protected virtual Task<Result> ExecuteDefault(CancellationToken ct) {
        Output.Write(GetPrePromptText());
        Output.WritePrompt();
        var input = AllowMultiLine
                        ? Input.ReadMultiLine(Enter, Control)
                        : Input.ReadLine() ?? string.Empty;
        return ProcessInput(input, ct);
    }

    private bool StartsWithCommand(string? firstWord)
        => Commands.Any(c => c.Name.Equals(firstWord, StringComparison.OrdinalIgnoreCase)
                          || c.Aliases.Contains(firstWord));
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\ShellApplicationBuilder.cs 
﻿namespace DotNetToolbox.ConsoleApplication;

public class ShellApplicationBuilder<TApplication>
    : ShellApplicationBuilder<TApplication, ShellApplicationBuilder<TApplication>>
    where TApplication : ShellApplication<TApplication> {
    internal ShellApplicationBuilder(string[] args)
        : base(args) {
    }
}

public abstract class ShellApplicationBuilder<TApplication, TBuilder>(string[] args)
    : ApplicationBuilder<TApplication, TBuilder>(args)
    where TApplication : ShellApplication<TApplication, TBuilder>
    where TBuilder : ShellApplicationBuilder<TApplication, TBuilder>;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Application\ApplicationBase.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Application;

public abstract class ApplicationBase<TApplication, TBuilder>(string[] args, IServiceProvider services)
    : ApplicationBase(args, services),
      IApplication<TApplication, TBuilder>
    where TApplication : ApplicationBase<TApplication, TBuilder>
    where TBuilder : ApplicationBuilder<TApplication, TBuilder> {

    protected virtual ValueTask Dispose()
        => ValueTask.CompletedTask;

    public static TApplication Create(Action<TBuilder>? configureBuilder = null)
        => Create([], configureBuilder);

    public static TApplication Create(string[] args, Action<TBuilder>? configure = null) {
        var builder = CreateInstance.Of<TBuilder>((object)args);
        configure?.Invoke(builder);
        return builder.Build();
    }

    public override string ToString()
        => $"{GetType().Name}: {Name} v{Version} => {Description}";

    public int Run() => RunAsync().ConfigureAwait(false).GetAwaiter().GetResult();

    public async Task<int> RunAsync() {
        try {
            IsRunning = true;
            var taskRun = new CancellationTokenSource();
            if (Context.TryGetValue("ClearScreenOnStart", out var clearScreen) && clearScreen is true)
                Output.ClearScreen();
            if (await TryParseArguments(taskRun.Token).ConfigureAwait(false))
                return IApplication.DefaultErrorCode;
            if (!IsRunning) return ExitCode;
            await Run(taskRun.Token).ConfigureAwait(false);
            return ExitCode;
        }
        catch (ConsoleException ex) {
            Output.WriteLine(FormatException(ex));
            return ex.ExitCode;
        }
        catch (Exception ex) {
            Output.WriteLine(FormatException(ex));
            return IApplication.DefaultErrorCode;
        }
    }

    protected void ProcessResult(Result result) {
        if (result.HasException) throw result.Exception!;
        if (!result.HasErrors) return;
        Output.WriteLine(FormatValidationErrors(result.Errors));
    }

    protected async Task<bool> TryParseArguments(CancellationToken ct) {
        var result = await ArgumentsParser.Parse(this, Arguments, ct).ConfigureAwait(false);
        ProcessResult(result);
        return result.HasErrors;
    }

    protected virtual async Task<Result> ProcessCommand(string[] input, CancellationToken ct) {
        if (input.Length == 0) return Success();
        var command = FindCommand((this as IHasChildren).Commands, input[0]);
        if (command is null) return Invalid($"Command '{input[0]}' not found. For a list of available commands use 'help'.");
        var arguments = input.Skip(1).ToArray();
        return await command.Set(arguments, ct).ConfigureAwait(false);
    }

    private static ICommand? FindCommand(IEnumerable<ICommand> commands, string token)
        => token.StartsWith('"') || token.StartsWith('-')
               ? null
               : commands.FirstOrDefault(c => c.Name.Equals(token, StringComparison.CurrentCultureIgnoreCase)
                                           || c.Aliases.Contains(token));

    public async ValueTask DisposeAsync() {
        await Dispose();
        GC.SuppressFinalize(this);
    }
}

public abstract class ApplicationBase : IApplication {
    public int ExitCode { get; protected set; } = IApplication.DefaultExitCode;

    protected ApplicationBase(string[] args, IServiceProvider services) {
        Services = services;
        Arguments = args;
        Logger = services.GetRequiredService<ILoggerFactory>().CreateLogger(GetType().Name);
        Environment = services.GetRequiredService<IEnvironment>();
        PromptFactory = services.GetRequiredService<IPromptFactory>();

        AssemblyName = Environment.Assembly.Name;
        Version = Environment.Assembly.Version.ToString();
        var ata = Environment.Assembly.GetCustomAttribute<AssemblyTitleAttribute>()?.Title;
        Name = ata ?? AssemblyName;
        var ada = Environment.Assembly.GetCustomAttribute<AssemblyDescriptionAttribute>()?.Description;
        Description = ada ?? string.Empty;

        AddFlag<HelpFlag>();
        AddFlag<ClearScreenFlag>();
        AddFlag<VersionFlag>();
        IsRunning = false;
    }

    public string AssemblyName { get; }
    public string Name { get; }
    public string Version { get; }
    public string FullName => $"{Name} v{Version}";
    public string Description { get; init; }
    public ILogger Logger { get; init; }

    public IServiceProvider Services { get; }
    public IEnvironment Environment { get; }
    protected IOutput Output => Environment.Output;
    protected IInput Input => Environment.Input;
    protected IFileSystem FileSystem => Environment.FileSystem;
    protected IAssemblyDescriptor Assembly => Environment.Assembly;
    protected IDateTimeProvider DateTime => Environment.DateTime;
    protected IGuidProvider Guid => Environment.Guid;
    public IPromptFactory PromptFactory { get; }

    public NodeContext Context { get; } = [];

    public ICollection<INode> Children { get; } = new HashSet<INode>();
    public IParameter[] Parameters => [.. Children.OfType<IParameter>().OrderBy(i => i.Order)];
    public IArgument[] Options => [.. Children.OfType<IArgument>().OrderBy(i => i.Name)];
    public ICommand[] Commands => [.. Children.OfType<ICommand>().Except(Options.Cast<INode>()).Cast<ICommand>().OrderBy(i => i.Name)];

    public virtual void Exit(int exitCode = IApplication.DefaultExitCode) {
        ExitCode = exitCode;
        IsRunning = false;
    }

    protected string[] Arguments { get; }
    protected bool IsRunning { get; set; }

    IApplication INode.Application => this;
    string[] INode.Aliases => [];

    internal abstract Task Run(CancellationToken ct);

    public ICommand AddCommand(string name, Delegate action)
        => AddCommand(name, aliases: [], action);
    public ICommand AddCommand(string name, string alias, Delegate action)
        => AddCommand(name, [alias], action);
    public ICommand AddCommand(string name, string[] aliases, Delegate action)
        => NodeFactory.Create<Command>(this, name, aliases, action);
    public ICommand AddCommand<TChildCommand>()
        where TChildCommand : Command<TChildCommand>, ICommand
        => NodeFactory.Create<TChildCommand>(this);
    public void AddCommand(ICommand command) => Children.Add(command);

    public IFlag AddFlag(string name, Delegate? action = null)
        => AddFlag(name, aliases: [], action);
    public IFlag AddFlag(string name, string alias, Delegate? action = null)
        => AddFlag(name, [alias], action);
    public IFlag AddFlag(string name, string[] aliases, Delegate? action = null)
        => NodeFactory.Create<Flag>(this, name, aliases, action);
    public IFlag AddFlag<TFlag>()
        where TFlag : Flag<TFlag>, IFlag
        => NodeFactory.Create<TFlag>(this);
    public void AddFlag(IFlag flag) => Children.Add(flag);

    public IOption AddOption(string name)
        => AddOption(name, aliases: []);
    public IOption AddOption(string name, string alias)
        => AddOption(name, [alias]);
    public IOption AddOption(string name, string[] aliases)
        => NodeFactory.Create<Option>(this, name, aliases);
    public IOption AddOption<TOption>()
        where TOption : Option<TOption>, IOption
        => NodeFactory.Create<TOption>(this);
    public void AddOption(IOption option) => Children.Add(option);

    public IParameter AddParameter(string name)
        => NodeFactory.Create<Parameter>(this, name, default(string));
    public IParameter AddParameter(string name, string defaultValue)
        => NodeFactory.Create<Parameter>(this, name, IsNotNull(defaultValue));
    public IParameter AddParameter<TParameter>()
        where TParameter : Parameter<TParameter>, IParameter
        => NodeFactory.Create<TParameter>(this);
    public void AddParameter(IParameter parameter) => Children.Add(parameter);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Application\ApplicationBuilder.cs 
﻿using System.Diagnostics.CodeAnalysis;

using Microsoft.Extensions.DependencyInjection.Extensions;

namespace DotNetToolbox.ConsoleApplication.Application;

public class ApplicationBuilder<TApplication, TBuilder>
    : IApplicationBuilder<TApplication, TBuilder>
    where TApplication : ApplicationBase<TApplication, TBuilder>
    where TBuilder : ApplicationBuilder<TApplication, TBuilder> {
    private readonly string[] _args;
    private string? _environment;
    private bool _addEnvironmentVariables;
    private string? _environmentVariablesPrefix;
    private readonly Dictionary<string, object?> _extraValues = [];
    private bool _useAppSettings;
    private IFileProvider? _fileProvider;
    private Type? _userSecretsReference;
    private Action<ILoggingBuilder> _setLogging = _ => { };
    private IConfigurationManager? _configuration;
    private IAssemblyDescriptor? _assemblyDescriptor;
    private IDateTimeProvider? _dateTimeProvider;
    private IGuidProvider? _guidProvider;
    private IFileSystem? _fileSystem;
    private IOutput? _output;
    private IInput? _input;

    internal ApplicationBuilder(string[] args) {
        _args = args;
    }

    public ServiceCollection Services { get; } = [];

    public IConfigurationManager Configuration {
        get {
            BuildConfiguration();
            return _configuration;
        }
    }

    public void SetAssemblyInformation(IAssemblyDescriptor assemblyDescriptor) => _assemblyDescriptor = IsNotNull(assemblyDescriptor);
    public void SetInputHandler(IInput input) => _input = IsNotNull(input);
    public void SetOutputHandler(IOutput output) => _output = IsNotNull(output);
    public void SetFileSystem(IFileSystem fileSystem) => _fileSystem = IsNotNull(fileSystem);
    public void SetGuidProvider(IGuidProvider guidProvider) => _guidProvider = IsNotNull(guidProvider);
    public void SetDateTimeProvider(IDateTimeProvider dateTimeProvider) => _dateTimeProvider = IsNotNull(dateTimeProvider);

    public TBuilder SetEnvironment(string environment) {
        _environment = IsNotNullOrWhiteSpace(environment);
        return (TBuilder)this;
    }

    public TBuilder AddEnvironmentVariables(string? prefix) {
        _addEnvironmentVariables = true;
        _environmentVariablesPrefix = prefix;
        return (TBuilder)this;
    }

    public TBuilder AddUserSecrets<TReference>()
        where TReference : class {
        _userSecretsReference = typeof(TReference);
        return (TBuilder)this;
    }

    public TBuilder AddAppSettings(IFileProvider? fileProvider = null) {
        _useAppSettings = true;
        _fileProvider = fileProvider;
        return (TBuilder)this;
    }

    public TBuilder AddValue(string key, object value) {
        _extraValues[key] = value;
        return (TBuilder)this;
    }

    public TBuilder ConfigureLogging(Action<ILoggingBuilder> configure) {
        _setLogging = IsNotNull(configure);
        return (TBuilder)this;
    }

    [MemberNotNull(nameof(_configuration))]
    public void BuildConfiguration() {
        _configuration = new ConfigurationManager();
        SetConfiguration(_configuration);
    }

    public TApplication Build() {
        Services.AddEnvironment(_environment,
                                _assemblyDescriptor,
                                _dateTimeProvider,
                                _guidProvider,
                                _fileSystem,
                                _input,
                                _output);
        Services.TryAddSingleton<IPromptFactory, PromptFactory>();
        AddLogging(Configuration);

        var serviceProvider = Services.BuildServiceProvider();
        var app = CreateInstance.Of<TApplication>(serviceProvider, (object)_args);
        var items = Configuration.Build().AsEnumerable().ToList();
        foreach (var item in items) app.Context.Add(item.Key, item.Value);
        return app;
    }

    private void SetConfiguration(IConfigurationManager configuration) {
        AddEnvironmentVariables(configuration);
        AddJsonFile(configuration);
        AddUserSecrets(configuration);
        AddConfiguration(configuration);
        Services.AddSingleton<IConfiguration>(configuration);
    }

    private void AddLogging(IConfiguration configuration)
        => Services.AddLogging(b => {
            b.AddConfiguration(configuration);
            _setLogging(b);
        });

    private void AddUserSecrets(IConfigurationBuilder configuration) {
        if (_userSecretsReference is null) return;
        configuration.AddUserSecrets(_userSecretsReference.Assembly, optional: true, reloadOnChange: false);
    }

    private void AddEnvironmentVariables(IConfigurationBuilder configuration) {
        if (!_addEnvironmentVariables) return;
        configuration.AddEnvironmentVariables(_environmentVariablesPrefix);
    }

    private void AddConfiguration(IConfigurationBuilder configuration)
        => configuration.AddJsonStream(new MemoryStream(JsonSerializer.SerializeToUtf8Bytes(_extraValues)));

    private void AddJsonFile(IConfigurationBuilder configuration) {
        if (!_useAppSettings) return;
        configuration.AddJsonFile(ConfigureSource("appsettings.json"));
        if (!string.IsNullOrWhiteSpace(_environment)) return;
        configuration.AddJsonFile(ConfigureSource($"appsettings.{_environment}.json", isOptional: true));
    }

    private Action<JsonConfigurationSource> ConfigureSource(string path, bool isOptional = false)
        => s => {
            s.FileProvider = _fileProvider;
            s.Path = path;
            s.Optional = isOptional;
            s.ReloadOnChange = true;
            s.ResolveFileProvider();
        };
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Application\IApplication.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Application;

public interface IApplication : IHasChildren {
    public const int DefaultExitCode = 0;
    public const int DefaultErrorCode = 1;
    int ExitCode { get; }

    string Version { get; }
    string AssemblyName { get; }
    string FullName { get; }
    IServiceProvider Services { get; }

    void Exit(int exitCode = DefaultExitCode);
}

public interface IApplication<out TApplication, out TBuilder>
    : IApplication, IAsyncDisposable
    where TApplication : class, IApplication<TApplication, TBuilder>
    where TBuilder : class, IApplicationBuilder<TApplication, TBuilder> {

    int Run();
    Task<int> RunAsync();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Application\IApplicationBuilder.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Application;

public interface IApplicationBuilder<out TApplication, out TBuilder>
    where TApplication : class, IApplication<TApplication, TBuilder>
    where TBuilder : class, IApplicationBuilder<TApplication, TBuilder> {
    TBuilder SetEnvironment(string environment);

    //TBuilder SetConfigurationSectionName(string sectionName);

    TBuilder AddEnvironmentVariables(string? prefix);
    TBuilder AddAppSettings(IFileProvider? fileProvider = null);
    TBuilder AddUserSecrets<TReference>() where TReference : class;

    TBuilder ConfigureLogging(Action<ILoggingBuilder> configure);

    TApplication Build();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Arguments\ClearScreenCommand.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Arguments;

internal class ClearScreenCommand : Command<ClearScreenCommand> {
    public ClearScreenCommand(IHasChildren parent)
        : base(parent, "ClearScreen", ["cls"]) {
        Description = "Clear the screen.";
    }

    public override Task<Result> Execute(CancellationToken ct = default) {
        Environment.Output.ClearScreen();
        return SuccessTask();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Arguments\ClearScreenFlag.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Arguments;

internal sealed class ClearScreenFlag
    : Flag<ClearScreenFlag> {
    private readonly ClearScreenCommand _command;

    public ClearScreenFlag(IHasChildren parent)
        : base(parent, "Clear-Screen", ["cls"]) {
        _command = new(parent);
        Description = _command.Description;
    }

    protected override Task<Result> Execute(CancellationToken ct = default)
        => _command.Execute(ct);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Arguments\ExitCommand.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Arguments;

internal class ExitCommand : Command<ExitCommand> {
    public ExitCommand(IHasChildren parent)
        : base(parent, "Exit", []) {
        Description = "Exit the application.";
    }

    public override Task<Result> Execute(CancellationToken ct = default) {
        Application.Exit();
        return SuccessTask();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Arguments\HelpCommand.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Arguments;

internal sealed class HelpCommand
    : Command<HelpCommand> {
    private readonly IHasChildren _parent;

    public HelpCommand(IHasChildren parent)
        : base(parent, "Help", ["?"]) {
        _parent = parent;
        Description = "Display this help information.";
        AddParameter("Target", string.Empty);
    }

    public override Task<Result> Execute(CancellationToken ct = default) {
        var target = (string?)Context.GetValueOrDefault("Target");
        var command = _parent.Commands.FirstOrDefault(i => i.Name.Equals(target, StringComparison.CurrentCultureIgnoreCase));
        var help = FormatHelp(command ?? _parent);
        Environment.Output.WriteLine(help);
        return SuccessTask();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Arguments\HelpFlag.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Arguments;

internal sealed class HelpFlag
    : Flag<HelpFlag> {
    private readonly HelpCommand _command;

    public HelpFlag(IHasChildren parent)
        : base(parent, "Help", ["h", "?"]) {
        _command = new(parent);
        Description = _command.Description;
    }

    protected override Task<Result> Execute(CancellationToken ct = default) {
        var result = _command.Execute(ct);
        Application.Exit();
        return result;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Arguments\VersionCommand.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Arguments;

internal class VersionCommand : Command<VersionCommand> {
    public VersionCommand(IHasChildren parent)
        : base(parent, "Version", []) {
        Description = "Display the application's version.";
    }

    public override Task<Result> Execute(CancellationToken ct = default) {
        Environment.Output.WriteLine((Parent as IApplication)!.FullName);
        return SuccessTask();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Arguments\VersionFlag.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Arguments;

internal sealed class VersionFlag
    : Flag<VersionFlag> {
    private readonly VersionCommand _command;

    public VersionFlag(IHasChildren parent)
        : base(parent, "Version", []) {
        _command = new(parent);
        Description = _command.Description;
    }

    protected override Task<Result> Execute(CancellationToken ct = default) {
        var result = _command.Execute(ct);
        Application.Exit();
        return result;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Exceptions\ConsoleException.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Exceptions;

public class ConsoleException(string message, Exception? innerException = null) : Exception(IsNotNullOrEmpty(message), innerException) {
    public const string DefaultMessage = "An error occurred while executing the application.";

    public ConsoleException(int exitCode = IApplication.DefaultErrorCode, string? message = null, Exception? innerException = null)
        : this(message ?? DefaultMessage, innerException) {
        ExitCode = exitCode;
    }

    public int ExitCode { get; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\Command.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public sealed class Command : Command<Command> {
    internal Command(IHasChildren parent, string name, string[] aliases, Func<Command, CancellationToken, Task<Result>>? execute = null)
        : base(parent, name, aliases, execute) {
    }
}

public class Command<TCommand>(IHasChildren parent, string name, string[] aliases, Func<TCommand, CancellationToken, Task<Result>>? execute = null)
    : Node<TCommand>(parent, name, aliases), ICommand
    where TCommand : Command<TCommand> {
    public NodeContext Context { get; } = [];

    public ICollection<INode> Children { get; } = new HashSet<INode>();
    public IParameter[] Parameters => [.. Children.OfType<IParameter>().OrderBy(i => i.Order)];
    public IArgument[] Options => [.. Children.OfType<IArgument>().OrderBy(i => i.Name)];
    public ICommand[] Commands => [.. Children.OfType<ICommand>().Except(Options.Cast<INode>()).Cast<ICommand>().OrderBy(i => i.Name)];

    async Task<Result> ICommand.Set(IReadOnlyList<string> args, CancellationToken ct) {
        var result = await ArgumentsParser.Parse(this, args, ct);
        return result.IsSuccess
                   ? await Execute(ct)
                   : result;
    }

    public virtual Task<Result> Execute(CancellationToken ct = default)
        => execute?.Invoke((TCommand)this, ct) ?? SuccessTask();

    public ICommand AddCommand(string name, Delegate action)
        => AddCommand(name, aliases: [], action);
    public ICommand AddCommand(string name, string alias, Delegate action)
        => AddCommand(name, [alias], action);
    public ICommand AddCommand(string name, string[] aliases, Delegate action)
        => NodeFactory.Create<Command>(this, name, aliases, action);
    public ICommand AddCommand<TChildCommand>()
        where TChildCommand : Command<TChildCommand>, ICommand
        => NodeFactory.Create<TChildCommand>(this);
    public void AddCommand(ICommand command) => Children.Add(command);

    public IFlag AddFlag(string name, Delegate? action = null)
        => AddFlag(name, aliases: [], action);
    public IFlag AddFlag(string name, string alias, Delegate? action = null)
        => AddFlag(name, [alias], action);
    public IFlag AddFlag(string name, string[] aliases, Delegate? action = null)
        => NodeFactory.Create<Flag>(this, name, aliases, action!);
    public IFlag AddFlag<TFlag>()
        where TFlag : Flag<TFlag>, IFlag
        => NodeFactory.Create<TFlag>(this);
    public void AddFlag(IFlag flag) => Children.Add(flag);

    public IOption AddOption(string name)
        => AddOption(name, aliases: []);
    public IOption AddOption(string name, string alias)
        => AddOption(name, [alias]);
    public IOption AddOption(string name, string[] aliases)
        => NodeFactory.Create<Option>(this, name, aliases);
    public IOption AddOption<TOption>()
        where TOption : Option<TOption>, IOption
        => NodeFactory.Create<TOption>(this);
    public void AddOption(IOption option) => Children.Add(option);

    public IParameter AddParameter(string name)
        => AddParameter(name, null);
    public IParameter AddParameter(string name, string? defaultValue)
        => NodeFactory.Create<Parameter>(this, name, defaultValue);
    public IParameter AddParameter<TParameter>()
        where TParameter : Parameter<TParameter>, IParameter
        => NodeFactory.Create<TParameter>(this);
    public void AddParameter(IParameter parameter) => Children.Add(parameter);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\Flag.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public sealed class Flag(IHasChildren parent, string name, string[] aliases, Func<Flag, CancellationToken, Task<Result>>? execute = null)
    : Flag<Flag>(parent, name, aliases, execute);

public abstract class Flag<TFlag>(IHasChildren parent, string name, string[] aliases, Func<TFlag, CancellationToken, Task<Result>>? execute = null)
    : Node<TFlag>(parent, name, aliases), IFlag
    where TFlag : Flag<TFlag> {

    Task<Result> IFlag.Read(NodeContext context, CancellationToken ct) {
        context[Name] = bool.TrueString;
        return Execute(ct);
    }

    protected virtual Task<Result> Execute(CancellationToken ct = default)
        => execute?.Invoke((TFlag)this, ct) ?? SuccessTask();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\IArgument.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public interface IArgument : IHasParent;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\ICommand.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public interface ICommand : IHasParent, IHasChildren {
    Task<Result> Set(IReadOnlyList<string> args, CancellationToken ct = default);

    Task<Result> Execute(CancellationToken ct = default);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\IFlag.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public interface IFlag : IArgument {
    Task<Result> Read(NodeContext context, CancellationToken ct = default);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\IHasChildren.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public interface IHasChildren : INode {
    public NodeContext Context { get; }

    ICollection<INode> Children { get; }
    IArgument[] Options { get; }
    IParameter[] Parameters { get; }
    ICommand[] Commands { get; }

    ICommand AddCommand(string name, Delegate action);
    ICommand AddCommand(string name, string alias, Delegate action);
    ICommand AddCommand(string name, string[] aliases, Delegate action);
    ICommand AddCommand<TChildCommand>() where TChildCommand : Command<TChildCommand>, ICommand;
    void AddCommand(ICommand command);

    IFlag AddFlag(string name, Delegate? action = null);
    IFlag AddFlag(string name, string alias, Delegate? action = null);
    IFlag AddFlag(string name, string[] aliases, Delegate? action = null);
    IFlag AddFlag<TFlag>() where TFlag : Flag<TFlag>, IFlag;
    void AddFlag(IFlag flag);

    IOption AddOption(string name);
    IOption AddOption(string name, string alias);
    IOption AddOption(string name, string[] aliases);
    IOption AddOption<TOption>() where TOption : Option<TOption>, IOption;
    void AddOption(IOption option);

    IParameter AddParameter(string name);
    IParameter AddParameter(string name, string defaultValue);
    IParameter AddParameter<TParameter>() where TParameter : Parameter<TParameter>, IParameter;
    void AddParameter(IParameter parameter);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\IHasParent.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public interface IHasParent : INode {
    IHasChildren Parent { get; }
};
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\INode.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public interface INode {
    string Name { get; }
    string[] Aliases { get; }
    string Description { get; }
    IApplication Application { get; }
    IEnvironment Environment { get; }
    IPromptFactory PromptFactory { get; }

    public string Path => this switch {
                              IApplication app => app.AssemblyName,
                              IHasParent { Parent: not IRunAsShell } node => $"{node.Parent.Path} {Name}".Trim(),
                              _ => Name,
                          };
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\IOption.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public interface IOption : IArgument {
    Task<Result> Read(string? value, NodeContext context, CancellationToken ct = default);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\IParameter.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public interface IParameter : IHasParent {
    int Order { get; }
    string? DefaultValue { get; }
    bool IsRequired { get; }
    bool IsSet { get; }

    Task<Result> Read(string? value, NodeContext context, CancellationToken ct = default);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\IRunAsShell.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public interface IRunAsShell : IApplication;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\IRunOnce.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public interface IRunOnce : IApplication;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\Node.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public abstract class Node<TNode>
    : IHasParent
    where TNode : Node<TNode> {

    protected Node(IHasChildren parent, string name, params string[] aliases) {
        Parent = parent;
        Application = FindRoot(this);
        Environment = Application.Environment;
        PromptFactory = new PromptFactory(Environment);
        var factory = Application.Services.GetRequiredService<ILoggerFactory>();
        Logger = factory.CreateLogger<TNode>();
        Name = IsValid(name, IsValidName);
        Aliases = DoesNotContainInvalidItems<string[], string>(aliases, IsValidAlias);
    }

    public IApplication Application { get; }
    public IEnvironment Environment { get; }
    public IPromptFactory PromptFactory { get; }
    public IHasChildren Parent { get; }
    public string Name { get; }
    public string[] Aliases { get; }
    public string Description { get; init; } = string.Empty;

    protected ILogger<TNode> Logger { get; }

    public override string ToString()
        => $"{GetType().Name}: {string.Join(", ", [Name, .. Aliases])} => {Description}";

    private static IApplication FindRoot(INode node) {
        while (node is IHasParent hasParent) node = hasParent.Parent;
        return (IApplication)node;
    }

    private static bool IsValidName(string? name)
        => name is not null
        && name.Length > 1
        && char.IsLetter(name[0])
        && name[1..].All(c => char.IsLetterOrDigit(c) || "-_".Contains(c));

    private static bool IsValidAlias(string? alias)
        => !string.IsNullOrEmpty(alias)
        && alias.All(c => char.IsLetterOrDigit(c) || "!?@#$%&".Contains(c));
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\NodeContext.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public class NodeContext : Dictionary<string, object?>;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\Option.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public sealed class Option(IHasChildren parent, string name, params string[] aliases)
        : Option<Option>(parent, name, aliases);

public abstract class Option<TOption>(IHasChildren parent, string name, params string[] aliases)
    : Node<TOption>(parent, name, aliases), IOption
    where TOption : Option<TOption> {

    Task<Result> IOption.Read(string? value, NodeContext context, CancellationToken ct) {
        context[Name] = value switch {
            null or "null" or "default" => null,
            ['"', .. var text, '"'] => text,
            _ => value,
        };

        return Execute(ct);
    }

    protected virtual Task<Result> Execute(CancellationToken ct = default) => SuccessTask();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Nodes\Parameter.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Nodes;

public sealed class Parameter(IHasChildren parent, string name, string? defaultValue = null)
        : Parameter<Parameter>(parent, name, defaultValue);

public abstract class Parameter<TParameter>
    : Node<TParameter>, IParameter
    where TParameter : Parameter<TParameter> {

    protected Parameter(IHasChildren parent, string name, string? defaultValue = default)
        : base(parent, name) {
        DefaultValue = defaultValue;
        parent.Context[Name] = DefaultValue;
        Order = parent.Children.OfType<IParameter>().Count();
    }

    public int Order { get; }
    public string? DefaultValue { get; }
    public bool IsRequired => DefaultValue is null;
    public bool IsSet { get; private set; }

    Task<Result> IParameter.Read(string? value, NodeContext context, CancellationToken ct) {
        context[Name] = value switch {
            null or "default" => DefaultValue,
            "null" => null,
            ['"', .. var text, '"'] => text,
            _ => value,
        };
        IsSet = true;
        return Execute(ct);
    }

    protected virtual Task<Result> Execute(CancellationToken ct = default) => SuccessTask();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Questions\Choice.cs 
namespace DotNetToolbox.ConsoleApplication.Questions;

public record Choice<TResult> {
    private readonly string _text;
    private readonly string? _order;
    private readonly string? _alias;

    public Choice(TResult result, string text, string? alias = null)
        : this(null, result, text, alias) {
    }
    public Choice(int order, TResult result, string text, string? alias = null)
        : this((order + 1).ToString(), result, text, alias) {
    }

    private Choice(string? order, TResult value, string text, string? alias = null) {
        Value = value;
        _text = text;
        _order = order;
        _alias = alias;
        Display = GetFormattedText();
        return;

        string GetFormattedText() {
            var sb = new StringBuilder();
            if (order is not null) sb.Append($"[{order}]. ");
            var pos = IsNotNullOrWhiteSpace(text).IndexOf(alias ?? string.Empty, StringComparison.OrdinalIgnoreCase);
            if ((alias is not null) && pos != -1) sb.Append(text[..pos]).Append($"[{alias}]").Append(text[(pos + alias.Length)..]);
            else if (alias is not null) sb.Append($"[{alias}] ").Append(text);
            else sb.Append(text);
            return sb.ToString();
        }
    }

    public string Display { get; }
    public TResult Value { get; }

    public bool Matches(string input)
        => _alias?.Equals(input, StringComparison.InvariantCultureIgnoreCase)
        ?? _order?.Equals(input, StringComparison.InvariantCultureIgnoreCase)
        ?? _text.Equals(input, StringComparison.InvariantCultureIgnoreCase);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Questions\FreeTextOptions.cs 
namespace DotNetToolbox.ConsoleApplication.Questions;

public class FreeTextOptions
    : QuestionOptions {
    public bool UseCtrlEnterToSubmit { get; set; } = false;
    public Func<string, bool> ValidateInput { get; set; } = _ => true;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Questions\FreeTextPrompt.cs 
namespace DotNetToolbox.ConsoleApplication.Questions;

public class FreeTextPrompt(string question, IEnvironment environment, FreeTextOptions options)
    : QuestionPrompt<string>(question, environment) {

    public override bool Validate(string input, out string result) {
        result = string.Empty;
        var isValid = options.ValidateInput(input);
        if (isValid) result = input;
        return isValid;
    }

    protected override string InvalidAnswerMessage => "The answer is not valid.";
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Questions\IPromptFactory.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Questions;

public interface IPromptFactory {
    YesOrNoPrompt CreateYesOrNoQuestion(string question, Action<YesOrNoOptions>? configure = null);
    MultipleChoicePrompt<TResult> CreateMultipleChoiceQuestion<TResult>(string question, Action<MultipleChoiceOptions<TResult>> configure);
    MultipleChoicePrompt CreateMultipleChoiceQuestion(string question, Action<MultipleChoiceOptions> configure);
    FreeTextPrompt CreateFreeTextQuestion(string question, Action<FreeTextOptions>? configure = null);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Questions\MultipleChoiceOptions.cs 
namespace DotNetToolbox.ConsoleApplication.Questions;

public class MultipleChoiceOptions
    : MultipleChoiceOptions<uint> {
    public override MultipleChoiceOptions AddChoice(uint result, string text, string? alias = null) {
        Choices.Add(new(Choices.Count, result, text, alias));
        return this;
    }

    public MultipleChoiceOptions AddChoice(string text, string? alias = null)
        => AddChoice((uint)(Choices.Count + 1), text, alias);
}

public class MultipleChoiceOptions<TResult>
    : QuestionOptions {
    public List<Choice<TResult>> Choices { get; } = [];
    public virtual MultipleChoiceOptions<TResult> AddChoice(TResult result, string text, string? alias = null) {
        Choices.Add(new(Choices.Count, result, text, alias));
        return this;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Questions\MultipleChoicePrompt.cs 
namespace DotNetToolbox.ConsoleApplication.Questions;

public class MultipleChoicePrompt(string question, IEnvironment environment, MultipleChoiceOptions options)
    : MultipleChoicePrompt<uint>(question, environment, options);

public class MultipleChoicePrompt<TResult>(string question, IEnvironment environment, MultipleChoiceOptions<TResult> options)
    : QuestionPrompt<TResult>(question, environment) {
    protected override void ShowPrompt() {
        IsNotEmpty(options.Choices);
        foreach (var choice in options.Choices.AsIndexed()) Output.WriteLine(choice.Value.Display);
        Output.Write("Please select one of the choices above ");
        base.ShowPrompt();
    }

    public override bool Validate(string input, out TResult result) {
        result = default!;
        var choice = options.Choices.FirstOrDefault(o => o.Matches(input));
        if (choice is null) return false;
        result = choice.Value;
        return true;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Questions\PromptFactory.cs 
namespace DotNetToolbox.ConsoleApplication.Questions;

public class PromptFactory(IEnvironment environment)
    : IPromptFactory {
    public YesOrNoPrompt CreateYesOrNoQuestion(string question, Action<YesOrNoOptions>? configure = null) {
        var options = new YesOrNoOptions();
        configure?.Invoke(options);
        return new(question, environment, options);
    }

    public MultipleChoicePrompt<TResult> CreateMultipleChoiceQuestion<TResult>(string question, Action<MultipleChoiceOptions<TResult>> configure) {
        var options = new MultipleChoiceOptions<TResult>();
        configure?.Invoke(options);
        return new(question, environment, options);
    }

    public MultipleChoicePrompt CreateMultipleChoiceQuestion(string question, Action<MultipleChoiceOptions> configure) {
        var options = new MultipleChoiceOptions();
        configure?.Invoke(options);
        return new(question, environment, options);
    }

    public FreeTextPrompt CreateFreeTextQuestion(string question, Action<FreeTextOptions>? configure = null) {
        var options = new FreeTextOptions();
        configure?.Invoke(options);
        return new FreeTextPrompt(question, environment, options);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Questions\QuestionOptions.cs 
namespace DotNetToolbox.ConsoleApplication.Questions;

public abstract class QuestionOptions;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Questions\QuestionPrompt.cs 
namespace DotNetToolbox.ConsoleApplication.Questions;

public abstract class Prompt(IEnvironment environment) {
    protected IOutput Output { get; } = environment.Output;
    protected IInput Input { get; } = environment.Input;
    protected virtual void ShowPrompt() => Output.WritePrompt();
}

public abstract class QuestionPrompt<TResult>(string question, IEnvironment environment) 
    : Prompt(environment) {
    protected string Question { get; set; } = IsNotNullOrWhiteSpace(question);
    public abstract bool Validate(string input, out TResult result);

    public virtual TResult Ask() {
        while (true) {
            Output.WriteLine(Question);
            ShowPrompt();
            var answer = Input.ReadLine()?.Trim() ?? string.Empty;
            if (Validate(answer, out var result)) return result;
            Output.WriteLine(InvalidAnswerMessage, answer);
        }
    }

    protected virtual string InvalidAnswerMessage => "'{0}' is not a valid answer.";
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Questions\YesOrNoOptions.cs 
namespace DotNetToolbox.ConsoleApplication.Questions;

public class YesOrNoOptions
    : QuestionOptions {
    public Choice<bool> Yes { get; set; } = new(true, "Yes", "Y");
    public Choice<bool> No { get; set; } = new(false, "No", "N");
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Questions\YesOrNoPrompt.cs 
namespace DotNetToolbox.ConsoleApplication.Questions;

public class YesOrNoPrompt(string question, IEnvironment environment, YesOrNoOptions options)
    : QuestionPrompt<bool>(question, environment) {
    protected override void ShowPrompt() {
        Output.Write($"Please select {options.Yes.Display} or {options.No.Display} ");
        base.ShowPrompt();
    }

    public override bool Validate(string input, out bool result) {
        result = default;
        if (options.Yes.Matches(input)) {
            result = true;
            return true;
        }
        if (!options.No.Matches(input)) return false;
        result = false;
        return true;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Utilities\ArgumentsParser.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Utilities;

public static class ArgumentsParser {
    public static async Task<Result> Parse(IHasChildren node, IReadOnlyList<string> arguments, CancellationToken ct) {
        var result = Success();
        ResetContext(node);
        for (var index = 0; index < arguments.Count; index++)
            (result, index) = await TrySetupChild(node, arguments, index, ct);
        return EnsureAllRequiredParametersAreSet(node, result);
    }

    private static void ResetContext(IHasChildren node) {
        if (node is IApplication) return;
        node.Context.Clear();
        foreach (var flag in node.Options.Where(o => o is IFlag))
            node.Context[flag.Name] = bool.FalseString;
        foreach (var optional in node.Parameters.Where(p => !p.IsRequired))
            node.Context[optional.Name] = optional.DefaultValue;
    }

    private static async Task<(Result result, int index)> TrySetupChild(IHasChildren node, IReadOnlyList<string> arguments, int index, CancellationToken ct) {
        var child = FindChild(node, arguments[index]);
        return child switch {
            IFlag f => (await f.Read(node.Context, ct), index),
            IOption when index >= arguments.Count - 1 => (Invalid($"Missing value for option '{arguments[index]}'."), index + 1),
            IOption o => (await o.Read(arguments[++index], node.Context, ct), index),
            ICommand c => (await c.Set(arguments.Skip(++index).ToArray(), ct), index),
            _ => (await ReadParameters(node, arguments.Skip(index).ToArray(), ct), arguments.Count - 1),
        };
    }

    private static INode? FindChild(IHasChildren node, string token)
        => token.StartsWith('"')
               ? null
               : token.StartsWith('-')
                   ? token.StartsWith("--")
                         ? node.Children.FirstOrDefault(c => c.Name.Equals(token.TrimStart('-'), StringComparison.CurrentCultureIgnoreCase))
                         : node.Children.FirstOrDefault(c => c.Aliases.Contains(token.TrimStart('-')))
                   : node.Children.FirstOrDefault(c => c.Name.Contains(token, StringComparison.CurrentCultureIgnoreCase)
                                               || c.Aliases.Contains(token));

    private static async Task<Result> ReadParameters(IHasChildren node, IReadOnlyList<string> arguments, CancellationToken ct) {
        if (node.Parameters.Length == 0) return Invalid($"Unknown argument '{arguments[0]}'. For a list of available arguments use '--help'.");
        var index = 0;
        var result = Success();
        foreach (var parameter in node.Parameters) {
            if (index >= arguments.Count) break;
            result += arguments[index].StartsWith('-')
                ? Invalid($"Unknown argument '{arguments[index]}'. For a list of available arguments use '--help'.")
                : await parameter.Read(arguments[index], node.Context, ct);
            index++;
        }

        return result;
    }

    private static Result EnsureAllRequiredParametersAreSet(IHasChildren node, Result result) {
        var missingParameters = node.Parameters.Where(p => p is { IsRequired: true, IsSet: false }).Select(p => p.Name).ToArray();
        return missingParameters.Length > 0
                   ? Invalid($"Required parameter is missing: '{string.Join("', '", missingParameters)}'.")
                   : result;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Utilities\NodeFactory.cs 
namespace DotNetToolbox.ConsoleApplication.Utilities;

public static class NodeFactory
{
    internal static TChild Create<TChild>(IHasChildren parent, string name, string[] aliases, Delegate? action)
        where TChild : class, IHasParent {
        var actionWrapper = ConvertToActionWrapper<TChild>(action);
        var child = CreateInstance.Of<TChild>(parent, name, aliases, actionWrapper);
        parent.Children.Add(child);
        return child;
    }

    internal static TChild Create<TChild>(IHasChildren parent, string name, string? defaultValue)
        where TChild : class, IHasParent {
        var child = CreateInstance.Of<TChild>(parent, name, defaultValue);
        parent.Children.Add(child);
        return child;
    }

    internal static TChild Create<TChild>(IHasChildren parent, string name, string[] aliases)
        where TChild : class, IHasParent {
        var child = CreateInstance.Of<TChild>(parent, name, aliases);
        parent.Children.Add(child);
        return child;
    }

    internal static TChild Create<TChild>(IHasChildren parent)
        where TChild : class, IHasParent {
        var child = CreateInstance.Of<TChild>(parent.Application.Services, parent);
        parent.Children.Add(child);
        return child;
    }

    internal static Func<TNode, CancellationToken, Task<Result>> ConvertToActionWrapper<TNode>(Delegate? action)
        => action switch {
               null => (_, _) => SuccessTask(),
               Action func => (_, ct) => Task.Run(() => func(), ct).ContinueWith(_ => Success(), ct, TaskContinuationOptions.NotOnFaulted, TaskScheduler.Current),
               Action<TNode> func => (c, ct) => Task.Run(() => func(c), ct).ContinueWith(_ => Success(), ct, TaskContinuationOptions.NotOnFaulted, TaskScheduler.Current),
               Func<Result> func => (_, _) => Task.FromResult(func()),
               Func<Task<Result>> func => (_, _) => func(),
               Func<Task> func => (_, ct) => func().ContinueWith(_ => Success(), ct),
               Func<CancellationToken, Task<Result>> func => (_, ct) => func(ct),
               Func<CancellationToken, Task> func => (_, ct) => func(ct).ContinueWith(_ => Success(), ct),
               Func<TNode, Result> func => (cmd, _) => Task.FromResult(func(cmd)),
               Func<TNode, Task<Result>> func => (cmd, _) => func(cmd),
               Func<TNode, Task> func => (cmd, ct) => func(cmd).ContinueWith(_ => Success(), ct),
               Func<TNode, CancellationToken, Task<Result>> func => (cmd, ct) => func(cmd, ct),
               Func<TNode, CancellationToken, Task> func => (cmd, ct) => func(cmd, ct).ContinueWith(_ => Success(), ct),
               _ => throw new ArgumentException("Unsupported delegate type for action", nameof(action)),
           };
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Utilities\OutputFormatter.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Utilities;

internal class OutputFormatter {
    private const int _indentSize = 4;

    public static string FormatException(Exception exception) {
        var builder = new StringBuilder();
        ShowException(builder, exception);
        return builder.ToString();
    }

    public static string FormatValidationErrors(IReadOnlyCollection<ValidationError> errors) {
        var builder = new StringBuilder();
        foreach (var error in errors)
            builder.AppendLine($"Validation error: {error.Message}");
        return builder.ToString();
    }

    public static string FormatHelp(IHasChildren node) {
        var builder = new StringBuilder();
        ShowNodeDescription(builder, node);
        ShowUsage(builder, node);
        ShowAliases(builder, node);
        ShowItems(builder, "Options", node.Options);
        ShowItems(builder, "Parameters", node.Parameters);
        ShowItems(builder, "Commands", node.Commands);
        return builder.ToString();
    }

    private static void ShowNodeDescription(StringBuilder builder, INode node) {
        if (node is IApplication app) builder.AppendLine(app.FullName);
        if (string.IsNullOrWhiteSpace(node.Description)) return;
        builder.AppendLine(node.Description.Trim());
    }

    private static void ShowUsage(StringBuilder builder, IHasChildren node) {
        if (builder.Length != 0) builder.AppendLine();
        builder.AppendLine("Usage:");
        ShowDefaultUsage(builder, node);
        ShowUsageWithParameters(builder, node);
    }

    private static void ShowDefaultUsage(StringBuilder builder, IHasChildren node) {
        if (node.Commands.Length == 0 && node.Parameters.Length != 0) return;
        builder.Append(' ', _indentSize).Append(node.Path);
        if (node.Options.Length != 0) builder.Append(" [Options]");
        if (node.Commands.Length != 0) builder.Append(" [Commands]");
        builder.AppendLine();
    }

    private static void ShowUsageWithParameters(StringBuilder builder, IHasChildren node) {
        if (node.Parameters.Length == 0) return;
        builder.Append(' ', _indentSize).Append(node.Path);
        if (node.Options.Length != 0) builder.Append(" [Options]");
        foreach (var parameter in node.Parameters) {
            if (parameter.IsRequired) builder.Append($" <{parameter.Name}>");
            else builder.Append($" [<{parameter.Name}>]");
        }
        builder.AppendLine();
    }

    private static void ShowAliases(StringBuilder builder, IHasChildren node) {
        if (node.Aliases.Length == 0) return;
        builder.AppendLine();
        builder.Append("Aliases: ").AppendJoin(", ", node.Aliases).AppendLine();
    }

    private static void ShowItems(StringBuilder builder, string section, IReadOnlyCollection<INode> items) {
        if (items.Count == 0) return;
        builder.AppendLine();
        builder.AppendLine($"{section}:");
        foreach (var item in items)
            ShowItem(builder, item);
    }

    private static void ShowException(StringBuilder builder, Exception ex, bool isInner = false, byte indent = 0) {
        while (true) {
            ShowExceptionDescription(builder, ex, isInner, indent);
            ShowStackTrace(builder, ex, (byte)(indent + 1));
            if (ex.InnerException is null) break;
            ex = ex.InnerException;
            isInner = true;
            indent = (byte)(indent + 1);
        }
    }

    private static void ShowExceptionDescription(StringBuilder builder, Exception ex, bool isInner, int indent) {
        builder.Append(' ', indent * _indentSize);
        if (isInner) builder.Append("Inner Exception => ");
        builder.Append(ex.GetType().Name);
        builder.Append(": ");
        builder.AppendLine(ex.Message);
    }

    private static void ShowStackTrace(StringBuilder builder, Exception ex, byte indent) {
        if (string.IsNullOrEmpty(ex.StackTrace)) return;
        builder.Append(' ', indent * _indentSize).AppendLine("Stack Trace:");
        var lines = ex.StackTrace.Split(System.Environment.NewLine);
        _ = lines.Aggregate(builder, (s, l) => s.Append(' ', (indent + 1) * _indentSize).AppendLine(l));
    }

    public static void ShowItem(StringBuilder builder, INode node) {
        var itemId = new StringBuilder();
        itemId.Append(' ', _indentSize);
        ShowIds();
        var length = itemId.Length;
        builder.Append(itemId);
        ShowItemDescription();
        return;

        void ShowIds() {
            string[] ids = node is IArgument _
                               ? [$"--{node.Name.ToLower()}", .. node.Aliases.Select(a => $"-{a}")]
                               : [node.Name, .. node.Aliases];
            itemId.AppendJoin(", ", ids);
        }

        void ShowItemDescription() {
            var lines = node.Description.Split(System.Environment.NewLine, StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
            if (lines.Length == 0) {
                builder.AppendLine();
                return;
            }
            builder.Append(' ', 30 - length).AppendLine(lines[0]);
            foreach (var line in lines.Skip(1)) {
                builder.Append(' ', 30).AppendLine(line);
            }
        }
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console\Utilities\UserInputParser.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Utilities;

internal static class UserInputParser {
    private const RegexOptions _parserOptions = IgnoreCase
                                              | Singleline
                                              | Compiled
                                              | CultureInvariant
                                              | NonBacktracking;
    private static readonly Regex _word = new("""
                                              "[^"]+"|\S+
                                              """, _parserOptions);
    public static string[] Parse(string input)
        => _word.Matches(input).Select(m => m.Value).ToArray();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.SampleCLI\GlobalUsings.cs 
global using DotNetToolbox.ConsoleApplication;
global using DotNetToolbox.ConsoleApplication.Nodes;
global using DotNetToolbox.Results;

global using SampleCLI.Commands;

global using static DotNetToolbox.Results.Result;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.SampleCLI\Program.cs 
﻿RunOnceApplication.Create(args).Run();
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.SampleCLI\Commands\SayCommand.cs 
﻿namespace SampleCLI.Commands;

internal class SayCommand : Command<SayCommand> {
    public SayCommand(IHasChildren node)
        : base(node, "Say", []) {
        AddParameter("Text");
    }

    public override Task<Result> Execute(CancellationToken ct) {
        var text = Application.Context["Text"];
        Environment.Output.WriteLine(text);
        return SuccessTask();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.SampleShell\BigMouth.cs 
﻿namespace BigMouth;

public class BigMouth
    : ShellApplication<BigMouth> {
    public BigMouth(string[] args, IServiceProvider services)
        : base(args, services) {
        AddCommand<SayCommand>();
    }

    protected override Task<Result> OnStart(CancellationToken ct = default) {
        var result = base.OnStart(ct);
        var name = Context["MyName"];
        Environment.Output.WriteLine($"Hello {name}.");
        return result;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.SampleShell\GlobalUsings.cs 
global using DotNetToolbox.ConsoleApplication;
global using DotNetToolbox.ConsoleApplication.Nodes;
global using DotNetToolbox.Results;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.SampleShell\Program.cs 
﻿var app = BigMouth.BigMouth.Create(args, b => {
                                             b.AddAppSettings(); // This will add the values from appsettings.json to the context
                                             b.AddUserSecrets<Program>(); // This will add the values from the user secrets to the context
                                         });

await app.RunAsync();
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.SampleShell\SayCommand.cs 
﻿namespace BigMouth;

public class SayCommand : Command<SayCommand> {
    public SayCommand(IHasChildren parent)
        : base(parent, "Say", ["s"]) {
        AddOption("My");
        AddParameter("Info", "Color");
    }

    public override Task<Result> Execute(CancellationToken ct = default) {
        var name = Application.Context["MyName"];
        Context.TryGetValue("My", out var type);
        type = type is string s && s.Equals("secret", StringComparison.CurrentCultureIgnoreCase) ? "Secret" : "Public";
        Context.TryGetValue("Info", out var info);
        Application.Context.TryGetValue($"{type}{info}", out var secret);
        Environment.Output.WriteLine(secret != null
                                         ? $"Ok {name}. Your {type} {info} is {secret}."
                                         : "I don't know.");
        return base.Execute(ct);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\ApplicationBaseTests.cs 
﻿using Microsoft.Extensions.DependencyInjection;

namespace DotNetToolbox.ConsoleApplication;

public class ApplicationBaseTests {
    [Fact]
    public void Create_WhenCreationFails_Throws() {
        // Arrange & Act
        var serviceProvider = CreateFakeServiceProvider();
        var app = TestApplication.Create(b => b.ConfigureLogging(l => l.SetMinimumLevel(LogLevel.Information)));

        // Assert
        app.Should().BeOfType<TestApplication>();
    }

    [Fact]
    public void Run_WithClearScreen_Runs() {
        // Arrange
        var option = new TestOutput();
        var app = TestApplication.Create([ "-cls" ], b => b.SetOutputHandler(option));

        // Act
        var action = () => app.Run();

        // Assert
        action.Should().NotThrow();
    }

    [Fact]
    public void Create_CreatesTestApplication_WithCustomAttributes() {
        // Arrange & Act
        var assemblyDescriptor = Substitute.For<IAssemblyDescriptor>();
        assemblyDescriptor.Name.Returns("TestApp");
        assemblyDescriptor.Version.Returns(new Version(1, 0));
        assemblyDescriptor.GetCustomAttribute<AssemblyTitleAttribute>().Returns(new AssemblyTitleAttribute("My App"));
        assemblyDescriptor.GetCustomAttribute<AssemblyDescriptionAttribute>().Returns(new AssemblyDescriptionAttribute("Some description."));
        var app = TestApplication.Create(b => b.SetAssemblyInformation(assemblyDescriptor));

        // Assert
        app.Should().BeOfType<TestApplication>();
        app.Name.Should().Be("My App");
        app.AssemblyName.Should().Be("TestApp");
        app.Version.Should().Be("1.0");
        app.Description.Should().Be("Some description.");
    }

    [Fact]
    public void Create_CreatesTestApplication_WithAssemblyInfo() {
        // Arrange & Act
        var assemblyDescriptor = Substitute.For<IAssemblyDescriptor>();
        assemblyDescriptor.Name.Returns("TestApp");
        assemblyDescriptor.Version.Returns(new Version(1, 0));
        var app = TestApplication.Create(b => b.SetAssemblyInformation(assemblyDescriptor));

        // Assert
        app.Should().BeOfType<TestApplication>();
        app.Name.Should().Be("TestApp");
        app.AssemblyName.Should().Be("TestApp");
        app.Version.Should().Be("1.0");
    }

    [Fact]
    public void Create_AddEnvironmentVariables_CreatesTestApplication() {
        // Act
        var app = TestApplication.Create(b => b.AddEnvironmentVariables("MYAPP_"));

        // Assert
        app.Should().BeOfType<TestApplication>();
    }

    [Fact]
    public void Create_AddUserSecrets_CreatesTestApplication() {
        // Act
        var app = TestApplication.Create(b => b.AddUserSecrets<TestApplication>());

        // Assert
        app.Should().BeOfType<TestApplication>();
    }

    [Fact]
    public void Create_WithConfig_CreatesTestApplication() {
        // Arrange & Act
        var wasCalled = false;
        var app = TestApplication.Create(_ => wasCalled = true);

        // Assert
        app.Should().BeOfType<TestApplication>();
        wasCalled.Should().BeTrue();
    }

    [Fact]
    public void Create_SetEnvironment_CreatesTestApplication() {
        // Arrange & Act
        var app = TestApplication.Create(b => b.SetEnvironment("Development"));

        // Assert
        app.Should().BeOfType<TestApplication>();
    }

    [Fact]
    public void Create_AddSettings_CreatesTestApplication() {
        // Arrange
        var fileProvider = new TestFileProvider();

        // Act
        var app = TestApplication.Create(b => b.AddAppSettings(fileProvider));

        // Assert
        app.Should().BeOfType<TestApplication>();
    }

    [Fact]
    public void Create_AddSettings_WithEnvironmentSet_CreatesTestApplication() {
        // Arrange
        var fileProvider = new TestFileProvider();

        // Act
        var app = TestApplication.Create(b => {
            b.SetEnvironment("Development");
            b.AddAppSettings(fileProvider);
        });

        // Assert
        app.Should().BeOfType<TestApplication>();
    }

    [Fact]
    public void Create_SetLogging_CreatesTestApplication() {
        // Arrange & Act
        var app = TestApplication.Create(b
                                   => b.ConfigureLogging(l => l.SetMinimumLevel(LogLevel.Debug)));

        // Assert
        app.Should().BeOfType<TestApplication>();
    }

    [Fact]
    public void ToString_ReturnsExpectedFormat() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider) {
            Description = "This is a test Application.",
        };

        var expectedToString = $"TestApplication: {app.Name} v{app.Version} => {app.Description}";

        // Act
        var actualToString = app.ToString();

        // Assert
        actualToString.Should().Be(expectedToString);
    }

    private class InvalidCommandDelegates : TheoryData<Delegate> {
        public InvalidCommandDelegates() {
            Add(() => 13);
            Add((Command _) => "Invalid");
            Add((string _) => { });
        }
    }
    [Theory]
    [ClassData(typeof(InvalidCommandDelegates))]
    public void AddCommand_WithInvalidDelegate_AddsCommand(Delegate action) {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        var result = () => app.AddCommand("command", action);

        // Assert
        result.Should().Throw<ArgumentException>();
    }

    [Fact]
    public void AddCommand_AndSubCommand_AddsCommand() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);
        var command = (Command)app.AddCommand("command", (Action)(() => throw new()));

        // Act
        var subCommand = command.AddCommand("sub-command", (Action)(() => throw new()));

        // Assert
        subCommand.Path.Should().Be("TestApp command sub-command");
    }

    [Fact]
    public async Task AddCommand_WithException_AddsCommandThatThrows() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);
        var command = (Command)app.AddCommand("command", (Action)(() => throw new()));

        // Act
        var result = () => command.Execute();

        // Assert
        await result.Should().ThrowAsync<Exception>();
    }

    private class CommandDelegates : TheoryData<Delegate> {
        public CommandDelegates() {
            Add(null!);
            Add(() => { });
            Add((Command _) => { });
            Add(() => Result.Success());
            Add((Command _) => Result.Success());
            Add(() => Result.SuccessTask());
            Add((Command _) => Result.SuccessTask());
            Add(() => Task.CompletedTask);
            Add((Command _) => Task.CompletedTask);
            Add((CancellationToken _) => Result.SuccessTask());
            Add((Command _, CancellationToken _) => Result.SuccessTask());
            Add((CancellationToken _) => Task.CompletedTask);
            Add((Command _, CancellationToken _) => Task.CompletedTask);
        }
    }
    [Theory]
    [ClassData(typeof(CommandDelegates))]
    public async Task AddCommand_AddsCommand(Delegate action) {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        var subject = app.AddCommand("command", action);

        // Assert
        app.Children.Should().ContainSingle(x => x.Name == "command");
        var command = subject.Should().BeOfType<Command>().Subject;
        command.Aliases.Should().BeEmpty();
        var result = await command.Execute();
        result.Should().Be(Result.Success());
    }

    [Theory]
    [InlineData(null, "c")]
    [InlineData("", "c")]
    [InlineData("c", "c")]
    [InlineData("2cmd", "c")]
    [InlineData("-c$h", "c")]
    [InlineData("c$h", "c")]
    [InlineData("c-h$", "c")]
    [InlineData("cmd", null)]
    [InlineData("cmd", "")]
    [InlineData("cmd", "=")]
    [InlineData("cmd", "-")]
    [InlineData("cmd", "2-")]
    public void AddCommand_WithInvalidNameOrAlias_Throws(string? name, string? alias) {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        var action = () => app.AddCommand(name!, [ alias! ], () => { });

        // Assert
        action.Should().Throw<InvalidOperationException>();
    }

    [Theory]
    [ClassData(typeof(CommandDelegates))]
    public void AddCommand_WithAlias_AddsCommand(Delegate action) {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        app.AddCommand("command", "c", action);

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "command").Subject;
        child.Aliases.Should().BeEquivalentTo("c");
    }

    [Fact]
    public async Task AddCommand_OfType_AddsCommandOfType() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        app.AddCommand<TestCommand>();

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "Command").Subject;
        var command = child.Should().BeOfType<TestCommand>().Subject;
        command.Aliases.Should().BeEquivalentTo("c");
        var text = command.ToString();
        text.Should().Be("TestCommand: Command, c => Test command.");
        var result = () => command.Execute();
        await result.Should().NotThrowAsync();
    }

    [Fact]
    public void AddCommand_WithCommand_AddsCommand() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);
        var node = new TestCommand(app);

        // Act
        app.AddCommand(node);

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "Command").Subject;
        child.Should().BeOfType<TestCommand>();
    }

    [Fact]
    public void AddOption_AddsOption() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        app.AddOption("option");

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "option").Subject;
        var option = child.Should().BeOfType<Option>().Subject;
        option.Aliases.Should().BeEmpty();
    }

    [Fact]
    public void AddOption_WithAlias_AddsOption() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        app.AddOption("option", "o");

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "option").Subject;
        var option = child.Should().BeOfType<Option>().Subject;
        option.Aliases.Should().BeEquivalentTo("o");
    }

    [Fact]
    public void AddOption_OfType_AddsOptionOfType() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        app.AddOption<TestOption>();

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "Option").Subject;
        var option = child.Should().BeOfType<TestOption>().Subject;
        option.Aliases.Should().BeEquivalentTo("o");
    }

    [Fact]
    public void AddOption_WithOption_AddsOption() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);
        var node = new TestOption(app);

        // Act
        app.AddOption(node);

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "Option").Subject;
        child.Should().BeOfType<TestOption>();
    }

    [Fact]
    public void AddParameter_AddsParameter() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);
        var parameterName = "param1";

        // Act
        app.AddParameter(parameterName);

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == parameterName).Subject;
        var parameter = child.Should().BeOfType<Parameter>().Subject;
        parameter.Order.Should().Be(0);
        parameter.IsRequired.Should().BeTrue();
        parameter.IsSet.Should().BeFalse();
    }

    [Fact]
    public void AddParameter_WithDefaultValue_AddsParameter() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);
        var parameterName = "param1";
        var defaultValue = "defaultValue";

        // Act
        app.AddParameter(parameterName, defaultValue);

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == parameterName).Subject;
        var parameter = child.Should().BeOfType<Parameter>().Subject;
        parameter.Order.Should().Be(0);
        parameter.IsRequired.Should().BeFalse();
        parameter.IsSet.Should().BeFalse();
    }

    [Fact]
    public void AddParameter_OfType_AddsParameterOfType() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        app.AddParameter<TestParameter>();

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "Age").Subject;
        var parameter = child.Should().BeOfType<TestParameter>().Subject;
        parameter.Aliases.Should().BeEmpty();
        parameter.Order.Should().Be(0);
    }

    [Fact]
    public void AddParameter_WithParameter_AddsParameter() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);
        var node = new TestParameter(app);

        // Act
        app.AddParameter(node);

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "Age").Subject;
        child.Should().BeOfType<TestParameter>();
    }

    private class InvalidFlagDelegates : TheoryData<Delegate> {
        public InvalidFlagDelegates() {
            Add(() => 13);
            Add((Flag _) => "Invalid");
            Add((string _) => { });
        }
    }
    [Theory]
    [ClassData(typeof(InvalidFlagDelegates))]
    public void AddFlag_WithInvalidDelegate_AddsFlag(Delegate action) {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        var result = () => app.AddFlag("flag", action);

        // Assert
        result.Should().Throw<ArgumentException>();
    }

    [Fact]
    public async Task AddFlag_WithException_AddsFlagThatThrows() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);
        var flag = app.AddFlag("flag", (Action)(() => throw new()));
        var context = new NodeContext();

        // Act
        var result = () => flag.Read(context);

        // Assert
        await result.Should().ThrowAsync<Exception>();
    }

    private class FlagDelegates : TheoryData<Delegate> {
        public FlagDelegates() {
            Add(null!);
            Add(() => { });
            Add((Flag _) => { });
            Add(() => Result.Success());
            Add((Flag _) => Result.Success());
            Add(() => Result.SuccessTask());
            Add((Flag _) => Result.SuccessTask());
            Add(() => Task.CompletedTask);
            Add((Flag _) => Task.CompletedTask);
            Add((CancellationToken _) => Result.SuccessTask());
            Add((Flag _, CancellationToken _) => Result.SuccessTask());
            Add((CancellationToken _) => Task.CompletedTask);
            Add((Flag _, CancellationToken _) => Task.CompletedTask);
        }
    }
    [Theory]
    [ClassData(typeof(FlagDelegates))]
    public async Task AddFlag_AddsFlag(Delegate action) {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);
        var context = new NodeContext();

        // Act
        var subject = app.AddFlag("flag", action);

        // Assert
        app.Children.Should().ContainSingle(x => x.Name == "flag");
        var flag = subject.Should().BeOfType<Flag>().Subject;
        flag.Aliases.Should().BeEmpty();
        var result = await subject.Read(context);
        result.Should().Be(Result.Success());
    }

    [Theory]
    [ClassData(typeof(FlagDelegates))]
    public void AddFlag_WithAlias_AddsFlag(Delegate action) {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        app.AddFlag("flag", "c", action);

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "flag").Subject;
        child.Aliases.Should().BeEquivalentTo("c");
    }

    [Fact]
    public void AddFlag_OfType_AddsFlagOfType() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);

        // Act
        app.AddFlag<TestFlag>();

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "Flag").Subject;
        var flag = child.Should().BeOfType<TestFlag>().Subject;
        flag.Aliases.Should().BeEquivalentTo("f");
    }

    [Fact]
    public void AddFlag_WithFlag_AddsFlag() {
        // Arrange
        var serviceProvider = CreateFakeServiceProvider();
        var app = new TestApplication([], serviceProvider);
        var node = new TestFlag(app);

        // Act
        app.AddFlag(node);

        // Assert
        var child = app.Children.Should().ContainSingle(x => x.Name == "Flag").Subject;
        child.Should().BeOfType<TestFlag>();
    }

    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestCommand
        : Command<TestCommand> {
        public TestCommand(IHasChildren app)
            : base(app, "Command", ["c"]) {
            Description = "Test command.";
        }

        public override Task<Result> Execute(CancellationToken ct = default) {
            Logger.LogInformation("Some logger.");
            return base.Execute(ct);
        }
    }

    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestOption(IHasChildren app) : Option<TestOption>(app, "Option", ["o"]);
    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestParameter(IHasChildren app) : Parameter<TestParameter>(app, "Age", "18");
    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestFlag(IHasChildren app) : Flag<TestFlag>(app, "Flag", ["f"]);

    private readonly IAssemblyDescriptor _assemblyDescriptor = Substitute.For<IAssemblyDescriptor>();
    private IServiceProvider CreateFakeServiceProvider() {
        var output = new TestOutput();
        var input = new TestInput(output);
        var environment = Substitute.For<IEnvironment>();
        var serviceProvider = Substitute.For<IKeyedServiceProvider>();
        serviceProvider.GetService(typeof(IConfiguration)).Returns(Substitute.For<IConfiguration>());
        serviceProvider.GetRequiredKeyedService(typeof(IAssemblyDescriptor), Arg.Any<string>()).Returns(_assemblyDescriptor);
        serviceProvider.GetRequiredKeyedService(typeof(IDateTimeProvider), Arg.Any<string>()).Returns(Substitute.For<IDateTimeProvider>());
        serviceProvider.GetRequiredKeyedService(typeof(IGuidProvider), Arg.Any<string>()).Returns(Substitute.For<IGuidProvider>());
        serviceProvider.GetRequiredKeyedService(typeof(IFileSystem), Arg.Any<string>()).Returns(Substitute.For<IFileSystem>());
        serviceProvider.GetRequiredKeyedService(typeof(IOutput), Arg.Any<string>()).Returns(output);
        serviceProvider.GetRequiredKeyedService(typeof(IInput), Arg.Any<string>()).Returns(input);
        serviceProvider.GetService(typeof(IEnvironment)).Returns(environment);
        _assemblyDescriptor.Name.Returns("TestApp");
        _assemblyDescriptor.Version.Returns(new Version(1, 0));
        serviceProvider.GetService(typeof(ILoggerFactory)).Returns(Substitute.For<ILoggerFactory>());
        return serviceProvider;
    }

    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestApplication(string[] args, IServiceProvider serviceProvider)
        : ApplicationBase<TestApplication, TestApplicationBuilder>(args, serviceProvider) {
        internal override Task Run(CancellationToken ct = default)
            => OnStart(ct);

        protected virtual Task<Result> OnStart(CancellationToken ct = default) => Result.SuccessTask();
    }

    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestApplicationBuilder(string[] args)
        : ApplicationBuilder<TestApplication, TestApplicationBuilder>(args);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\GlobalUsings.cs 
global using System.Reflection;
global using System.Text;

global using DotNetToolbox.ConsoleApplication.Application;
global using DotNetToolbox.ConsoleApplication.Exceptions;
global using DotNetToolbox.ConsoleApplication.Nodes;
global using DotNetToolbox.ConsoleApplication.TestDoubles;
global using DotNetToolbox.Results;

global using FluentAssertions;

global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.FileProviders;
global using Microsoft.Extensions.Logging;
global using Microsoft.Extensions.Primitives;

global using NSubstitute;

global using Xunit;

global using Syntax = System.Diagnostics.CodeAnalysis.StringSyntaxAttribute;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\NodeTests.cs 
﻿namespace DotNetToolbox.ConsoleApplication;

public class NodeTests {
    [Fact]
    public void Constructor_CreatesNode() {
        // Arrange & Act
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);

        // Act
        var node = new TestNode(app, "node", ["n"]) {
            Description = "Some description.",
        };

        // Assert
        node.Name.Should().Be("node");
        node.Description.Should().Be("Some description.");
        node.Aliases.Should().BeEquivalentTo("n");
        node.Parent.Should().Be(app);
        node.Application.Should().Be(app);
        node.Children.Should().BeEmpty();
    }

    [Fact]
    public void ToString_ReturnsExpectedFormat() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]) {
            Description = "Some description.",
        };
        var expectedToString = $"TestNode: {node.Name}, {node.Aliases[0]} => {node.Description}";

        // Act
        var actualToString = node.ToString();

        // Assert
        actualToString.Should().Be(expectedToString);
    }

    private class InvalidCommandDelegates : TheoryData<Delegate> {
        public InvalidCommandDelegates() {
            Add(() => 13);
            Add((Command _) => "Invalid");
            Add((string _) => { });
        }
    }
    [Theory]
    [ClassData(typeof(InvalidCommandDelegates))]
    public void AddCommand_WithInvalidDelegate_AddsCommand(Delegate action) {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);

        // Act
        var result = () => node.AddCommand("command", action);

        // Assert
        result.Should().Throw<ArgumentException>();
    }

    [Fact]
    public async Task AddCommand_WithException_AddsCommandThatThrows() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);
        var command = (Command)node.AddCommand("command", (Action)(() => throw new()));

        // Act
        var result = () => command.Execute();

        // Assert
        await result.Should().ThrowAsync<Exception>();
    }

    private class CommandDelegates : TheoryData<Delegate> {
        public CommandDelegates() {
            Add(null!);
            Add(() => { });
            Add((Command _) => { });
            Add(() => Result.Success());
            Add((Command _) => Result.Success());
            Add(() => Result.SuccessTask());
            Add((Command _) => Result.SuccessTask());
            Add(() => Task.CompletedTask);
            Add((Command _) => Task.CompletedTask);
            Add((CancellationToken _) => Result.SuccessTask());
            Add((Command _, CancellationToken _) => Result.SuccessTask());
            Add((CancellationToken _) => Task.CompletedTask);
            Add((Command _, CancellationToken _) => Task.CompletedTask);
        }
    }
    [Theory]
    [ClassData(typeof(CommandDelegates))]
    public async Task AddCommand_AddsCommand(Delegate action) {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);

        // Act
        var subject = node.AddCommand("command", action);

        // Assert
        node.Children.Should().ContainSingle(x => x.Name == "command");
        var command = subject.Should().BeOfType<Command>().Subject;
        command.Aliases.Should().BeEmpty();
        var result = await command.Execute();
        result.Should().Be(Result.Success());
    }

    [Theory]
    [ClassData(typeof(CommandDelegates))]
    public void AddCommand_WithAlias_AddsCommand(Delegate action) {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);

        // Act
        node.AddCommand("command", "c", action);

        // Assert
        var child = node.Children.Should().ContainSingle(x => x.Name == "command").Subject;
        child.Aliases.Should().BeEquivalentTo("c");
    }

    [Fact]
    public async Task AddCommand_OfType_AddsCommandOfType() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);

        // Act
        node.AddCommand<TestCommand>();

        // Assert
        var child = node.Children.Should().ContainSingle(x => x.Name == "Command").Subject;
        var command = child.Should().BeOfType<TestCommand>().Subject;
        command.Aliases.Should().BeEquivalentTo("c");
        var text = command.ToString();
        text.Should().Be("TestCommand: Command, c => Test command.");
        var result = () => command.Execute();
        await result.Should().NotThrowAsync();
    }

    [Fact]
    public void AddCommand_WithCommand_AddsCommand() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var parent = new TestNode(app, "node");
        var node = new TestCommand(parent);

        // Act
        parent.AddCommand(node);

        // Assert
        var child = parent.Children.Should().ContainSingle(x => x.Name == "Command").Subject;
        child.Should().BeOfType<TestCommand>();
    }

    [Fact]
    public void AddCommand_ManyTimes_AddsMultipleCommand() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var parent = new TestNode(app, "node");

        // Act
        parent.AddCommand("Node1", () => { });
        parent.AddCommand("Node2", () => { });

        // Assert
        parent.Commands.Should().HaveCount(2);
    }

    [Fact]
    public void AddOption_AddsOption() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);

        // Act
        node.AddOption("option");

        // Assert
        var child = node.Children.Should().ContainSingle(x => x.Name == "option").Subject;
        var option = child.Should().BeOfType<Option>().Subject;
        option.Aliases.Should().BeEmpty();
    }

    [Fact]
    public void AddOption_WithAlias_AddsOption() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);

        // Act
        node.AddOption("option", "o");

        // Assert
        var child = node.Children.Should().ContainSingle(x => x.Name == "option").Subject;
        var option = child.Should().BeOfType<Option>().Subject;
        option.Aliases.Should().BeEquivalentTo("o");
    }

    [Fact]
    public void AddOption_OfType_AddsOptionOfType() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);

        // Act
        node.AddOption<TestOption>();

        // Assert
        var child = node.Children.Should().ContainSingle(x => x.Name == "Option").Subject;
        var option = child.Should().BeOfType<TestOption>().Subject;
        option.Aliases.Should().BeEquivalentTo("o");
    }

    [Fact]
    public void AddOption_WithOption_AddsOption() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var parent = new TestNode(app, "node");
        var node = new TestOption(parent);

        // Act
        parent.AddOption(node);

        // Assert
        var child = parent.Children.Should().ContainSingle(x => x.Name == "Option").Subject;
        child.Should().BeOfType<TestOption>();
    }

    [Fact]
    public void AddParameter_AddsParameter() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);
        var parameterName = "param1";

        // Act
        node.AddParameter(parameterName);

        // Assert
        var child = node.Children.Should().ContainSingle(x => x.Name == parameterName).Subject;
        var parameter = child.Should().BeOfType<Parameter>().Subject;
        parameter.Order.Should().Be(0);
        parameter.IsRequired.Should().BeTrue();
        parameter.IsSet.Should().BeFalse();
    }

    [Fact]
    public void AddParameter_WithDefaultValue_AddsParameter() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);
        var parameterName = "param1";
        var defaultValue = "defaultValue";

        // Act
        node.AddParameter(parameterName, defaultValue);

        // Assert
        var child = node.Children.Should().ContainSingle(x => x.Name == parameterName).Subject;
        var parameter = child.Should().BeOfType<Parameter>().Subject;
        parameter.Order.Should().Be(0);
        parameter.IsRequired.Should().BeFalse();
        parameter.IsSet.Should().BeFalse();
    }

    [Fact]
    public void AddParameter_OfType_AddsParameterOfType() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);

        // Act
        node.AddParameter<TestParameter>();

        // Assert
        var child = node.Children.Should().ContainSingle(x => x.Name == "Age").Subject;
        var parameter = child.Should().BeOfType<TestParameter>().Subject;
        parameter.Aliases.Should().BeEmpty();
        parameter.Order.Should().Be(0);
    }

    [Fact]
    public void AddParameter_WithParameter_AddsParameter() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var parent = new TestNode(app, "node");
        var node = new TestParameter(parent);

        // Act
        parent.AddParameter(node);

        // Assert
        var child = parent.Children.Should().ContainSingle(x => x.Name == "Age").Subject;
        child.Should().BeOfType<TestParameter>();
    }

    private class InvalidFlagDelegates : TheoryData<Delegate> {
        public InvalidFlagDelegates() {
            Add(() => 13);
            Add((Flag _) => "Invalid");
            Add((string _) => { });
        }
    }
    [Theory]
    [ClassData(typeof(InvalidFlagDelegates))]
    public void AddFlag_WithInvalidDelegate_AddsFlag(Delegate action) {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);

        // Act
        var result = () => node.AddFlag("flag", action);

        // Assert
        result.Should().Throw<ArgumentException>();
    }

    [Fact]
    public async Task AddFlag_WithException_AddsFlagThatThrows() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);
        var flag = node.AddFlag("flag", (Action)(() => throw new()));
        var context = new NodeContext();

        // Act
        var result = () => flag.Read(context);

        // Assert
        await result.Should().ThrowAsync<Exception>();
    }

    private class FlagDelegates : TheoryData<Delegate> {
        public FlagDelegates() {
            Add(null!);
            Add(() => { });
            Add((Flag _) => { });
            Add(() => Result.Success());
            Add((Flag _) => Result.Success());
            Add(() => Result.SuccessTask());
            Add((Flag _) => Result.SuccessTask());
            Add(() => Task.CompletedTask);
            Add((Flag _) => Task.CompletedTask);
            Add((CancellationToken _) => Result.SuccessTask());
            Add((Flag _, CancellationToken _) => Result.SuccessTask());
            Add((CancellationToken _) => Task.CompletedTask);
            Add((Flag _, CancellationToken _) => Task.CompletedTask);
        }
    }
    [Theory]
    [ClassData(typeof(FlagDelegates))]
    public async Task AddFlag_AddsFlag(Delegate action) {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);
        var context = new NodeContext();

        // Act
        var subject = node.AddFlag("flag", action);

        // Assert
        node.Children.Should().ContainSingle(x => x.Name == "flag");
        var flag = subject.Should().BeOfType<Flag>().Subject;
        flag.Aliases.Should().BeEmpty();
        var result = await subject.Read(context);
        result.Should().Be(Result.Success());
    }

    [Theory]
    [ClassData(typeof(FlagDelegates))]
    public void AddFlag_WithAlias_AddsFlag(Delegate action) {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);

        // Act
        node.AddFlag("flag", "c", action);

        // Assert
        var child = node.Children.Should().ContainSingle(x => x.Name == "flag").Subject;
        child.Aliases.Should().BeEquivalentTo("c");
    }

    [Fact]
    public void AddFlag_OfType_AddsFlagOfType() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var node = new TestNode(app, "node", ["n"]);

        // Act
        node.AddFlag<TestFlag>();

        // Assert
        var child = node.Children.Should().ContainSingle(x => x.Name == "Flag").Subject;
        var flag = child.Should().BeOfType<TestFlag>().Subject;
        flag.Aliases.Should().BeEquivalentTo("f");
    }

    [Fact]
    public void AddFlag_WithFlag_AddsFlag() {
        // Arrange
        var app = Substitute.For<IApplication>();
        var serviceProvider = CreateFakeServiceProvider();
        app.Services.Returns(serviceProvider);
        var parent = new TestNode(app, "node");
        var node = new TestFlag(parent);

        // Act
        parent.AddFlag(node);

        // Assert
        var child = parent.Children.Should().ContainSingle(x => x.Name == "Flag").Subject;
        child.Should().BeOfType<TestFlag>();
    }

    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestCommand
        : Command<TestCommand> {
        public TestCommand(IHasChildren app)
            : base(app, "Command", ["c"]) {
            Description = "Test command.";
        }

        public override Task<Result> Execute(CancellationToken ct = default) {
            Logger.LogInformation("Some logger.");
            return base.Execute(ct);
        }
    }

    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestOption(IHasChildren app) : Option<TestOption>(app, "Option", ["o"]);
    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestParameter(IHasChildren app) : Parameter<TestParameter>(app, "Age", "18");
    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestFlag(IHasChildren app) : Flag<TestFlag>(app, "Flag", ["f"]);

    private readonly IAssemblyDescriptor _assemblyDescriptor = Substitute.For<IAssemblyDescriptor>();
    private readonly IAssemblyAccessor _assemblyAccessor = Substitute.For<IAssemblyAccessor>();
    private IServiceProvider CreateFakeServiceProvider() {
        var output = new TestOutput();
        var input = new TestInput(output);
        var serviceProvider = Substitute.For<IServiceProvider>();
        serviceProvider.GetService(typeof(IConfiguration)).Returns(Substitute.For<IConfiguration>());
        serviceProvider.GetService(typeof(IOutput)).Returns(output);
        serviceProvider.GetService(typeof(IInput)).Returns(input);
        _assemblyAccessor.GetEntryAssembly().Returns(_assemblyDescriptor);
        _assemblyDescriptor.Name.Returns("TestApp");
        _assemblyDescriptor.Version.Returns(new Version(1, 0));
        serviceProvider.GetService(typeof(IAssemblyAccessor)).Returns(_assemblyAccessor);
        serviceProvider.GetService(typeof(IDateTimeProvider)).Returns(Substitute.For<IDateTimeProvider>());
        serviceProvider.GetService(typeof(IGuidProvider)).Returns(Substitute.For<IGuidProvider>());
        serviceProvider.GetService(typeof(IFileSystem)).Returns(Substitute.For<IFileSystem>());
        serviceProvider.GetService(typeof(ILoggerFactory)).Returns(Substitute.For<ILoggerFactory>());
        return serviceProvider;
    }

    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestNode(IHasChildren parent, string name, params string[] aliases)
        : Command<TestNode>(parent, name, aliases);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\RunOnceApplicationTests.cs 
﻿namespace DotNetToolbox.ConsoleApplication;

public class RunOnceApplicationTests {
    [Fact]
    public void Create_CreatesCliApplication() {
        // Arrange & Act
        var app = RunOnceApplication.Create();

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
        app.Name.Should().Be("testhost");
        app.Environment.Name.Should().Be("");
        app.AssemblyName.Should().Be("testhost");
        app.Children.Should().HaveCount(3);
        app.Context.Should().BeEmpty();
        app.Logger.Should().NotBeNull();
    }

    [Fact]
    public void Create_AddEnvironmentVariables_CreatesRunOnceApplication() {
        // Act
        var app = RunOnceApplication.Create(b => b.AddEnvironmentVariables("MYAPP_"));

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
    }

    [Fact]
    public void Create_WithVersionFlag_CreatesRunOnceApplication() {
        // Arrange
        var output = new TestOutput();
        var app = RunOnceApplication.Create(["--version"], b => b.SetOutputHandler(output));

        // Act
        var action = () => app.Run();

        // Assert
        action.Should().NotThrow();
    }

    [Fact]
    public void Create_AddUserSecrets_CreatesRunOnceApplication() {
        // Act
        var app = RunOnceApplication.Create(b => b.AddUserSecrets<RunOnceApplication>());

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
    }

    [Fact]
    public void Create_WithArgs_CreatesRunOnceApplication() {
        // Arrange
        string[] args = ["arg1", "arg2"];

        // Act
        var app = RunOnceApplication.Create(args);

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
    }

    [Fact]
    public void Create_WithConfig_CreatesRunOnceApplication() {
        // Arrange & Act
        var wasCalled = false;
        var app = RunOnceApplication.Create(_ => wasCalled = true);

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
        wasCalled.Should().BeTrue();
    }

    [Fact]
    public void Create_WithArgsAndConfig_CreatesRunOnceApplication() {
        // Arrange
        var wasCalled = false;
        string[] args = ["arg1", "arg2"];

        // Act
        var app = RunOnceApplication.Create(args, _ => wasCalled = true);

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
        wasCalled.Should().BeTrue();
    }

    [Fact]
    public void Create_SetEnvironment_CreatesRunOnceApplication() {
        // Arrange & Act
        var app = RunOnceApplication.Create(b => b.SetEnvironment("Development"));

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
    }

    [Fact]
    public void Create_AddSettings_CreatesRunOnceApplication() {
        // Arrange
        var fileProvider = new TestFileProvider();

        // Act
        var app = RunOnceApplication.Create(b => b.AddAppSettings(fileProvider));

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
    }

    [Fact]
    public void Create_AddSettings_WithEnvironmentSet_CreatesRunOnceApplication() {
        // Arrange
        var fileProvider = new TestFileProvider();

        // Act
        var app = RunOnceApplication.Create(b => {
            b.SetEnvironment("Development");
            b.AddAppSettings(fileProvider);
        });

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
    }

    [Fact]
    public void ReplaceInput_ExecutesUntilExit() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output);

        // Act
        var app = RunOnceApplication.Create(b => b.SetInputHandler(input));

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
    }

    [Fact]
    public void Run_WithNoArgs_DisplayHelp() {
        // Arrange
        var output = new TestOutput();
        const string expectedOutput =
            """
            testhost v15.0.0.0

            Usage:
                testhost [Options]

            Options:
                --clear-screen, -cls      Clear the screen.
                --help, -h, -?            Display this help information.
                --version                 Display the application's version.


            """;
        var app = RunOnceApplication.Create(b => b.SetOutputHandler(output));

        // Act
        app.Run();

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
        output.ToString().Should().BeEquivalentTo(expectedOutput);
    }

    [Fact]
    public void Run_WithCommandAndNoArgs_DisplayHelp() {
        // Arrange
        var output = new TestOutput();
        const string expectedOutput =
            """
            testhost v15.0.0.0

            Usage:
                testhost [Options] [Commands]

            Options:
                --clear-screen, -cls      Clear the screen.
                --help, -h, -?            Display this help information.
                --version                 Display the application's version.

            Commands:
                magic
                say-it


            """;
        var app = RunOnceApplication.Create(b => b.SetOutputHandler(output));
        app.AddCommand("say-it", (Command c) => c.Environment.Output.WriteLine("Hello world!"));
        app.AddCommand("magic", (Command c) => c.Environment.Output.WriteLine("Please..."));

        // Act
        app.Run();

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
        output.ToString().Should().BeEquivalentTo(expectedOutput);
    }

    [Fact]
    public void Run_WithParameterAndNoArgs_DisplayHelp() {
        // Arrange
        var output = new TestOutput();
        const string expectedOutput =
            """
            testhost v15.0.0.0

            Usage:
                testhost [Options] [<Project>]

            Options:
                --clear-screen, -cls      Clear the screen.
                --help, -h, -?            Display this help information.
                --version                 Display the application's version.

            Parameters:
                Project


            """;
        var app = RunOnceApplication.Create(b => b.SetOutputHandler(output));
        app.AddParameter("Project", "");

        // Act
        app.Run();

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
        output.ToString().Should().BeEquivalentTo(expectedOutput);
    }

    [Fact]
    public void Run_WithCommand_ExecutesCommand() {
        // Arrange
        var output = new TestOutput();
        const string expectedOutput =
            """
            Hello world!

            """;
        var app = RunOnceApplication.Create([ "say-it" ], b => b.SetOutputHandler(output));
        app.AddCommand("say-it", (Command c) => c.Environment.Output.WriteLine("Hello world!"));

        // Act
        app.Run();

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
        output.ToString().Should().BeEquivalentTo(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithSetOptionsAndProvidersReplaced_ExecutesUntilExit() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output);
        var fileSystem = new TestFileSystem();
        var guidProvider = new TestGuidProvider();
        var dateTimeProvider = new TestDateTimeProvider();
        const string expectedOutput =
            """
            testhost v15.0.0.0

            Usage:
                testhost [Options]

            Options:
                --clear-screen, -cls      Clear the screen.
                --help, -h, -?            Display this help information.
                --version                 Display the application's version.


            """;
        await using var app = RunOnceApplication.Create(b => {
            b.SetDateTimeProvider(dateTimeProvider);
            b.SetGuidProvider(guidProvider);
            b.SetFileSystem(fileSystem);
            b.SetOutputHandler(output);
            b.SetInputHandler(input);
        });

        // Act
        await app.RunAsync();

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithHelpOption_DisplaysHelp() {
        // Arrange
        var output = new TestOutput();
        const string expectedOutput =
            """
            testhost v15.0.0.0

            Usage:
                testhost [Options]

            Options:
                --clear-screen, -cls      Clear the screen.
                --help, -h, -?            Display this help information.
                --version                 Display the application's version.


            """;
        await using var app = RunOnceApplication.Create(["--help"], b => b.SetOutputHandler(output));

        // Act
        await app.RunAsync();

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithErrorDuringArgumentRead_ReturnsResultWithErrors() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output);
        const string expectedOutput =
            """
            Validation error: Unknown argument '--invalid'. For a list of available arguments use '--help'.


            """;
        var app = RunOnceApplication.Create(["--invalid"], b => {
            b.SetInputHandler(input);
            b.SetOutputHandler(output);
        });

        // Act
        var actualResult = await app.RunAsync();

        // Assert
        actualResult.Should().Be(IApplication.DefaultErrorCode);
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public void Create_SetLogging_CreatesRunOnceApplication() {
        // Arrange & Act
        var app = RunOnceApplication.Create(b => b.ConfigureLogging(l => l.SetMinimumLevel(LogLevel.Debug)));

        // Assert
        app.Should().BeOfType<RunOnceApplication>();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\ShellApplicationTests.cs 
﻿using Shell = DotNetToolbox.ConsoleApplication.ShellApplication;

namespace DotNetToolbox.ConsoleApplication;

public class ShellApplicationTests {
    [Fact]
    public void Create_CreatesShellApplication() {
        // Arrange & Act
        var app = Shell.Create();

        // Assert
        app.Should().BeOfType<Shell>();
        app.Name.Should().Be("testhost");
        app.Version.Should().Be("15.0.0.0");
        app.Environment.Name.Should().Be("");
        app.AssemblyName.Should().Be("testhost");
        app.Children.Should().HaveCount(6);
        app.Context.Should().BeEmpty();
        app.Logger.Should().NotBeNull();
    }

    [Fact]
    public void ReplaceInput_ExecutesUntilExit() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output);

        // Act
        var app = Shell.Create(b => b.SetInputHandler(input));

        // Assert
        app.Should().BeOfType<Shell>();
    }

    [Fact]
    public void Run_ExecutesUntilExit() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "", "--exit", "\"exit\"", "exit");
        const string expectedOutput =
            """
            testhost v15.0.0.0
            > 
            > --exit
            > "exit"
            > exit

            """;
        var fileSystem = new TestFileSystem();
        var guidProvider = new TestGuidProvider();
        var dateTimeProvider = new TestDateTimeProvider();
        var app = Shell.Create(b => {
            b.SetDateTimeProvider(dateTimeProvider);
            b.SetGuidProvider(guidProvider);
            b.SetFileSystem(fileSystem);
            b.SetOutputHandler(output);
            b.SetInputHandler(input);
        });

        // Act
        app.Run();

        // Assert
        app.Should().BeOfType<Shell>();
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithSetOptionsAndProvidersReplaced_ExecutesUntilExit() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "exit");
        const string expectedOutput =
            """
            testhost v15.0.0.0
            > exit

            """;
        var fileSystem = new TestFileSystem();
        var guidProvider = new TestGuidProvider();
        var dateTimeProvider = new TestDateTimeProvider();
        await using var app = Shell.Create(b => {
            b.SetDateTimeProvider(dateTimeProvider);
            b.SetGuidProvider(guidProvider);
            b.SetFileSystem(fileSystem);
            b.SetOutputHandler(output);
            b.SetInputHandler(input);
        });

        // Act
        await app.RunAsync();

        // Assert
        app.Should().BeOfType<Shell>();
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithHelp_ExecutesUntilExit() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "help", "exit");
        var assemblyDescriptor = Substitute.For<IAssemblyDescriptor>();
        assemblyDescriptor.Name.Returns("tsa");
        assemblyDescriptor.Version.Returns(new Version(1, 0));
        assemblyDescriptor.GetCustomAttribute<AssemblyTitleAttribute>().Returns(new AssemblyTitleAttribute("Test Shell Application"));
        assemblyDescriptor.GetCustomAttribute<AssemblyDescriptionAttribute>().Returns(new AssemblyDescriptionAttribute("This is a test application."));
        const string expectedOutput =
            """
            Test Shell Application v1.0
            > help
            Test Shell Application v1.0
            This is a test application.

            Usage:
                tsa [Options] [Commands]
                tsa [Options] [<Timeout>]

            Options:
                --clear-screen, -cls      Clear the screen.
                --help, -h, -?            Display this help information.
                --version                 Display the application's version.

            Parameters:
                Timeout

            Commands:
                ClearScreen, cls          Clear the screen.
                Exit                      Exit the application.
                Help, ?                   Display this help information.

            > exit

            """;
        await using var app = Shell.Create(b => {
            b.SetAssemblyInformation(assemblyDescriptor);
            b.SetOutputHandler(output);
            b.SetInputHandler(input);
        });
        app.AddParameter("Timeout", "5000");

        // Act
        await app.RunAsync();

        // Assert
        app.Should().BeOfType<Shell>();
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithHelpAlias_ExecutesUntilExit() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "?", "exit");
        var assemblyDescriptor = Substitute.For<IAssemblyDescriptor>();
        assemblyDescriptor.Name.Returns("tsa");
        assemblyDescriptor.Version.Returns(new Version(1, 0));
        assemblyDescriptor.GetCustomAttribute<AssemblyTitleAttribute>().Returns(new AssemblyTitleAttribute("Test Shell Application"));
        assemblyDescriptor.GetCustomAttribute<AssemblyDescriptionAttribute>().Returns(new AssemblyDescriptionAttribute("This is a test application."));
        const string expectedOutput =
            """
            Test Shell Application v1.0
            > ?
            Test Shell Application v1.0
            This is a test application.

            Usage:
                tsa [Options] [Commands]
                tsa [Options] [<Timeout>]

            Options:
                --clear-screen, -cls      Clear the screen.
                --help, -h, -?            Display this help information.
                --version                 Display the application's version.

            Parameters:
                Timeout

            Commands:
                ClearScreen, cls          Clear the screen.
                Exit                      Exit the application.
                Help, ?                   Display this help information.

            > exit

            """;
        await using var app = Shell.Create(b => {
            b.SetAssemblyInformation(assemblyDescriptor);
            b.SetOutputHandler(output);
            b.SetInputHandler(input);
        });
        app.AddParameter("Timeout", "5000");

        // Act
        await app.RunAsync();

        // Assert
        app.Should().BeOfType<Shell>();
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithHelpCommand_ExecutesUntilExit() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "help exit", "exit");
        var assemblyDescriptor = Substitute.For<IAssemblyDescriptor>();
        assemblyDescriptor.Name.Returns("tsa");
        assemblyDescriptor.Version.Returns(new Version(1, 0));
        assemblyDescriptor.GetCustomAttribute<AssemblyTitleAttribute>().Returns(new AssemblyTitleAttribute("Test Shell Application"));
        assemblyDescriptor.GetCustomAttribute<AssemblyDescriptionAttribute>().Returns(new AssemblyDescriptionAttribute("This is a test application."));
        const string expectedOutput =
            """
            Test Shell Application v1.0
            > help exit
            Exit the application.

            Usage:
                Exit

            > exit

            """;
        await using var app = Shell.Create(b => {
            b.SetAssemblyInformation(assemblyDescriptor);
            b.SetOutputHandler(output);
            b.SetInputHandler(input);
        });
        app.AddParameter("Timeout", "5000");

        // Act
        await app.RunAsync();

        // Assert
        app.Should().BeOfType<Shell>();
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithHelpOption_ShowsHelpAndExits() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output);
        var assemblyDescriptor = Substitute.For<IAssemblyDescriptor>();
        assemblyDescriptor.Name.Returns("tsa");
        assemblyDescriptor.Version.Returns(new Version(1, 0));
        assemblyDescriptor.GetCustomAttribute<AssemblyTitleAttribute>().Returns(new AssemblyTitleAttribute("Test Shell Application"));
        assemblyDescriptor.GetCustomAttribute<AssemblyDescriptionAttribute>().Returns(new AssemblyDescriptionAttribute("This is a test application."));
        const string expectedOutput =
            """
            Test Shell Application v1.0
            This is a test application.

            Usage:
                tsa [Options] [Commands]
                tsa [Options] [<Timeout>]

            Options:
                --clear-screen, -cls      Clear the screen.
                --help, -h, -?            Display this help information.
                --version                 Display the application's version.

            Parameters:
                Timeout

            Commands:
                ClearScreen, cls          Clear the screen.
                Exit                      Exit the application.
                Help, ?                   Display this help information.


            """;
        await using var app = Shell.Create(["--help"], b => {
            b.SetAssemblyInformation(assemblyDescriptor);
            b.SetOutputHandler(output);
            b.SetInputHandler(input);
        });
        app.AddParameter("Timeout", "5000");

        // Act
        await app.RunAsync();

        // Assert
        app.Should().BeOfType<Shell>();
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithHelpCommand_ShowsHelp() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "help ClearScreen", "exit");
        var assemblyDescriptor = Substitute.For<IAssemblyDescriptor>();
        assemblyDescriptor.Name.Returns("tsa");
        assemblyDescriptor.Version.Returns(new Version(1, 0));
        assemblyDescriptor.GetCustomAttribute<AssemblyTitleAttribute>().Returns(new AssemblyTitleAttribute("Test Shell Application"));
        assemblyDescriptor.GetCustomAttribute<AssemblyDescriptionAttribute>().Returns(new AssemblyDescriptionAttribute("This is a test application."));
        const string expectedOutput =
            """
            Test Shell Application v1.0
            > help ClearScreen
            Clear the screen.

            Usage:
                ClearScreen

            Aliases: cls

            > exit

            """;
        var app = Shell.Create(b => {
            b.SetAssemblyInformation(assemblyDescriptor);
            b.SetOutputHandler(output);
            b.SetInputHandler(input);
        });
        // Act
        await app.RunAsync();

        // Assert
        app.Should().BeOfType<Shell>();
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithExceptionDuringExecution_ReturnsResultWithException() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "crash");

        static Result CommandAction() => throw new("Some error.");
        const string expectedOutput =
            """
            testhost v15.0.0.0
            > crash
            Exception: Some error.
                Stack Trace:
                       at DotNetToolbox.ConsoleApplication.ShellApplicationTests.*
                       at DotNetToolbox.ConsoleApplication.Utilities.NodeFactory*
                       at DotNetToolbox.ConsoleApplication.Nodes.Command`1*
                       at DotNetToolbox.ConsoleApplication.Nodes.Command`1*
                       at DotNetToolbox.ConsoleApplication.Application.Application`2.*
                       at DotNetToolbox.ConsoleApplication.ShellApplication`2.*
                       at DotNetToolbox.ConsoleApplication.ShellApplication`2.*
                       at DotNetToolbox.ConsoleApplication.Application.Application`2.*


            """;
        var app = Shell.Create(b => {
            b.SetInputHandler(input);
            b.SetOutputHandler(output);
        });
        app.AddCommand("Crash", CommandAction);

        // Act
        var actualResult = await app.RunAsync();

        // Assert
        actualResult.Should().Be(IApplication.DefaultErrorCode);
        output.ToString().Should().Match(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithConsoleExceptionDuringExecution_ReturnsResultWithException() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "crash");
        const int expectedErrorCode = 13;

        static Result CommandAction()
            => throw new ConsoleException(expectedErrorCode, "Some error.");
        const string expectedOutput =
            """
            testhost v15.0.0.0
            > crash
            ConsoleException: Some error.
                Stack Trace:
                       at DotNetToolbox.ConsoleApplication.ShellApplicationTests*
                       at DotNetToolbox.ConsoleApplication.Utilities.NodeFactory*
                       at DotNetToolbox.ConsoleApplication.Nodes.Command`1*
                       at DotNetToolbox.ConsoleApplication.Nodes.Command`1*
                       at DotNetToolbox.ConsoleApplication.Application.Application`2.ProcessCommand(String[] input, CancellationToken ct)*
                       at DotNetToolbox.ConsoleApplication.ShellApplication`2.ProcessInput(CancellationToken ct)*
                       at DotNetToolbox.ConsoleApplication.ShellApplication`2.Run(CancellationToken ct)*
                       at DotNetToolbox.ConsoleApplication.Application.Application`2.RunAsync()*


            """;
        var app = Shell.Create(b => {
            b.SetInputHandler(input);
            b.SetOutputHandler(output);
        });
        app.AddCommand("Crash", CommandAction);

        // Act
        var actualResult = await app.RunAsync();

        // Assert
        actualResult.Should().Be(expectedErrorCode);
        output.ToString().Should().Match(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithConsoleExceptionDuringExecution_AndInnerException_ReturnsResultWithException() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "crash");
        const int expectedErrorCode = 13;

        static Result CommandAction() {
            try {
                throw new InvalidOperationException("Some error.");
            }
            catch (Exception ex) {
                throw new ConsoleException(expectedErrorCode, "Some error.", ex);
            }
        }
        const string expectedOutput =
            """
            testhost v15.0.0.0
            > crash
            ConsoleException: Some error.
                Stack Trace:
                       at DotNetToolbox.ConsoleApplication.ShellApplicationTests*
                       at DotNetToolbox.ConsoleApplication.Utilities.NodeFactory*
                       at DotNetToolbox.ConsoleApplication.Nodes.Command`1*
                       at DotNetToolbox.ConsoleApplication.Nodes.Command`1*
                       at DotNetToolbox.ConsoleApplication.Application.Application`2*
                       at DotNetToolbox.ConsoleApplication.ShellApplication`2.ProcessInput(CancellationToken ct)*
                       at DotNetToolbox.ConsoleApplication.ShellApplication`2.Run(CancellationToken ct)*
                       at DotNetToolbox.ConsoleApplication.Application.Application`2.RunAsync()*
                Inner Exception => InvalidOperationException: Some error.
                    Stack Trace:
                           at DotNetToolbox.ConsoleApplication.ShellApplicationTests*


            """;
        var app = Shell.Create(b => {
            b.SetInputHandler(input);
            b.SetOutputHandler(output);
        });
        app.AddCommand("Crash", CommandAction);

        // Act
        var actualResult = await app.RunAsync();

        // Assert
        actualResult.Should().Be(expectedErrorCode);
        output.ToString().Should().Match(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithErrorDuringExecution_ReturnsResultWithErrors() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "crash", "exit");

        static Result CommandAction() => Result.Invalid("Some error.");
        const string expectedOutput =
            """
            testhost v15.0.0.0
            > crash
            Validation error: Some error.

            > exit

            """;
        var app = Shell.Create(b => {
            b.SetInputHandler(input);
            b.SetOutputHandler(output);
        });
        app.AddCommand("Crash", CommandAction);

        // Act
        var actualResult = await app.RunAsync();

        // Assert
        actualResult.Should().Be(IApplication.DefaultExitCode);
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_WithErrorDuringArgumentRead_ReturnsResultWithErrors() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "exit");
        const string expectedOutput =
            """
            Validation error: Unknown argument '--invalid'. For a list of available arguments use '--help'.


            """;
        var app = Shell.Create(["--invalid"], b => {
            b.SetInputHandler(input);
            b.SetOutputHandler(output);
        });

        // Act
        var actualResult = await app.RunAsync();

        // Assert
        actualResult.Should().Be(IApplication.DefaultErrorCode);
        output.ToString().Should().Be(expectedOutput);
    }

    [Fact]
    public async Task RunAsync_InvalidCommand_ReturnsResultWithErrors() {
        // Arrange
        var output = new TestOutput();
        var input = new TestInput(output, "invalid", "exit");
        const string expectedOutput =
            """
            testhost v15.0.0.0
            > invalid
            > exit

            """;
        var app = Shell.Create(b => {
            b.SetInputHandler(input);
            b.SetOutputHandler(output);
        });

        // Act
        var actualResult = await app.RunAsync();

        // Assert
        actualResult.Should().Be(IApplication.DefaultExitCode);
        output.ToString().Should().Be(expectedOutput);
    }

    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestShellApp(string[] args, IServiceProvider serviceProvider)
        : ShellApplication<TestShellApp>(args, serviceProvider) {
        protected override Task<Result> OnStart(CancellationToken ct) => Result.InvalidTask("Some error.");
    }

    [Fact]
    public async Task RunAsync_WithInvalidAction_ExecutesApp() {
        var output = new TestOutput();
        var input = new TestInput(output, "exit");
        var app = TestShellApp.Create(b => {
            b.SetInputHandler(input);
            b.SetOutputHandler(output);
        });

        // Act
        var actualResult = await app.RunAsync();

        // Assert
        actualResult.Should().Be(1);
    }

    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestFaultyShellApp(string[] args, IServiceProvider serviceProvider)
        : ShellApplication<TestFaultyShellApp>(args, serviceProvider) {
        protected override Task<Result> OnStart(CancellationToken ct = default) => Result.ErrorTask(new ConsoleException(13));
    }

    [Fact]
    public async Task RunAsync_WithFaultyAction_ExecutesApp() {
        var output = new TestOutput();
        var input = new TestInput(output, "exit");
        var app = TestFaultyShellApp.Create(b => {
            b.SetInputHandler(input);
            b.SetOutputHandler(output);
        });

        // Act
        var actualResult = await app.RunAsync();

        // Assert
        actualResult.Should().Be(13);
    }

    [Fact]
    public async Task RunAsync_WithArguments_ExecutesApp() {
        var output = new TestOutput();
        var input = new TestInput(output, "exit");
        var app = Shell.Create(["Option", "o", "20"], b => {
            b.SetInputHandler(input);
            b.SetOutputHandler(output);
        });
        app.AddOption<TestOption>();
        app.AddFlag<TestFlag>();
        app.AddParameter<TestParameter>();

        // Act
        var actualResult = await app.RunAsync();

        // Assert
        actualResult.Should().Be(0);
    }

    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestOption(IHasChildren app) : Option<TestOption>(app, "Option", ["o"]);
    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestParameter(IHasChildren app) : Parameter<TestParameter>(app, "Age", "18");
    // ReSharper disable once ClassNeverInstantiated.Local - Used for tests.
    private class TestFlag(IHasChildren app) : Flag<TestFlag>(app, "Flag", ["f"]);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\TestDoubles\TestChangeToken.cs 
﻿namespace DotNetToolbox.ConsoleApplication.TestDoubles;

public class TestChangeToken
    : IChangeToken {
    public IDisposable RegisterChangeCallback(Action<object?> callback, object? state)
        => new DisposableStateHolder(state);

    public bool HasChanged => false;
    public bool ActiveChangeCallbacks => false;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\TestDoubles\TestDateTimeProvider.cs 
﻿namespace DotNetToolbox.ConsoleApplication.TestDoubles;

internal class TestDateTimeProvider() : IDateTimeProvider {
    public DateTimeOffset FromFileTime(long fileTime) => throw new NotImplementedException();

    public DateTimeOffset FromUnixTimeMilliseconds(long ms) => throw new NotImplementedException();

    public DateTimeOffset FromUnixTimeSeconds(long s) => throw new NotImplementedException();

    public DateTimeOffset Parse(string s) => throw new NotImplementedException();

    public DateTimeOffset ParseExact(string s, string format) => throw new NotImplementedException();

    public bool TryParse(string s, out DateTimeOffset result) => throw new NotImplementedException();

    public bool TryParseExact(string s, string format, out DateTimeOffset result) => throw new NotImplementedException();

    public DateTimeOffset Maximum { get; }
    public DateTimeOffset Minimum { get; }
    public DateTimeOffset Now { get; }
    public TimeOnly TimeOfDay { get; }
    public DateOnly Today { get; }
    public DateTimeOffset UnixEpoch { get; }
    public DateTimeOffset UtcNow { get; }
    public TimeOnly UtcTimeOfDay { get; }
    public DateOnly UtcToday { get; }
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\TestDoubles\TestFileInfo.cs 
﻿namespace DotNetToolbox.ConsoleApplication.TestDoubles;

public class TestFileInfo
    : IFileInfo {
    private const string _contents = "{}";
    public Stream CreateReadStream() => new MemoryStream(Encoding.UTF8.GetBytes(_contents));
    public bool Exists => true;
    public long Length => 100;
    public string? PhysicalPath => null;
    public string Name => "settings.json";
    public DateTimeOffset LastModified => DateTimeOffset.Now.AddDays(-1);
    public bool IsDirectory => false;
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\TestDoubles\TestFileProvider.cs 
﻿namespace DotNetToolbox.ConsoleApplication.TestDoubles;

public class TestFileProvider
    : IFileProvider {
    public IFileInfo GetFileInfo(string subpath) => new TestFileInfo();
    public IDirectoryContents GetDirectoryContents(string subpath) => throw new NotImplementedException();
    public IChangeToken Watch(string filter) => new TestChangeToken();
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\TestDoubles\TestFileSystem.cs 
﻿namespace DotNetToolbox.ConsoleApplication.TestDoubles;

internal class TestFileSystem() : IFileSystem {
    public string CombinePath(params string[] paths) => throw new NotImplementedException();

    public void CopyFile(string sourcePath, string targetPath, bool overwrite = false) => throw new NotImplementedException();

    public void CreateFolder(string folderPath) => throw new NotImplementedException();

    public Stream CreateNewOrOverwriteFile(string filePath, bool blockExternalAccess = true) => throw new NotImplementedException();

    public void DeleteFile(string sourcePath) => throw new NotImplementedException();

    public void DeleteFolder(string folderPath, bool includeAllContent = false) => throw new NotImplementedException();

    public bool FileExists(string filePath) => throw new NotImplementedException();
    public string GetFileExtension(string filePath, bool includeDot = true) => throw new NotImplementedException();
    public string GetFileName(string filePath, bool includeExtension = false) => throw new NotImplementedException();
    public IEnumerable<string> GetEntries(string baseFolder) => throw new NotImplementedException();
    public IEnumerable<string> GetEntries(string baseFolder, string searchPattern) => throw new NotImplementedException();
    public IEnumerable<string> GetEntries(string baseFolder, EnumerationOptions enumerationOptions) => throw new NotImplementedException();
    public IEnumerable<string> GetEntries(string baseFolder, string searchPattern, EnumerationOptions enumerationOptions) => throw new NotImplementedException();
    public IEnumerable<string> GetFiles(string baseFolder) => throw new NotImplementedException();
    public IEnumerable<string> GetFiles(string baseFolder, string searchPattern) => throw new NotImplementedException();
    public IEnumerable<string> GetFiles(string baseFolder, EnumerationOptions enumerationOptions) => throw new NotImplementedException();
    public IEnumerable<string> GetFiles(string baseFolder, string searchPattern, EnumerationOptions enumerationOptions) => throw new NotImplementedException();
    public bool FolderExists(string folderPath) => throw new NotImplementedException();
    public string CurrentFolder {
        get => throw new NotImplementedException();
        set => throw new NotImplementedException();
    }

    public IEnumerable<string> GetFolders(string baseFolder) => throw new NotImplementedException();
    public IEnumerable<string> GetFolders(string baseFolder, string searchPattern) => throw new NotImplementedException();
    public IEnumerable<string> GetFolders(string baseFolder, EnumerationOptions enumerationOptions) => throw new NotImplementedException();
    public IEnumerable<string> GetFolders(string baseFolder, string searchPattern, EnumerationOptions enumerationOptions) => throw new NotImplementedException();
    public string[] GetFilePath(string filePath) => throw new NotImplementedException();
    public void MoveFile(string sourcePath, string targetPath, bool overwrite = false) => throw new NotImplementedException();
    public Stream OpenFileAsReadOnly(string filePath, bool blockExternalAccess = true) => throw new NotImplementedException();
    public Stream OpenOrCreateFile(string filePath, bool blockExternalAccess = true) => throw new NotImplementedException();
    public char DirectorySeparatorChar => throw new NotImplementedException();

    public char FolderSeparator => throw new NotImplementedException();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\TestDoubles\TestGuidProvider.cs 
﻿namespace DotNetToolbox.ConsoleApplication.TestDoubles;

internal class TestGuidProvider()
    : IGuidProvider {
    public Guid New() => throw new NotImplementedException();
    public Guid New(byte[] bytes) => throw new NotImplementedException();
    public Guid New(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k)
        => throw new NotImplementedException();
    public Guid New(int a, short b, short c, byte[] d) => throw new NotImplementedException();
    public Guid New(ReadOnlySpan<byte> bytes) => throw new NotImplementedException();
    public Guid New(ReadOnlySpan<byte> bytes, bool bigEndian) => throw new NotImplementedException();
    public Guid New(string text) => throw new NotImplementedException();
    public Guid New(uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k)
        => throw new NotImplementedException();

    public Guid Parse(ReadOnlySpan<char> input) => throw new NotImplementedException();
    public Guid Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => throw new NotImplementedException();
    public Guid Parse(string input) => throw new NotImplementedException();
    public Guid Parse(string s, IFormatProvider? provider) => throw new NotImplementedException();

    public Guid ParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format) => throw new NotImplementedException();
    public Guid ParseExact(string input, string format) => throw new NotImplementedException();

    public bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Guid result) => throw new NotImplementedException();
    public bool TryParse(ReadOnlySpan<char> input, out Guid result) => throw new NotImplementedException();
    public bool TryParse(string? s, IFormatProvider? provider, out Guid result) => throw new NotImplementedException();
    public bool TryParse(string? input, out Guid result) => throw new NotImplementedException();

    public bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, out Guid result) => throw new NotImplementedException();
    public bool TryParseExact(string? input, string? format, out Guid result) => throw new NotImplementedException();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\TestDoubles\TestInput.cs 
﻿namespace DotNetToolbox.ConsoleApplication.TestDoubles;

internal class TestInput(IOutput output, params string[] inputs) : IInput {
    private readonly Queue<string> _inputQueue = new(inputs);

    public bool KeyAvailable() => throw new NotImplementedException();

    public int Read() => throw new NotImplementedException();

    public ConsoleKeyInfo ReadKey(bool intercept = false) => throw new NotImplementedException();

    public string ReadLine() {
        if (!_inputQueue.TryDequeue(out var input)) return string.Empty;
        output.WriteLine(input);
        return input;
    }

    public string ReadMultiLine(ConsoleKey submitKey = ConsoleKey.Enter,
                                ConsoleModifiers submitKeyModifiers = ConsoleModifiers.None) {
        var input = string.Empty;
        while (_inputQueue.TryDequeue(out var line) && !line.EndsWith("[Ctrl+Enter]")) {
            output.WriteLine(line);
            input += line + System.Environment.NewLine;
        }
        return input;
    }

    public Encoding Encoding {
        get => throw new NotImplementedException();
        set => throw new NotImplementedException();
    }
    public TextReader Reader => throw new NotImplementedException();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\TestDoubles\TestOutput.cs 
﻿namespace DotNetToolbox.ConsoleApplication.TestDoubles;

internal class TestOutput : IOutput {
    public string Prompt { get; set; } = "> ";

    public override string ToString() => string.Join(System.Environment.NewLine, Lines);

    public List<string> Lines { get; } = [];

    public void ClearScreen() {
        Lines.Clear();
        Lines.Add(string.Empty);
    }

    public void ResetColor() => throw new NotImplementedException();

    public void Write(bool value) => throw new NotImplementedException();

    public void Write(char value) => throw new NotImplementedException();

    public void Write(char[] buffer, int index, int count) => throw new NotImplementedException();

    public void Write(char[]? buffer) => throw new NotImplementedException();

    public void Write(decimal value) => throw new NotImplementedException();

    public void Write(double value) => throw new NotImplementedException();

    public void Write(float value) => throw new NotImplementedException();

    public void Write(int value) => throw new NotImplementedException();

    public void Write(long value) => throw new NotImplementedException();

    public void Write(object? value) => throw new NotImplementedException();

    public void Write([Syntax(Syntax.CompositeFormat)] string format, object? arg0)
        => Lines[^1] += string.Format(format, arg0);

    public void Write([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1) => throw new NotImplementedException();

    public void Write([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1, object? arg2) => throw new NotImplementedException();

    public void Write([Syntax(Syntax.CompositeFormat)] string format, params object?[] args)
        => Lines[^1] += string.Format(format, args);

    public void Write(string? value) {
        var lines = (value ?? string.Empty).Split(System.Environment.NewLine);
        if (lines.Length == 0) return;
        if (Lines.Count == 0) Lines.Add(lines[0]);
        else Lines[^1] += lines[0];
        foreach (var line in lines.Skip(1)) Lines.Add(line);
    }

    public void Write(StringBuilder? builder) => throw new NotImplementedException();

    public void Write(uint value) => throw new NotImplementedException();

    public void Write(ulong value) => throw new NotImplementedException();

    public void WritePrompt() {
        if (Lines.Count == 0) Lines.Add(Prompt);
        else Lines[^1] += Prompt;
    }

    public void WriteLine() => Lines.Add(string.Empty);

    public void WriteLine(bool value) => throw new NotImplementedException();

    public void WriteLine(char value) => throw new NotImplementedException();

    public void WriteLine(char[] buffer, int index, int count) => throw new NotImplementedException();

    public void WriteLine(char[]? buffer) => throw new NotImplementedException();

    public void WriteLine(decimal value) => throw new NotImplementedException();

    public void WriteLine(double value) => throw new NotImplementedException();

    public void WriteLine(float value) => throw new NotImplementedException();

    public void WriteLine(int value) => throw new NotImplementedException();

    public void WriteLine(long value) => throw new NotImplementedException();

    public void WriteLine(object? value) {
        Write("{0}", value);
        WriteLine();
    }

    public void WriteLine([Syntax(Syntax.CompositeFormat)] string format, object? arg0) {
        Write(format, arg0);
        WriteLine();
    }

    public void WriteLine([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1) => throw new NotImplementedException();

    public void WriteLine([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1, object? arg2) => throw new NotImplementedException();

    public void WriteLine([Syntax(Syntax.CompositeFormat)] string format, params object?[] args) {
        Write(format, args);
        WriteLine();
    }

    public void WriteLine(string? value) {
        Write(value ?? string.Empty);
        WriteLine();
    }

    public void WriteLine(StringBuilder? builder) => throw new NotImplementedException();

    public void WriteLine(uint value) => throw new NotImplementedException();

    public void WriteLine(ulong value) => throw new NotImplementedException();

    public ConsoleColor BackgroundColor {
        get => throw new NotImplementedException();
        set => throw new NotImplementedException();
    }

    public Encoding Encoding {
        get => throw new NotImplementedException();
        set => throw new NotImplementedException();
    }
    public TextWriter Error => throw new NotImplementedException();
    public ConsoleColor ForegroundColor {
        get => throw new NotImplementedException();
        set => throw new NotImplementedException();
    }

    public TextWriter Writer => throw new NotImplementedException();

    public string NewLine => throw new NotImplementedException();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\Utilities\ArgumentsParserTests.cs 
namespace DotNetToolbox.ConsoleApplication.Utilities;

public class ArgumentsParserTests {
    private readonly IApplication _app = Substitute.For<IApplication>();
    private readonly IServiceProvider _serviceProvider = Substitute.For<IServiceProvider>();
    private readonly ILoggerFactory _loggerFactory = Substitute.For<ILoggerFactory>();
    private readonly IFlag _flag;
    private readonly IOption _option;
    private readonly IParameter _parameter;
    private readonly IParameter _requiredParameter;
    private readonly Command _command;

    public ArgumentsParserTests() {
        _serviceProvider.GetService(typeof(ILoggerFactory)).Returns(_loggerFactory);
        _app.Services.Returns(_serviceProvider);
        _app.Context.Returns([]);
        _option = new Option(_app, "Option", "o");
        _flag = new Flag(_app, "Flag", ["f"]);
        _requiredParameter = new Parameter(_app, "Name");
        _parameter = new Parameter(_app, "Age", "18");
        _command = new(_app, "Say", ["s"], (_, _) => Result.SuccessTask());
    }

    [Fact]
    public async Task Read_WithNoArguments_ShouldReturnSuccess() {
        // Arrange & Act
        var result = await ArgumentsParser.Parse(_app, [], default);

        // Assert
        result.Should().BeEquivalentTo(Result.Success());
    }

    [Fact]
    public async Task Read_WithInvalidArgument_ReturnsInvalid() {
        // Arrange
        var arguments = new[] { "unknown" };
        const string expectedMessage = "Unknown argument 'unknown'. For a list of available arguments use '--help'.";

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsInvalid.Should().BeTrue();
        result.Errors[0].Message.Should().Be(expectedMessage);
    }

    [Fact]
    public async Task Read_WithInvalidOption_ReturnsInvalid() {
        // Arrange
        var arguments = new[] { "--unknown" };
        const string expectedMessage = "Unknown argument '--unknown'. For a list of available arguments use '--help'.";

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsInvalid.Should().BeTrue();
        result.Errors[0].Message.Should().Be(expectedMessage);
    }

    [Fact]
    public async Task Read_WithInvalidAlias_ReturnsInvalid() {
        // Arrange
        var arguments = new[] { "-u" };
        const string expectedMessage = "Unknown argument '-u'. For a list of available arguments use '--help'.";

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsInvalid.Should().BeTrue();
        result.Errors[0].Message.Should().Be(expectedMessage);
    }

    [Fact]
    public async Task Read_WithFlagByName_AndValue_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "--flag" };
        _app.Children.Returns(new List<INode> { _flag });

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Flag"].Should().BeOfType<string>().Subject.Should().Be("True");
    }

    [Fact]
    public async Task Read_WithFlagByAlias_AndValue_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "-f" };
        _app.Children.Returns(new List<INode> { _flag });

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Flag"].Should().BeOfType<string>().Subject.Should().Be("True");
    }

    [Fact]
    public async Task Read_WithOptionByName_WithoutValue_ReturnsInvalid() {
        // Arrange
        var arguments = new[] { "--option" };
        _app.Children.Returns(new List<INode> { _option });
        const string expectedMessage = "Missing value for option '--option'.";

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsInvalid.Should().BeTrue();
        result.Errors[0].Message.Should().Be(expectedMessage);
    }

    [Fact]
    public async Task Read_WithOptionByName_AndValue_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "--option", "42" };
        _app.Children.Returns(new List<INode> { _option });

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Option"].Should().BeOfType<string>().Subject.Should().Be("42");
    }

    [Fact]
    public async Task Read_WithOptionByAlias_AndValue_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "-o", "42" };
        _app.Children.Returns(new List<INode> { _option });

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Option"].Should().BeOfType<string>().Subject.Should().Be("42");
    }

    [Fact]
    public async Task Read_WithOptionByName_AndQuotedValue_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "-o", """
                                      "John Doe"
                                      """ };
        _app.Children.Returns(new List<INode> { _option });

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Option"].Should().Be("John Doe");
    }

    [Fact]
    public async Task Read_WithOptionByName_AndDefaultKeyWord_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "-o", "default" };
        _app.Children.Returns(new List<INode> { _option });

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Option"].Should().BeNull();
    }

    [Fact]
    public async Task Read_WithOptionByAlias_AndNullKeyWord_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "-o", "null" };
        _app.Children.Returns(new List<INode> { _option });

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Option"].Should().BeNull();
    }

    [Fact]
    public async Task Read_WithValueForParameter_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "42" };
        _app.Children.Returns(new List<INode> { _parameter });
        _app.Parameters.Returns([_parameter]);

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Age"].Should().BeOfType<string>().Subject.Should().Be("42");
    }

    [Fact]
    public async Task Read_WithValueForRequiredParameterOnly_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "John Doe" };
        _app.Children.Returns(new List<INode> { _requiredParameter, _parameter });
        _app.Parameters.Returns([_requiredParameter, _parameter]);

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Name"].Should().Be("John Doe");
        _app.Context["Age"].Should().Be("18");
    }

    [Fact]
    public async Task Read_WithOptionAfterArgument_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "42", "-o" };
        _app.Children.Returns(new List<INode> { _requiredParameter, _parameter });
        _app.Parameters.Returns([_requiredParameter, _parameter]);
        const string expectedMessage = "Unknown argument '-o'. For a list of available arguments use '--help'.";

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsInvalid.Should().BeTrue();
        result.Errors[0].Message.Should().Be(expectedMessage);
    }

    [Fact]
    public async Task Read_WithNoValueForOptionalParameter_ReturnsSuccess() {
        // Arrange
        var arguments = Array.Empty<string>();
        _app.Children.Returns(new List<INode> { _parameter });
        _app.Parameters.Returns([_parameter]);

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Age"].Should().BeOfType<string>().Subject.Should().Be("18");
    }

    [Fact]
    public async Task Read_WithDefaultKeyWordForParameter_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "default" };
        _app.Children.Returns(new List<INode> { _parameter });
        _app.Parameters.Returns([_parameter]);

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Age"].Should().BeOfType<string>().Subject.Should().Be("18");
    }

    [Fact]
    public async Task Read_WithNullKeyWordForParameter_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "null" };
        _app.Children.Returns(new List<INode> { _parameter });
        _app.Parameters.Returns([_parameter]);

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Age"].Should().BeNull();
    }

    [Fact]
    public async Task Read_WithOption_AndNoValueForRequiredParameter_ReturnsInvalid() {
        // Arrange
        var arguments = new[] { "-o", """
                                      "John Doe"
                                      """ };
        _app.Children.Returns(new List<INode> { _option, _requiredParameter });
        _app.Options.Returns([_option]);
        _app.Parameters.Returns([_requiredParameter]);
        const string expectedMessage = "Required parameter is missing: 'Name'.";

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsInvalid.Should().BeTrue();
        result.Errors[0].Message.Should().Be(expectedMessage);
    }

    [Fact]
    public async Task Read_WithFullSetOfArguments_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "--flag", "-o", "42", """
                                                      "John Doe"
                                                      """, "20" };
        _app.Children.Returns(new List<INode> { _flag, _option, _requiredParameter, _parameter });
        _app.Options.Returns([_flag, _option]);
        _app.Parameters.Returns([_requiredParameter, _parameter]);
        _app.Context.Returns([]);

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
        _app.Context["Flag"].Should().BeOfType<string>().Subject.Should().Be("True");
        _app.Context["Option"].Should().BeOfType<string>().Subject.Should().Be("42");
        _app.Context["Name"].Should().BeOfType<string>().Subject.Should().Be("John Doe");
        _app.Context["Age"].Should().BeOfType<string>().Subject.Should().Be("20");
    }

    [Fact]
    public async Task Read_WithNoValueForRequiredParameter_ReturnsInvalid() {
        // Arrange
        var arguments = Array.Empty<string>();
        _app.Children.Returns(new List<INode> { _requiredParameter });
        _app.Parameters.Returns([_requiredParameter]);
        const string expectedMessage = "Required parameter is missing: 'Name'.";

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsInvalid.Should().BeTrue();
        result.Errors[0].Message.Should().Be(expectedMessage);
    }

    [Fact]
    public async Task Read_WithCommandByName_ReturnsInvalid() {
        // Arrange
        var arguments = new[] { "say" };
        _app.Children.Returns(new List<INode> { _command });

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public async Task Read_WithCommandByAlias_ReturnsInvalid() {
        // Arrange
        var arguments = new[] { "s" };
        _app.Children.Returns(new List<INode> { _command });

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public async Task Read_WithCommand_WithSubCommand_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "s", "-f" };
        _app.Children.Returns(new List<INode> { _command });
        _command.AddFlag("Flag", "f");
        _command.AddCommand("TheCommand", () => { });
        _command.AddFlag("ACommand", () => { });
        _command.AddParameter("First", "1");
        _command.AddParameter("Second", "2");

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public async Task Read_WithCommandWithOption_AndValue_ReturnsSuccess() {
        // Arrange
        var arguments = new[] { "-o", "42" };
        _app.Children.Returns(new List<INode> { _option });

        // Act
        var result = await ArgumentsParser.Parse(_app, arguments, default);

        // Assert
        result.IsSuccess.Should().BeTrue();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Console.UnitTests\Utilities\OutputFormatterTests.cs 
﻿namespace DotNetToolbox.ConsoleApplication.Utilities;
public class OutputFormatterTests {
    [Fact]
    public void FormatException_WithSingleException_IncludesTypeAndMessage() {
        // Arrange
        var exception = new InvalidOperationException("Test exception");

        // Act
        var result = OutputFormatter.FormatException(exception);

        // Assert
        result.Should().Contain("InvalidOperationException");
        result.Should().Contain("Test exception");
    }

    [Fact]
    public void FormatException_WithInnerException_IncludesBothExceptions() {
        // Arrange
        var innerException = new InvalidOperationException("Inner exception");
        var outerException = new Exception("Outer exception", innerException);
        const string expectedResult = """
                                      Exception: Outer exception
                                          Inner Exception => InvalidOperationException: Inner exception

                                      """;

        // Act
        var result = OutputFormatter.FormatException(outerException);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatValidationErrors_WithNoErrors_ReturnsEmptyString() {
        // Arrange
        var errors = Array.Empty<ValidationError>();

        // Act
        var result = OutputFormatter.FormatValidationErrors(errors);

        // Assert
        result.Should().BeEmpty();
    }

    [Fact]
    public void FormatValidationErrors_WithMultipleErrors_FormatsAllErrors() {
        // Arrange
        var errors = new List<ValidationError> {
            new("First error."),
            new("Second error."),
        };
        const string expectedResult = """
                                      Validation error: First error.
                                      Validation error: Second error.

                                      """;

        // Act
        var result = OutputFormatter.FormatValidationErrors(errors);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatHelp_WithNode_IncludesDescriptionAndUsage() {
        // Arrange
        var node = Substitute.For<IHasChildren>();
        node.Name.Returns("test-command");
        node.Path.Returns("test-command");
        node.Description.Returns("Test command description.");
        const string expectedResult = """
                                      Test command description.

                                      Usage:
                                          test-command

                                      """;

        // Act
        var result = OutputFormatter.FormatHelp(node);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatHelp_WithApplication_IncludesFullNameAndVersion() {
        // Arrange
        var app = Substitute.For<IApplication>();
        app.FullName.Returns("TestApp");
        app.Version.Returns("1.0.0");
        app.Path.Returns("TestApp");
        const string expectedResult = """
                                      TestApp

                                      Usage:
                                          TestApp

                                      """;

        // Act
        var result = OutputFormatter.FormatHelp(app);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatHelp_WithChildren_IncludesSectionHeaders() {
        // Arrange
        var node = Substitute.For<IHasChildren>();
        node.Name.Returns("test-command");
        node.Path.Returns("test-command");
        node.Description.Returns("Test command description.");
        var option = Substitute.For<IOption>();
        option.Name.Returns("option");
        option.Description.Returns("Description for option.");
        node.Options.Returns([option]);
        var parameter = Substitute.For<IParameter>();
        parameter.Name.Returns("parameter");
        parameter.Description.Returns($"Description for parameter.{System.Environment.NewLine}");
        node.Parameters.Returns([parameter]);
        var command = Substitute.For<ICommand>();
        command.Name.Returns("subcommand");
        command.Description.Returns($"Description for subcommand line1.{System.Environment.NewLine}Description for subcommand line2.{System.Environment.NewLine}");
        node.Commands.Returns([command]);
        node.Children.Returns([option, parameter, command]);

        const string expectedResult = """
                                  Test command description.

                                  Usage:
                                      test-command [Options] [Commands]
                                      test-command [Options] [<parameter>]

                                  Options:
                                      --option                  Description for option.

                                  Parameters:
                                      parameter                 Description for parameter.

                                  Commands:
                                      subcommand                Description for subcommand line1.
                                                                Description for subcommand line2.

                                  """;

        // Act
        var result = OutputFormatter.FormatHelp(node);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatHelp_WithEmptyChildren_DoesNotIncludeSectionHeaders() {
        // Arrange
        var node = Substitute.For<IHasChildren>();
        node.Name.Returns("test-command");
        node.Path.Returns("test-command");
        node.Description.Returns("Test command description.");
        node.Options.Returns([]);
        node.Parameters.Returns([]);
        node.Commands.Returns([]);

        const string expectedResult = """
                                  Test command description.

                                  Usage:
                                      test-command

                                  """;

        // Act
        var result = OutputFormatter.FormatHelp(node);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatHelp_ForApplicationWithChildren_IncludesSectionHeaders() {
        // Arrange
        var node = Substitute.For<IApplication>();
        node.FullName.Returns("TestApp v1.0");
        node.AssemblyName.Returns("test-command");
        node.Path.Returns("test-command");
        node.Description.Returns("Test command description.");
        var option = Substitute.For<IOption>();
        option.Name.Returns("option");
        option.Description.Returns("Description for option.");
        node.Options.Returns([option]);
        var parameter = Substitute.For<IParameter>();
        parameter.Name.Returns("parameter");
        parameter.IsRequired.Returns(true);
        parameter.Description.Returns("Description for parameter.");
        node.Parameters.Returns([parameter]);
        var command = Substitute.For<ICommand>();
        command.Name.Returns("subcommand");
        command.Description.Returns("Description for subcommand.");
        node.Commands.Returns([command]);
        node.Children.Returns([option, parameter, command]);

        const string expectedResult = """
                                      TestApp v1.0
                                      Test command description.

                                      Usage:
                                          test-command [Options] [Commands]
                                          test-command [Options] <parameter>

                                      Options:
                                          --option                  Description for option.

                                      Parameters:
                                          parameter                 Description for parameter.

                                      Commands:
                                          subcommand                Description for subcommand.

                                      """;

        // Act
        var result = OutputFormatter.FormatHelp(node);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatException_WithoutStackTrace_IncludesExceptionWithoutStackTrace() {
        // Arrange
        var exception = new InvalidOperationException("Test exception without stack trace");
        const string expectedResult = """
                                  InvalidOperationException: Test exception without stack trace

                                  """;

        // Act
        var result = OutputFormatter.FormatException(exception);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatHelp_WithNodeHavingAliases_IncludesAliasesInDescription() {
        // Arrange
        var node = Substitute.For<IHasChildren>();
        node.Path.Returns("test-command");
        node.Name.Returns("test-command");
        node.Aliases.Returns(["t", "test"]);
        node.Description.Returns("Test command with aliases.");
        const string expectedResult = """
                                  Test command with aliases.

                                  Usage:
                                      test-command

                                  Aliases: t, test

                                  """;

        // Act
        var result = OutputFormatter.FormatHelp(node);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatHelp_WithIncludeApplicationTrue_IncludesApplicationName() {
        // Arrange
        var app = Substitute.For<IApplication>();
        app.FullName.Returns("TestApp");
        app.Description.Returns("Application description.");
        app.Path.Returns("TestApp");
        const string expectedResult = """
                                  TestApp
                                  Application description.

                                  Usage:
                                      TestApp

                                  """;

        // Act
        var result = OutputFormatter.FormatHelp(app);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatHelp_WithNodeHavingWhitespaceInDescription_TrimsDescription() {
        // Arrange
        var node = Substitute.For<IHasChildren>();
        node.Path.Returns("test-command");
        node.Description.Returns("  Test command with leading and trailing whitespace.  ");
        const string expectedResult = """
                                  Test command with leading and trailing whitespace.

                                  Usage:
                                      test-command

                                  """;

        // Act
        var result = OutputFormatter.FormatHelp(node);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatHelp_WithNodeHavingEmptyDescription_DoesNotIncludeEmptyDescription() {
        // Arrange
        var node = Substitute.For<IHasChildren>();
        node.Path.Returns("test-command");
        node.Description.Returns("");
        const string expectedResult = """
                                  Usage:
                                      test-command

                                  """;

        // Act
        var result = OutputFormatter.FormatHelp(node);

        // Assert
        result.Should().Be(expectedResult);
    }

    [Fact]
    public void FormatHelp_WithNullNode_ThrowsArgumentNullException() {
        // Act
        var act = () => OutputFormatter.FormatHelp(null!);

        // Assert
        act.Should().Throw<NullReferenceException>();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\AssemblyAccessor.cs 
﻿namespace DotNetToolbox;

public interface IAssemblyAccessor {
    IAssemblyDescriptor GetExecutingAssembly();
    IAssemblyDescriptor? GetEntryAssembly();
    IAssemblyDescriptor? GetDeclaringAssembly(Type type);
    IAssemblyDescriptor? GetDeclaringAssembly<TType>();
    IAssemblyDescriptor GetCallingAssembly();
}

[ExcludeFromCodeCoverage(Justification = "Thin wrapper for Assembly functionality.")]
// ReSharper disable once ClassWithVirtualMembersNeverInherited.Global - Used for externally.
public class AssemblyAccessor : HasDefault<AssemblyAccessor>, IAssemblyAccessor {
    public virtual IAssemblyDescriptor GetExecutingAssembly()
        => new AssemblyDescriptor(Assembly.GetExecutingAssembly());

    public virtual IAssemblyDescriptor? GetEntryAssembly() {
        var assembly = Assembly.GetEntryAssembly();
        return assembly is null ? null : new AssemblyDescriptor(assembly);
    }

    public virtual IAssemblyDescriptor? GetDeclaringAssembly(Type type) {
        var assembly = Assembly.GetAssembly(type);
        return assembly is null ? null : new AssemblyDescriptor(assembly);
    }

    public virtual IAssemblyDescriptor? GetDeclaringAssembly<TType>()
        => GetDeclaringAssembly(typeof(TType));

    public virtual IAssemblyDescriptor GetCallingAssembly()
        => new AssemblyDescriptor(Assembly.GetCallingAssembly());
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\AssemblyDescriptor.cs 
﻿namespace DotNetToolbox;

public interface IAssemblyDescriptor {
    string Name { get; }
    string FullName { get; }
    Version Version { get; }
    string RuntimeVersion { get; }
    CultureInfo? CultureInfo { get; }
    string? PublicKey { get; }
    string? PublicKeyToken { get; }
    string Location { get; }
    MethodInfo? EntryPoint { get; }
    Module ManifestModule { get; }
    IEnumerable<Attribute> GetCustomAttributes();
    IEnumerable<Attribute> GetCustomAttributes(Type attributeType);
    IEnumerable<Attribute> GetCustomAttributes<TAttribute>()
        where TAttribute : Attribute;
    TAttribute? GetCustomAttribute<TAttribute>()
        where TAttribute : Attribute;
    Attribute? GetCustomAttribute(Type attributeType);
    IEnumerable<TypeInfo> DefinedTypes { get; }
    IEnumerable<Type> ExportedTypes { get; }
    IEnumerable<Module> Modules { get; }
}

[ExcludeFromCodeCoverage(Justification = "Thin wrapper for Assembly functionality.")]
public class AssemblyDescriptor
    : HasDefault<AssemblyDescriptor>, IAssemblyDescriptor {
    private readonly Assembly _assembly;

    public AssemblyDescriptor() {
        _assembly = Assembly.GetEntryAssembly()!;
    }

    internal AssemblyDescriptor(Assembly assembly) {
        _assembly = assembly;
    }

    public virtual string Name => _assembly.GetName().Name!;
    public virtual string FullName => _assembly.FullName!;
    public virtual Version Version => _assembly.GetName().Version!;
    public virtual CultureInfo? CultureInfo => _assembly.GetName().CultureInfo;
    public virtual string? PublicKey {
        get {
            var bytes = _assembly.GetName().GetPublicKey();
            return bytes is null ? null : Encoding.UTF8.GetString(bytes);
        }
    }
    public virtual string? PublicKeyToken {
        get {
            var bytes = _assembly.GetName().GetPublicKeyToken();
            return bytes is null ? null : Encoding.UTF8.GetString(bytes);
        }
    }

    public virtual string RuntimeVersion => _assembly.ImageRuntimeVersion;
    public virtual string Location => _assembly.Location;
    public virtual MethodInfo? EntryPoint => _assembly.EntryPoint;
    public virtual Module ManifestModule => _assembly.ManifestModule;
    public virtual IEnumerable<Attribute> GetCustomAttributes()
        => _assembly.GetCustomAttributes();
    public virtual IEnumerable<Attribute> GetCustomAttributes(Type attributeType)
        => _assembly.GetCustomAttributes(attributeType);
    public virtual IEnumerable<Attribute> GetCustomAttributes<TAttribute>()
        where TAttribute : Attribute
        => _assembly.GetCustomAttributes<TAttribute>();
    public virtual TAttribute? GetCustomAttribute<TAttribute>()
        where TAttribute : Attribute
        => _assembly.GetCustomAttribute<TAttribute>();
    public virtual Attribute? GetCustomAttribute(Type attributeType)
        => _assembly.GetCustomAttribute(attributeType);
    public virtual IEnumerable<TypeInfo> DefinedTypes => _assembly.DefinedTypes;
    public virtual IEnumerable<Type> ExportedTypes => _assembly.ExportedTypes;
    public virtual IEnumerable<Module> Modules => _assembly.Modules;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\CreateInstance.cs 
﻿namespace DotNetToolbox;

public static class CreateInstance {
    private const BindingFlags _allConstructors = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance;

    public static T Of<[DynamicallyAccessedMembers(PublicConstructors | NonPublicConstructors)] T>(params object?[] args) {
        try {
            return (T)IsNotNull(Activator.CreateInstance(typeof(T), _allConstructors, null, args, null, null));
        }
        catch (Exception ex) {
            throw new InvalidOperationException($"Failed to create instance of type {typeof(T).Name}", ex);
        }
    }

    public static T Of<[DynamicallyAccessedMembers(PublicConstructors)] T>(IServiceProvider services, params object?[] args)
        where T : class {
        try {
            return ActivatorUtilities.CreateInstance<T>(services, args!);
        }
        catch (Exception ex) {
            throw new InvalidOperationException($"Failed to create instance of type {typeof(T).Name}", ex);
        }
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\DateTimeProvider.cs 
﻿namespace DotNetToolbox;

public interface IDateTimeProvider {
    DateTimeOffset Maximum { get; }
    DateTimeOffset Minimum { get; }
    DateTimeOffset Now { get; }
    TimeOnly TimeOfDay { get; }
    DateOnly Today { get; }
    DateTimeOffset UnixEpoch { get; }
    DateTimeOffset UtcNow { get; }
    TimeOnly UtcTimeOfDay { get; }
    DateOnly UtcToday { get; }

    DateTimeOffset FromFileTime(long fileTime);
    DateTimeOffset FromUnixTimeMilliseconds(long ms);
    DateTimeOffset FromUnixTimeSeconds(long s);
    DateTimeOffset Parse(string s);
    DateTimeOffset ParseExact(string s, [Syntax("DateTimeFormat")] string format);
    bool TryParse(string s, out DateTimeOffset result);
    bool TryParseExact(string s, [Syntax("DateTimeFormat")] string format, out DateTimeOffset result);
}

[ExcludeFromCodeCoverage(Justification = "Thin wrapper for OS functionality.")]
// ReSharper disable once ClassWithVirtualMembersNeverInherited.Global - Used for externally.
public class DateTimeProvider : HasDefault<DateTimeProvider>, IDateTimeProvider {
    public virtual DateTimeOffset Now => DateTimeOffset.Now;
    public virtual DateOnly Today => DateOnly.FromDateTime(DateTime.Today);
    public virtual TimeOnly TimeOfDay => TimeOnly.FromDateTime(DateTime.Now);

    public virtual DateTimeOffset UtcNow => DateTimeOffset.UtcNow;
    public virtual DateOnly UtcToday => DateOnly.FromDateTime(UtcNow.DateTime);
    public virtual TimeOnly UtcTimeOfDay => TimeOnly.FromDateTime(UtcNow.DateTime);

    public virtual DateTimeOffset Minimum => DateTimeOffset.MinValue;
    public virtual DateTimeOffset Maximum => DateTimeOffset.MaxValue;
    public virtual DateTimeOffset UnixEpoch => DateTimeOffset.UnixEpoch;

    public virtual DateTimeOffset FromFileTime(long fileTime) => DateTimeOffset.FromFileTime(fileTime);
    public virtual DateTimeOffset FromUnixTimeMilliseconds(long ms) => DateTimeOffset.FromUnixTimeMilliseconds(ms);
    public virtual DateTimeOffset FromUnixTimeSeconds(long s) => DateTimeOffset.FromUnixTimeSeconds(s);

    public virtual DateTimeOffset Parse(string s) => DateTimeOffset.Parse(s);
    public virtual bool TryParse(string s, out DateTimeOffset result)
        => DateTimeOffset.TryParse(s, out result);

    public virtual DateTimeOffset ParseExact(string s, [Syntax(Syntax.DateTimeFormat)] string format)
        => DateTimeOffset.ParseExact(s, format, null, DateTimeStyles.None);
    public virtual bool TryParseExact(
        string s,
        [Syntax(Syntax.DateTimeFormat)] string format,
        out DateTimeOffset result)
        => DateTimeOffset.TryParseExact(s, format, null, DateTimeStyles.None, out result);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\DisposableStateHolder.cs 
﻿namespace DotNetToolbox;

public class DisposableStateHolder(object? state)
    : DisposableStateHolder<object?>(state);

public class DisposableStateHolder<TState>(TState state)
    : IDisposable {
    public TState State { get; } = state;
    public void Dispose() {
        if (State is IDisposable disposable)
            disposable.Dispose();
        GC.SuppressFinalize(this);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Ensure.cs 
﻿namespace DotNetToolbox;

public static class Ensure {
    [return: NotNull]
    public static TArgument IsNotNull<TArgument>(TArgument? argument, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
        => argument ?? throw new ArgumentNullException(paramName, ValueCannotBeNull);

    [return: NotNull]
    public static TArgument IsNotNullOrDefault<TArgument>(TArgument? argument, TArgument defaultValue)
        => argument ?? IsNotNull(defaultValue);

    [return: NotNull]
    public static TArgument IsOfType<TArgument>(object? argument, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
        => IsNotNull(argument, paramName) is not TArgument result
            ? throw new ArgumentException(string.Format(ValueMustBeOfType, typeof(TArgument).Name, argument!.GetType().Name), paramName)
            : result;

    [return: NotNullIfNotNull(nameof(argument))]
    public static TArgument? IsNotEmpty<TArgument>(TArgument? argument, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
        where TArgument : IEnumerable
        => argument switch {
            ICollection { Count: 0 } => throw new ArgumentException(CollectionCannotBeEmpty, paramName),
            _ => argument,
        };

    [return: NotNull]
    public static TArgument IsNotNullOrEmpty<TArgument>(TArgument? argument, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
        where TArgument : IEnumerable
        => argument switch {
            null => throw new ArgumentException(ValueCannotBeNull, paramName),
            string { Length: 0 } => throw new ArgumentException(StringCannotBeNullOrEmpty, paramName),
            ICollection { Count: 0 } => throw new ArgumentException(CollectionCannotBeEmpty, paramName),
            _ => argument,
        };

    public static string IsNotNullOrWhiteSpace(string? argument, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
        => argument is null || argument.Trim().Length == 0
            ? throw new ArgumentException(StringCannotBeNullOrWhiteSpace, paramName)
            : argument;

    [return: NotNullIfNotNull(nameof(argument))]
    public static TArgument IsValid<TArgument>(TArgument? argument, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
        where TArgument : IValidatable
        => IsValid(argument, arg => IsNotNull(arg).Validate(), paramName)!;

    [return: NotNullIfNotNull(nameof(validValue))]
    public static TArgument? IsValidOrDefault<TArgument>(TArgument? argument, TArgument? validValue)
        where TArgument : IValidatable { // null maybe a valid value
        var result = argument?.Validate() ?? Result.Success();
        return result.IsSuccess
                   ? argument ?? validValue
                   : validValue;
    }

    [return: NotNullIfNotNull(nameof(argument))]
    public static TArgument? IsValid<TArgument>(TArgument? argument, Func<TArgument, Result> validate, [CallerArgumentExpression(nameof(argument))]string? paramName = null) {
        if (argument is null) return argument;
        var result = validate(argument);
        return result.IsSuccess ? argument : throw new ValidationException(ValueIsInvalid, paramName!);
    }

    [return: NotNullIfNotNull(nameof(defaultValue))]
    public static TArgument? IsValidOrDefault<TArgument>(TArgument? argument, Func<TArgument?, Result> validate, TArgument? defaultValue)
        => validate(argument).IsSuccess
               ? argument ?? defaultValue
               : defaultValue;

    [return: NotNullIfNotNull(nameof(argument))]
    public static TArgument? IsValid<TArgument>(TArgument? argument, Func<TArgument?, bool> isValid, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
        => isValid(argument)
               ? argument
               : throw new ValidationException(ValueIsInvalid, paramName!);

    [return: NotNullIfNotNull(nameof(defaultValue))]
    public static TArgument? IsValidOrDefault<TArgument>(TArgument? argument, Func<TArgument?, bool> isValid, TArgument? defaultValue)
        => isValid(argument)
               ? argument ?? defaultValue
               : defaultValue;

    [return: NotNullIfNotNull(nameof(argument))]
    public static TArgument? DoesNotContainNullItems<TArgument>(TArgument? argument, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
        where TArgument : IEnumerable
        => argument?.Cast<object?>().All(i => i is not null) ?? true
               ? argument
               : throw new ValidationException(CollectionContainsNull, paramName!);

    [return: NotNullIfNotNull(nameof(argument))]
    public static TArgument? DoesNotContainInvalidItems<TArgument>(TArgument? argument, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
        where TArgument : IEnumerable<IValidatable>
        => argument?.All(i => i?.Validate().IsSuccess ?? true) ?? true
               ? argument
               : throw new ValidationException(CollectionContainsInvalid, paramName!);

    [return: NotNullIfNotNull(nameof(argument))]
    public static TArgument? DoesNotContainInvalidItems<TArgument, TValue>(TArgument? argument, Func<TValue?, Result> validate, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
        where TArgument : IEnumerable<TValue?>
        => argument?.All(i => validate(i).IsSuccess) ?? true
               ? argument
               : throw new ValidationException(CollectionContainsInvalid, paramName!);

    [return: NotNullIfNotNull(nameof(argument))]
    public static TArgument? DoesNotContainInvalidItems<TArgument, TValue>(TArgument? argument, Func<TValue?, bool> isValid, [CallerArgumentExpression(nameof(argument))] string? paramName = null)
        where TArgument : IEnumerable<TValue?>
        => argument?.All(isValid) ?? true
                   ? argument
                   : throw new ValidationException(CollectionContainsInvalid, paramName!);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Environment.cs 
﻿namespace DotNetToolbox;

public interface IEnvironment {
    string Name { get; }
    IAssemblyDescriptor Assembly { get; }
    IDateTimeProvider DateTime { get; }
    IFileSystem FileSystem { get; }
    IGuidProvider Guid { get; }
    IInput Input { get; }
    IOutput Output { get; }
}

public class Environment(IServiceProvider services, string? name = null) : IEnvironment {
    public virtual string Name { get; } = name ?? string.Empty;
    public virtual IAssemblyDescriptor Assembly { get; } = services.GetRequiredService<IAssemblyDescriptor>();
    public virtual IOutput Output { get; } = services.GetRequiredService<IOutput>();
    public virtual IInput Input { get; } = services.GetRequiredService<IInput>();
    public virtual IDateTimeProvider DateTime { get; } = services.GetRequiredService<IDateTimeProvider>();
    public virtual IGuidProvider Guid { get; } = services.GetRequiredService<IGuidProvider>();
    public virtual IFileSystem FileSystem { get; } = services.GetRequiredService<IFileSystem>();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\FileSystem.cs 
﻿namespace DotNetToolbox;

public interface IFileSystem {
    char DirectorySeparatorChar { get; }

    string CombinePath(params string[] paths);
    void CopyFile(string sourcePath, string targetPath, bool overwrite = false);
    void CreateFolder(string folderPath);
    Stream CreateNewOrOverwriteFile(string filePath, bool blockExternalAccess = true);
    void DeleteFile(string sourcePath);
    void DeleteFolder(string folderPath, bool includeAllContent = false);
    bool FileExists(string filePath);
    string[] GetFilePath(string filePath);
    string GetFileName(string filePath, bool includeExtension = false);
    string GetFileExtension(string filePath, bool includeDot = true);
    char FolderSeparator { get; }
    string CurrentFolder { get; set; }
    bool FolderExists(string folderPath);
    IEnumerable<string> GetEntries(string baseFolder);
    IEnumerable<string> GetEntries(string baseFolder, string searchPattern);
    IEnumerable<string> GetEntries(string baseFolder, EnumerationOptions enumerationOptions);
    IEnumerable<string> GetEntries(string baseFolder, string searchPattern, EnumerationOptions enumerationOptions);
    IEnumerable<string> GetFiles(string baseFolder);
    IEnumerable<string> GetFiles(string baseFolder, string searchPattern);
    IEnumerable<string> GetFiles(string baseFolder, EnumerationOptions enumerationOptions);
    IEnumerable<string> GetFiles(string baseFolder, string searchPattern, EnumerationOptions enumerationOptions);
    IEnumerable<string> GetFolders(string baseFolder);
    IEnumerable<string> GetFolders(string baseFolder, string searchPattern);
    IEnumerable<string> GetFolders(string baseFolder, EnumerationOptions enumerationOptions);
    IEnumerable<string> GetFolders(string baseFolder, string searchPattern, EnumerationOptions enumerationOptions);
    void MoveFile(string sourcePath, string targetPath, bool overwrite = false);
    Stream OpenFileAsReadOnly(string filePath, bool blockExternalAccess = true);
    Stream OpenOrCreateFile(string filePath, bool blockExternalAccess = true);
}

[ExcludeFromCodeCoverage(Justification = "Thin wrapper for OS functionality.")]
// ReSharper disable once ClassWithVirtualMembersNeverInherited.Global - Used for externally.
public class FileSystem : HasDefault<FileSystem>, IFileSystem {
    public virtual char DirectorySeparatorChar => Path.DirectorySeparatorChar;
    public virtual string CombinePath(params string[] paths) => Path.Combine(paths);
    public virtual string[] GetFilePath(string filePath)
        => [.. Path.GetDirectoryName(filePath)?.Split(DirectorySeparatorChar) ?? [], GetFileName(filePath, true)];
    public virtual string GetFileName(string filePath, bool includeExtension = false)
        => includeExtension
               ? Path.GetFileName(filePath)
               : Path.GetFileNameWithoutExtension(filePath);
    public virtual string GetFileExtension(string filePath, bool includeDot = true)
        => includeDot
               ? Path.GetExtension(filePath)
               : Path.GetExtension(filePath).TrimStart('.');

    public virtual string CurrentFolder {
        get => Directory.GetCurrentDirectory();
        set => Directory.SetCurrentDirectory(value);
    }

    public virtual bool FolderExists(string folderPath)
        => Directory.Exists(folderPath);

    private static readonly EnumerationOptions _defaultEnumerationOptions = new();
    private static IEnumerable<string> GetFileSystemEntries(string baseFolder, SearchTarget target, string searchPattern = "*", EnumerationOptions? enumerationOptions = null) {
        baseFolder += IsNotNullOrWhiteSpace(baseFolder)[^1] is '\\' or '/' ? string.Empty : '\\';
        var list = target switch {
            SearchTarget.File => Directory.EnumerateFiles(baseFolder, searchPattern, enumerationOptions ?? _defaultEnumerationOptions),
            SearchTarget.Folder => Directory.EnumerateDirectories(baseFolder, searchPattern, enumerationOptions ?? _defaultEnumerationOptions),
            _ => Directory.EnumerateFileSystemEntries(baseFolder, searchPattern, enumerationOptions ?? _defaultEnumerationOptions),
        };
        return list.Select(f => f[baseFolder.Length..]);
    }

    private enum SearchTarget {
        Both,
        File,
        Folder,
    }

    public virtual IEnumerable<string> GetEntries(string baseFolder)
        => GetFileSystemEntries(baseFolder, SearchTarget.Both);

    public virtual IEnumerable<string> GetEntries(string baseFolder, string searchPattern)
        => GetFileSystemEntries(baseFolder, SearchTarget.Both, searchPattern);
    public virtual IEnumerable<string> GetEntries(string baseFolder, EnumerationOptions enumerationOptions)
        => GetFileSystemEntries(baseFolder, SearchTarget.Both, enumerationOptions: enumerationOptions);
    public virtual IEnumerable<string> GetEntries(string baseFolder, string searchPattern, EnumerationOptions enumerationOptions)
        => GetFileSystemEntries(baseFolder, SearchTarget.Both, searchPattern, enumerationOptions);
    public virtual IEnumerable<string> GetFiles(string baseFolder)
        => GetFileSystemEntries(baseFolder, SearchTarget.File);
    public virtual IEnumerable<string> GetFiles(string baseFolder, string searchPattern)
        => GetFileSystemEntries(baseFolder, SearchTarget.File, searchPattern);
    public virtual IEnumerable<string> GetFiles(string baseFolder, EnumerationOptions enumerationOptions)
        => GetFileSystemEntries(baseFolder, SearchTarget.File, enumerationOptions: enumerationOptions);
    public virtual IEnumerable<string> GetFiles(string baseFolder, string searchPattern, EnumerationOptions enumerationOptions)
        => GetFileSystemEntries(baseFolder, SearchTarget.File, searchPattern, enumerationOptions);
    public virtual IEnumerable<string> GetFolders(string baseFolder)
        => GetFileSystemEntries(baseFolder, SearchTarget.Folder);
    public virtual IEnumerable<string> GetFolders(string baseFolder, string searchPattern)
        => GetFileSystemEntries(baseFolder, SearchTarget.Folder, searchPattern);
    public virtual IEnumerable<string> GetFolders(string baseFolder, EnumerationOptions enumerationOptions)
        => GetFileSystemEntries(baseFolder, SearchTarget.Folder, enumerationOptions: enumerationOptions);
    public virtual IEnumerable<string> GetFolders(string baseFolder, string searchPattern, EnumerationOptions enumerationOptions)
        => GetFileSystemEntries(baseFolder, SearchTarget.Folder, searchPattern, enumerationOptions);

    public virtual char FolderSeparator => Path.DirectorySeparatorChar;
    public virtual void CreateFolder(string folderPath)
        => Directory.CreateDirectory(folderPath);
    public virtual void DeleteFolder(string folderPath, bool includeAllContent = false)
        => Directory.Delete(folderPath, includeAllContent);

    public virtual bool FileExists(string filePath) => File.Exists(filePath);
    public virtual void MoveFile(string sourcePath, string targetPath, bool overwrite = false) => File.Move(sourcePath, targetPath, overwrite);
    public virtual void CopyFile(string sourcePath, string targetPath, bool overwrite = false) => File.Copy(sourcePath, targetPath, overwrite);
    public virtual void DeleteFile(string sourcePath) => File.Delete(sourcePath);

    public virtual Stream OpenFileAsReadOnly(string filePath, bool blockExternalAccess = true) => new FileStream(filePath, FileMode.Open, FileAccess.Read, blockExternalAccess ? FileShare.None : FileShare.ReadWrite);
    public virtual Stream OpenOrCreateFile(string filePath, bool blockExternalAccess = true) => new FileStream(filePath, FileMode.OpenOrCreate, FileAccess.ReadWrite, blockExternalAccess ? FileShare.None : FileShare.Read);
    public virtual Stream CreateNewOrOverwriteFile(string filePath, bool blockExternalAccess = true) => new FileStream(filePath, FileMode.Create, FileAccess.ReadWrite, blockExternalAccess ? FileShare.None : FileShare.Read);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\GlobalUsings.cs 
// Global using directives

global using System.Collections;
global using System.Diagnostics;
global using System.Diagnostics.CodeAnalysis;
global using System.Globalization;
global using System.Linq.Expressions;
global using System.Net;
global using System.Reflection;
global using System.Runtime.CompilerServices;
global using System.Text;
global using System.Text.RegularExpressions;

global using DotNetToolbox.Results;
global using DotNetToolbox.Singleton;

global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.DependencyInjection.Extensions;

global using static System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes;
global using static DotNetToolbox.Constants.Messages;
global using static DotNetToolbox.Ensure;

global using Syntax = System.Diagnostics.CodeAnalysis.StringSyntaxAttribute;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\GuidProvider.cs 
﻿namespace DotNetToolbox;

public interface IGuidProvider {
    Guid New();
    Guid New(byte[] bytes);
    Guid New(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    Guid New(int a, short b, short c, byte[] d);
    Guid New(ReadOnlySpan<byte> bytes);
    Guid New(ReadOnlySpan<byte> bytes, bool bigEndian);
    Guid New(string text);
    Guid New(uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    Guid Parse(ReadOnlySpan<char> input);
    Guid Parse(ReadOnlySpan<char> s, IFormatProvider? provider);
    Guid Parse(string input);
    Guid Parse(string s, IFormatProvider? provider);
    Guid ParseExact(ReadOnlySpan<char> input, [Syntax("GuidFormat")] ReadOnlySpan<char> format);
    Guid ParseExact(string input, [Syntax("GuidFormat")] string format);
    bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Guid result);
    bool TryParse(ReadOnlySpan<char> input, out Guid result);
    bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out Guid result);
    bool TryParse([NotNullWhen(true)] string? input, out Guid result);
    bool TryParseExact(ReadOnlySpan<char> input, [Syntax("GuidFormat")] ReadOnlySpan<char> format, out Guid result);
    bool TryParseExact([NotNullWhen(true)] string? input, [NotNullWhen(true), Syntax("GuidFormat")] string? format, out Guid result);
}

[ExcludeFromCodeCoverage(Justification = "Thin wrapper for OS functionality.")]
// ReSharper disable once ClassWithVirtualMembersNeverInherited.Global - Used for externally.
public class GuidProvider : HasDefault<GuidProvider>, IGuidProvider {
    public virtual Guid New() => Guid.NewGuid();
    public virtual Guid New(string text) => new(text);
    public virtual Guid New(byte[] bytes) => new(bytes);
    public virtual Guid New(ReadOnlySpan<byte> bytes) => new(bytes);
    public virtual Guid New(ReadOnlySpan<byte> bytes, bool bigEndian) => new(bytes, bigEndian);
    public virtual Guid New(uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k)
        => new(a, b, c, d, e, f, g, h, i, j, k);
    public virtual Guid New(int a, short b, short c, byte[] d)
        => new(a, b, c, d);
    public virtual Guid New(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k)
        => new(a, b, c, d, e, f, g, h, i, j, k);

    public virtual Guid Parse(string input) => Guid.Parse(input);
    public virtual Guid Parse(ReadOnlySpan<char> input) => Guid.Parse(input);
    public virtual Guid Parse(string s, IFormatProvider? provider) => Guid.Parse(s, provider);
    public virtual Guid Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => Guid.Parse(s, provider);

    public virtual Guid ParseExact(string input, [Syntax(Syntax.GuidFormat)] string format)
        => Guid.ParseExact(input, format);
    public virtual Guid ParseExact(ReadOnlySpan<char> input, [Syntax(Syntax.GuidFormat)] ReadOnlySpan<char> format)
        => Guid.ParseExact(input, format);

    public virtual bool TryParse([NotNullWhen(true)] string? input, out Guid result)
        => Guid.TryParse(input, out result);
    public virtual bool TryParse(ReadOnlySpan<char> input, out Guid result)
        => Guid.TryParse(input, out result);
    public virtual bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out Guid result)
        => Guid.TryParse(s, provider, out result);
    public virtual bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Guid result)
        => Guid.TryParse(s, provider, out result);

    public virtual bool TryParseExact([NotNullWhen(true)] string? input, [NotNullWhen(true), Syntax(Syntax.GuidFormat)] string? format, out Guid result)
        => Guid.TryParseExact(input, format, out result);
    public virtual bool TryParseExact(ReadOnlySpan<char> input, [Syntax(Syntax.GuidFormat)] ReadOnlySpan<char> format, out Guid result)
        => Guid.TryParseExact(input, format, out result);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\IndexedItem.cs 
﻿namespace DotNetToolbox;

public record Indexed<TValue>(uint Index, TValue Value);

public record IndexedItem<TValue>(uint Index, TValue Value, bool IsLast) : Indexed<TValue>(Index, Value) {
    public bool IsFirst => Index == 0;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Input.cs 
﻿namespace DotNetToolbox;

public interface IInput {
    Encoding Encoding { get; set; }
    TextReader Reader { get; }

    bool KeyAvailable();
    int Read();
    ConsoleKeyInfo ReadKey(bool intercept = false);
    string? ReadLine();
    string ReadMultiLine(ConsoleKey submitKey = ConsoleKey.Enter, ConsoleModifiers submitKeyModifiers = ConsoleModifiers.None);
}

[ExcludeFromCodeCoverage(Justification = "Thin wrapper for Console functionality.")]
// ReSharper disable once ClassWithVirtualMembersNeverInherited.Global - Used for externally.
public class Input() : HasDefault<Input>, IInput {
    private readonly IOutput _output = new Output();

    public Input(IOutput output) : this() {
        _output = output;
    }

    public virtual Encoding Encoding {
        get => Console.InputEncoding;
        set => Console.InputEncoding = value;
    }

    public virtual TextReader Reader => Console.In;

    public virtual bool KeyAvailable() => Console.KeyAvailable;
    public virtual int Read() => Reader.Read();
    public virtual ConsoleKeyInfo ReadKey(bool intercept = false) => Console.ReadKey(intercept);
    public virtual string? ReadLine() => Reader.ReadLine()!; // ReadLine is only null when the stream is closed.

    public virtual string ReadMultiLine(ConsoleKey submitKey = ConsoleKey.Enter, ConsoleModifiers submitKeyModifiers = ConsoleModifiers.None) {
        var promptLength = Console.CursorLeft;
        var currentLine = new StringBuilder();
        var lines = new List<string>();
        for (var key = ReadKey(intercept: true); !IsSubmitKey(key, submitKey, submitKeyModifiers); key = ReadKey(intercept: true)) {
            if (TryProcessLineBreak(key, currentLine, lines)) continue;
            if (TryProcessBackspace(key, currentLine, lines, promptLength: promptLength)) continue;
            if (TryProcessSpecialKeys(key)) continue;
            TryAddCharacter(key, currentLine);
        }

        AddLineBreak(currentLine);
        lines.Add(currentLine.ToString());
        return string.Join(_output.NewLine, lines);
    }

    private static bool TryProcessSpecialKeys(ConsoleKeyInfo keyInfo)
        => keyInfo.Key is ConsoleKey.LeftArrow or ConsoleKey.RightArrow or ConsoleKey.Home or ConsoleKey.End or ConsoleKey.PageUp or ConsoleKey.PageDown;

    private bool TryProcessBackspace(ConsoleKeyInfo keyInfo, StringBuilder currentLine, List<string> lines, int promptLength)
    {
        if (keyInfo.Key != ConsoleKey.Backspace) return false;
        if (currentLine.Length > 0) {
            currentLine.Remove(currentLine.Length - 1, 1);
            _output.Write("\b \b");
            return true;
        }

        if (lines.Count <= 0) return true;

        currentLine.Append(lines[^1][..^_output.NewLine.Length]);
        lines.RemoveAt(lines.Count - 1);
        Console.CursorTop--;
        Console.CursorLeft = currentLine.Length + (lines.Count == 0 ?  promptLength : 0);
        return true;

    }

    private bool TryProcessLineBreak(ConsoleKeyInfo keyInfo, StringBuilder currentLine, List<string> lines)
    {
        if (!IsLineBreakKey(keyInfo)) return false;
        AddLineBreak(currentLine);
        lines.Add(currentLine.ToString());
        currentLine.Clear();
        return true;

    }

    private static bool IsLineBreakKey(ConsoleKeyInfo keyInfo)
        => keyInfo.Key == ConsoleKey.Enter;

    private static bool IsSubmitKey(ConsoleKeyInfo keyInfo, ConsoleKey submitKey, ConsoleModifiers submitKeyModifiers)
        => keyInfo.Key == submitKey && keyInfo.Modifiers.HasFlag(submitKeyModifiers);

    private bool TryAddCharacter(ConsoleKeyInfo keyInfo, StringBuilder inputBuilder) {
        if (char.IsControl(keyInfo.KeyChar)) return false;
        _output.Write(keyInfo.KeyChar);
        inputBuilder.Append(keyInfo.KeyChar);
        return true;
    }

    private void AddLineBreak(StringBuilder inputBuilder) {
        _output.WriteLine();
        inputBuilder.AppendLine();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Output.cs 
﻿namespace DotNetToolbox;

public interface IOutput {
    string Prompt { get; set; }
    ConsoleColor BackgroundColor { get; set; }
    Encoding Encoding { get; set; }
    TextWriter Error { get; }
    ConsoleColor ForegroundColor { get; set; }
    TextWriter Writer { get; }

    void ClearScreen();
    void ResetColor();
    void Write(bool value);
    void Write(char value);
    void Write(char[] buffer, int index, int count);
    void Write(char[]? buffer);
    void Write(decimal value);
    void Write(double value);
    void Write(float value);
    void Write(int value);
    void Write(long value);
    void Write(object? value);
    void Write([Syntax(Syntax.CompositeFormat)] string format, object? arg0);
    void Write([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1);
    void Write([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1, object? arg2);
    void Write([Syntax(Syntax.CompositeFormat)] string format, params object?[] arg);
    void Write(string? value);
    void Write(StringBuilder? builder);
    void Write(uint value);
    void Write(ulong value);
    void WritePrompt();

    string NewLine { get; }
    void WriteLine();
    void WriteLine(bool value);
    void WriteLine(char value);
    void WriteLine(char[] buffer, int index, int count);
    void WriteLine(char[]? buffer);
    void WriteLine(decimal value);
    void WriteLine(double value);
    void WriteLine(float value);
    void WriteLine(int value);
    void WriteLine(long value);
    void WriteLine(object? value);
    void WriteLine([Syntax(Syntax.CompositeFormat)] string format, object? arg0);
    void WriteLine([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1);
    void WriteLine([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1, object? arg2);
    void WriteLine([Syntax(Syntax.CompositeFormat)] string format, params object?[] arg);
    void WriteLine(string? value);
    void WriteLine(StringBuilder? builder);
    void WriteLine(uint value);
    void WriteLine(ulong value);
}

[ExcludeFromCodeCoverage(Justification = "Thin wrapper for Console functionality.")]
// ReSharper disable once ClassWithVirtualMembersNeverInherited.Global - Used for externally.
public class Output : HasDefault<Output>, IOutput {
    public virtual string Prompt { get; set; } = "> ";

    public virtual Encoding Encoding {
        get => Console.OutputEncoding;
        set => Console.OutputEncoding = value;
    }

    public virtual ConsoleColor ForegroundColor {
        get => Console.ForegroundColor;
        set => Console.ForegroundColor = value;
    }
    public virtual ConsoleColor BackgroundColor {
        get => Console.BackgroundColor;
        set => Console.BackgroundColor = value;
    }

    public virtual TextWriter Writer => Console.Out;
    public virtual TextWriter Error => Console.Error;

    public virtual void ResetColor() => Console.ResetColor();
    public virtual void ClearScreen() => Console.Clear();

    public virtual void Write(bool value) => Console.Write(value);
    public virtual void Write(ulong value) => Console.Write(value);
    public virtual void Write(uint value) => Console.Write(value);
    public virtual void Write(long value) => Console.Write(value);
    public virtual void Write(int value) => Console.Write(value);
    public virtual void Write(float value) => Console.Write(value);
    public virtual void Write(double value) => Console.Write(value);
    public virtual void Write(decimal value) => Console.Write(value);
    public virtual void Write(char value) => Console.Write(value);
    public virtual void Write(string? value) => Console.Write(value);
    public virtual void Write(object? value) => Console.Write(value);

    public virtual void Write(StringBuilder? builder) => Console.Write(builder);

    public virtual void Write([Syntax(Syntax.CompositeFormat)] string format, object? arg0) => Console.Write(format, arg0);
    public virtual void Write([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1) => Console.Write(format, arg0, arg1);
    public virtual void Write([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1, object? arg2) => Console.Write(format, arg0, arg1, arg2);
    public virtual void Write([Syntax(Syntax.CompositeFormat)] string format, params object?[] arg) => Console.Write(format, arg);

    public virtual void Write(char[]? buffer) => Console.Write(buffer);
    public virtual void Write(char[] buffer, int index, int count) => Console.Write(buffer, index, count);

    public virtual void WritePrompt() => Console.Write(Prompt);
    public virtual string NewLine => System.Environment.NewLine;
    public virtual void WriteLine() => Console.WriteLine();

    public virtual void WriteLine(bool value) => Console.WriteLine(value);
    public virtual void WriteLine(uint value) => Console.WriteLine(value);
    public virtual void WriteLine(ulong value) => Console.WriteLine(value);
    public virtual void WriteLine(int value) => Console.WriteLine(value);
    public virtual void WriteLine(long value) => Console.WriteLine(value);
    public virtual void WriteLine(float value) => Console.WriteLine(value);
    public virtual void WriteLine(double value) => Console.WriteLine(value);
    public virtual void WriteLine(decimal value) => Console.WriteLine(value);
    public virtual void WriteLine(char value) => Console.WriteLine(value);
    public virtual void WriteLine(string? value) => Console.WriteLine(value);
    public virtual void WriteLine(object? value) => Console.WriteLine(value);

    public virtual void WriteLine(StringBuilder? builder) => Console.WriteLine(builder);

    public virtual void WriteLine([Syntax(Syntax.CompositeFormat)] string format, object? arg0) => Console.WriteLine(format, arg0);
    public virtual void WriteLine([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1) => Console.WriteLine(format, arg0, arg1);
    public virtual void WriteLine([Syntax(Syntax.CompositeFormat)] string format, object? arg0, object? arg1, object? arg2) => Console.WriteLine(format, arg0, arg1, arg2);
    public virtual void WriteLine([Syntax(Syntax.CompositeFormat)] string format, params object?[] arg) => Console.WriteLine(format, arg);

    public virtual void WriteLine(char[]? buffer) => Console.WriteLine(buffer);
    public virtual void WriteLine(char[] buffer, int index, int count) => Console.WriteLine(buffer, index, count);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\OutputVerboseLevel.cs 
﻿namespace DotNetToolbox;

public enum OutputVerboseLevel {
    Trace = -2,
    Debug = -1,
    Default = 0,
    Detailed = 1,
    Warning = 2,
    Error = 3,
    Critical = 4,
    Silent = 5,
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\UrlSafeBase64String.cs 
﻿namespace DotNetToolbox;

public readonly partial record struct UrlSafeBase64String {
    public UrlSafeBase64String() {
        Bytes = [];
    }

    public UrlSafeBase64String(byte[]? input = null) {
        Bytes = input ?? [];
    }

    public UrlSafeBase64String(Guid input) {
        Bytes = input.ToByteArray();
    }

    public UrlSafeBase64String(string input) {
        input = input?.Trim() ?? string.Empty;
        Bytes = _safeBase64String.IsMatch(input)
            ? ToBytes(input)
            : Encoding.UTF8.GetBytes(input);
    }

    public byte[] Bytes { get; }
    public string Text => Encoding.UTF8.GetString(Bytes);
    public string Base64 => ToBase64(Bytes);
    public bool IsGuid => Bytes.Length is 0 or 16;
    public Guid Guid => Bytes.Length switch {
        0 => Guid.Empty,
        16 => new(Bytes),
        _ => throw new FormatException("The value is not a valid GUID."),
    };

    public static implicit operator UrlSafeBase64String(byte[]? input) => new(input);
    public static implicit operator UrlSafeBase64String(string input) => new(input);
    public static implicit operator UrlSafeBase64String(Guid input) => new(input);
    public static implicit operator byte[](UrlSafeBase64String input) => input.Bytes;
    public static implicit operator string(UrlSafeBase64String input) => input.Base64;
    public static implicit operator Guid(UrlSafeBase64String input) => input.Guid;

    private static string ToBase64(byte[] bytes)
        => bytes.Length == 0
        ? string.Empty
        : ToSafeBase64(bytes);

    private static string ToSafeBase64(byte[] bytes) {
        var base64 = Convert.ToBase64String(bytes);
        var builder = new StringBuilder(base64.TrimEnd('='));
        builder.Replace('+', '-');
        builder.Replace('/', '_');
        return builder.ToString();
    }

    private static byte[] ToBytes(string input)
        => Convert.FromBase64String(ToStandardBase64(input));

    private static string ToStandardBase64(string input) {
        var builder = new StringBuilder(input.Trim());
        builder.Replace('_', '/');
        builder.Replace('-', '+');
        builder.Append('=', 24 - (input.Length % 24));
        return builder.ToString();
    }

    private static readonly Regex _safeBase64String = SafeBase64String();
    [GeneratedRegex("^[a-zA-Z0-9_-]{22}$", RegexOptions.Compiled)]
    private static partial Regex SafeBase64String();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Collections\Generic\EnumerableExtensions.cs 
﻿namespace DotNetToolbox.Collections.Generic;

public static class EnumerableExtensions {

    #region Projections

    public static IEnumerable<TItem> As<TItem>(this IEnumerable source) => source.Cast<TItem>();
    public static IEnumerable<TOutput> As<TItem, TOutput>(this IEnumerable source, Func<TItem, TOutput> transform) => source.Cast<TItem>().Select(transform);

    public static TOutput[] ToArray<TItem, TOutput>(this IEnumerable<TItem> source, Func<TItem, TOutput> transform)
        => [.. IsNotNull(source).Select(transform)];

    public static List<TOutput> ToList<TItem, TOutput>(this IEnumerable<TItem> source, Func<TItem, TOutput> transform)
        => [.. IsNotNull(source).Select(transform)];

    public static Dictionary<TKey, TOutputValue> ToDictionary<TKey, TInputValue, TOutputValue>(this IEnumerable<KeyValuePair<TKey, TInputValue>> source, Func<TInputValue, TOutputValue> transformValue)
        where TKey : notnull
        => IsNotNull(source).ToDictionary(i => i.Key, i => transformValue(i.Value));

    public static Dictionary<TKey, TValue> ToDictionary<TInput, TOutput, TKey, TValue>(this IEnumerable<TInput> source, Func<TInput, TOutput> transformElement, Func<TOutput, TKey> selectKey, Func<TOutput, TValue> selectValue)
        where TKey : notnull
        => IsNotNull(source).Select(transformElement).ToDictionary(selectKey, selectValue);

    public static HashSet<TOutput> ToHashSet<TItem, TOutput>(this IEnumerable<TItem> source, Func<TItem, TOutput> transform)
        => [.. IsNotNull(source).Select(transform)];

    #endregion

    #region With Index

    public static IEnumerable<Indexed<TItem>> AsIndexed<TItem>(this IEnumerable source) => source.Cast<TItem>().AsIndexed();

    public static IEnumerable<Indexed<TOutput>> AsIndexed<TItem, TOutput>(this IEnumerable source, Func<TItem, TOutput> transform) => source.Cast<TItem>().AsIndexed(transform);

    public static IEnumerable<Indexed<TItem>> AsIndexed<TItem>(this IEnumerable<TItem> source) => source.AsIndexed(i => i);

    public static IEnumerable<Indexed<TOutput>> AsIndexed<TItem, TOutput>(this IEnumerable<TItem> source, Func<TItem, TOutput> transform) => source.Select((v, i) => new Indexed<TOutput>((uint)i, transform(v)));

    public static IReadOnlyList<IndexedItem<TItem>> ToIndexedItems<TItem>(this IEnumerable<TItem> source)
        => source.ToIndexedItems(i => i);

    public static IReadOnlyList<IndexedItem<TOutput>> ToIndexedItems<TItem, TOutput>(this IEnumerable<TItem> source, Func<TItem, TOutput> transform) {
        using var enumerator = source.GetEnumerator();
        var list = new List<IndexedItem<TOutput>>();
        var index = 0u;
        var hasNext = enumerator.MoveNext();
        while (hasNext) {
            var value = transform(enumerator.Current);
            hasNext = enumerator.MoveNext();
            list.Add(new(index++, value, !hasNext));
        }
        return list.AsReadOnly();
    }

    #endregion
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Collections\Generic\QueryableExtensions.cs 
﻿namespace DotNetToolbox.Collections.Generic;

public static class QueryableExtensions {
    public static TOutput[] ToArray<TItem, TOutput>(this IQueryable<TItem> source, Expression<Func<TItem, TOutput>> project)
        => [.. IsNotNull(source).Select(project)];

    public static Dictionary<TKey, TValue> ToDictionary<TInput, TKey, TValue>(this IQueryable<TInput> source, Expression<Func<TInput, TInput>> project, Func<TInput, TKey> selectKey, Func<TInput, TValue> selectValue)
        where TKey : notnull
        => ToDictionary<TInput, TInput, TKey, TValue>(source, project, selectKey, selectValue);
    public static Dictionary<TKey, TValue> ToDictionary<TInput, TOutput, TKey, TValue>(this IQueryable<TInput> source, Expression<Func<TInput, TOutput>> project, Func<TOutput, TKey> selectKey, Func<TOutput, TValue> selectValue)
        where TKey : notnull
        => IsNotNull(source).Select(project).ToDictionary(selectKey, selectValue);

    public static HashSet<TItem> ToHashSet<TItem>(this IQueryable<TItem> source, Expression<Func<TItem, TItem>> project)
        => ToHashSet<TItem, TItem>(source, project);

    public static HashSet<TOutput> ToHashSet<TItem, TOutput>(this IQueryable<TItem> source, Expression<Func<TItem, TOutput>> project)
        => [.. IsNotNull(source).Select(project)];
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Constants\Messages.cs 
﻿namespace DotNetToolbox.Constants;

public static class Messages {
    public const string GenericError = "An error ocurred while executing the operation.";
    public const string ValueMustBeOfType = "Expected value to be of type '{0}'. Found: '{1}'.";

    public const string ValueCannotBeNull = "The value cannot be null.";
    public const string StringCannotBeNullOrEmpty = "The string cannot be null or empty.";
    public const string StringCannotBeNullOrWhiteSpace = "The string cannot be null or white space.";
    public const string ValueIsInvalid = "The value is invalid.";

    public const string CollectionCannotBeEmpty = "The collection cannot be empty.";
    public const string CollectionContainsInvalid = "The collection contains invalid element(s).";
    public const string CollectionContainsNull = "The collection contains null element(s).";
    public const string CollectionContainsNullOrEmpty = "The collection contains null or empty string(s).";
    public const string CollectionContainsNullOrWhiteSpace = "The collection contains null or white space string(s).";
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\DependencyInjection\ServiceCollectionExtensions.cs 
﻿namespace DotNetToolbox.DependencyInjection;

public static class ServiceCollectionExtensions {
    private static void SetEnvironmentFrom(
        this IServiceCollection services,
        IAssemblyDescriptor? assemblyDescriptor = null,
        IDateTimeProvider? dateTimeProvider = null,
        IGuidProvider? guidProvider = null,
        IFileSystem? fileSystem = null,
        IInput? input = null,
        IOutput? output = null) {
        services.AddAssemblyDescriptor(assemblyDescriptor);
        services.AddDateTimeProvider(dateTimeProvider);
        services.AddGuidProvider(guidProvider);
        services.AddFileSystem(fileSystem);
        services.AddInput(input);
        services.AddOutput(output);
    }

    public static IServiceCollection AddEnvironment(
        this IServiceCollection services,
        string? name = null,
        IAssemblyDescriptor? assemblyDescriptor = null,
        IDateTimeProvider? dateTimeProvider = null,
        IGuidProvider? guidProvider = null,
        IFileSystem? fileSystem = null,
        IInput? input = null,
        IOutput? output = null) {
        services.SetEnvironmentFrom(assemblyDescriptor,
                                    dateTimeProvider,
                                    guidProvider,
                                    fileSystem,
                                    input,
                                    output);
        services.TryAddSingleton<IEnvironment>(prv => new Environment(prv, name));
        return services;
    }

    public static IServiceCollection AddEnvironment(this IServiceCollection services, IEnvironment environment) {
        services.SetEnvironmentFrom(environment.Assembly,
                                    environment.DateTime,
                                    environment.Guid,
                                    environment.FileSystem,
                                    environment.Input,
                                    environment.Output);
        services.TryAddSingleton(IsNotNull(environment));
        return services;
    }

    public static IServiceCollection AddAssemblyDescriptor(this IServiceCollection services, IAssemblyDescriptor? descriptor = null) {
        services.TryAddSingleton(descriptor ?? AssemblyDescriptor.Default);
        return services;
    }

    public static IServiceCollection AddDateTimeProvider(this IServiceCollection services, IDateTimeProvider? provider = null) {
        services.TryAddSingleton(provider ?? DateTimeProvider.Default);
        return services;
    }

    public static IServiceCollection AddGuidProvider(this IServiceCollection services, IGuidProvider? provider = null) {
        services.TryAddSingleton(provider ?? GuidProvider.Default);
        return services;
    }

    public static IServiceCollection AddFileSystem(this IServiceCollection services, IFileSystem? provider = null) {
        services.TryAddSingleton(provider ?? FileSystem.Default);
        return services;
    }

    public static IServiceCollection AddInput(this IServiceCollection services, IInput? provider = null) {
        services.TryAddSingleton(provider ?? Input.Default);
        return services;
    }

    public static IServiceCollection AddOutput(this IServiceCollection services, IOutput? provider = null) {
        services.TryAddSingleton(provider ?? Output.Default);
        return services;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Pagination\Block.cs 
﻿namespace DotNetToolbox.Pagination;

public class Block<TItem>
    : Block<TItem, TItem>,
      IBlock<TItem> {
    [SetsRequiredMembers]
    public Block() {
    }

    [SetsRequiredMembers]
    public Block(IReadOnlyList<TItem> items, TItem offset, uint size = BlockSettings.DefaultBlockSize)
        : base(items, offset, size) {
    }
}

public class Block<TItem, TOffset>
    : IBlock<TItem, TOffset> {
    [SetsRequiredMembers]
    public Block() {
        Items = Array.Empty<TItem>();
        Offset = default!;
    }

    [SetsRequiredMembers]
    public Block(IReadOnlyList<TItem> items, TOffset offset, uint size = BlockSettings.DefaultBlockSize) {
        Items = IsNotNull(items);
        Offset = offset;
        Size = size;
    }

    public required IReadOnlyList<TItem> Items { get; init; }
    public required TOffset Offset { get; init; }
    public uint Size { get; init; } = BlockSettings.DefaultBlockSize;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Pagination\BlockSettings.cs 
﻿namespace DotNetToolbox.Pagination;

public static class BlockSettings {
    public const uint MaxSize = 1_000;
    public const uint MinSize = 1;
    public const uint MaxCount = 1_000_000_000;
    public const uint MaxIndex = 999_999_999;

    public const uint DefaultBlockSize = 20;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Pagination\IBlock.cs 
﻿namespace DotNetToolbox.Pagination;

public interface IBlock<out TItem> : IBlock<TItem, TItem>;

public interface IBlock<out TItem, out TOffset> {
    uint Size { get; }
    TOffset Offset { get; }
    IReadOnlyList<TItem> Items { get; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Pagination\IPage.cs 
﻿namespace DotNetToolbox.Pagination;

public interface IPage<out TItem> : IBlock<TItem, uint> {
    uint TotalCount { get; init; }
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Pagination\Page.cs 
﻿namespace DotNetToolbox.Pagination;

public class Page<TItem>
    : Block<TItem, uint>,
      IPage<TItem> {
    [SetsRequiredMembers]
    public Page() {
    }

    [SetsRequiredMembers]
    public Page(IReadOnlyList<TItem> items, uint offset = 0, uint size = BlockSettings.DefaultBlockSize, uint totalCount = 0)
        : base(items, offset, size) {
        TotalCount = totalCount;
    }

    public uint TotalCount { get; init; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\CrudResult.cs 
﻿namespace DotNetToolbox.Results;

public record CrudResult : ResultBase<CrudResultType> {
    private readonly CrudResultType _type = CrudResultType.Success;

    protected CrudResult(Exception exception)
        : base(exception) {
    }

    protected CrudResult(CrudResultType type, IEnumerable<ValidationError>? errors = null)
        : base(errors) {
        _type = type;
    }

    public override CrudResultType Type => HasException
        ? CrudResultType.Error
        : HasErrors
            ? CrudResultType.Invalid
            : _type;

    public bool IsSuccess => Type is CrudResultType.Success;
    public bool IsInvalid => Type is CrudResultType.Invalid;
    public bool IsFaulty => Type is CrudResultType.Error;
    public bool WasNotFound => Type is CrudResultType.NotFound;
    public bool HasConflict => Type is CrudResultType.Conflict;

    public static CrudResult Success() => new(CrudResultType.Success);
    public static CrudResult NotFound() => new(CrudResultType.NotFound);
    public static CrudResult Conflict() => new(CrudResultType.Conflict);
    public static CrudResult Invalid(Result result) => new(CrudResultType.Invalid, result.Errors);
    public static CrudResult Error(string error) => Error(new Exception(error));
    public static CrudResult Error(Exception exception) => new(exception);

    public static Task<CrudResult> SuccessTask() => Task.FromResult(Success());
    public static Task<CrudResult> NotFoundTask() => Task.FromResult(NotFound());
    public static Task<CrudResult> ConflictTask() => Task.FromResult(Conflict());
    public static Task<CrudResult> InvalidTask(Result result) => Task.FromResult(Invalid(result));
    public static Task<CrudResult> ErrorTask(string error) => ErrorTask(new Exception(error));
    public static Task<CrudResult> ErrorTask(Exception exception) => Task.FromResult(Error(exception));

    public static implicit operator CrudResult(Exception exception) => new(exception);
    public static implicit operator CrudResult(string error) => (Result)error;
    public static implicit operator CrudResult(ValidationError error) => (Result)error;
    public static implicit operator CrudResult(ValidationErrors errors) => (Result)errors;
    public static implicit operator CrudResult(ValidationError[] errors) => (Result)errors;
    public static implicit operator CrudResult(List<ValidationError> errors) => (Result)errors;
    public static implicit operator CrudResult(HashSet<ValidationError> errors) => (Result)errors;
    public static implicit operator CrudResult(Result result) => new(CrudResultType.Success, result.Errors);
    public static implicit operator ValidationErrors(CrudResult result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator ValidationError[](CrudResult result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator Exception?(CrudResult result) => result.Exception;

    public static CrudResult operator +(CrudResult left, Result right)
        => left.HasException
               ? left
               : right.HasException
                   ? new(right.Exception)
                   : new(left._type, left.Errors.Union(right.Errors));

    public static CrudResult<TValue> Success<TValue>(TValue value) => new(CrudResultType.Success, value);
    public static CrudResult<TValue> NotFound<TValue>() => new(CrudResultType.NotFound);
    public static CrudResult<TValue> Conflict<TValue>(TValue value) => new(CrudResultType.Conflict, value);
    public static CrudResult<TValue> Invalid<TValue>(TValue? value, Result result) => new(CrudResultType.Invalid, value, result.Errors);
    public static CrudResult<TValue> Error<TValue>(string error) => Error<TValue>(new Exception(error));
    public static CrudResult<TValue> Error<TValue>(Exception exception) => new(exception);

    public static Task<CrudResult<TValue>> SuccessTask<TValue>(TValue value) => Task.FromResult(Success(value));
    public static Task<CrudResult<TValue>> NotFoundTask<TValue>() => Task.FromResult(NotFound<TValue>());
    public static Task<CrudResult<TValue>> ConflictTask<TValue>(TValue value) => Task.FromResult(Conflict(value));
    public static Task<CrudResult<TValue>> InvalidTask<TValue>(TValue? value, Result result) => Task.FromResult(Invalid(value, result));
    public static Task<CrudResult<TValue>> ErrorTask<TValue>(string error) => ErrorTask<TValue>(new Exception(error));
    public static Task<CrudResult<TValue>> ErrorTask<TValue>(Exception exception) => Task.FromResult(Error<TValue>(exception));
}

public record CrudResult<TValue> : CrudResult, IResult<CrudResultType, TValue> {
    private readonly CrudResultType _type = CrudResultType.Success;

    internal CrudResult(Exception exception)
        : base(exception) {
    }

    internal CrudResult(CrudResultType type, TValue? value = default, IEnumerable<ValidationError>? errors = null)
        : base(type, errors) {
        _type = type;
        Value = value;
    }

    public TValue? Value { get; init; }

    public static implicit operator CrudResult<TValue>(TValue? value) => new(CrudResultType.Success, value);
    public static implicit operator CrudResult<TValue>(Result<TValue> result) => new(CrudResultType.Success, result.Value, result.Errors);
    public static implicit operator CrudResult<TValue>(Exception exception) => new(exception);
    public static implicit operator CrudResult<TValue>(ValidationError error) => (ValidationErrors)error;
    public static implicit operator CrudResult<TValue>(ValidationErrors errors) => new(CrudResultType.Success, default!, errors.AsEnumerable());
    public static implicit operator CrudResult<TValue>(ValidationError[] errors) => (ValidationErrors)errors;
    public static implicit operator CrudResult<TValue>(List<ValidationError> errors) => (ValidationErrors)errors;
    public static implicit operator CrudResult<TValue>(HashSet<ValidationError> errors) => (ValidationErrors)errors;
    public static implicit operator ValidationErrors(CrudResult<TValue> result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator ValidationError[](CrudResult<TValue> result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator Exception?(CrudResult<TValue> result) => result.Exception;
    public static implicit operator TValue?(CrudResult<TValue> result) => result.Value;

    public static CrudResult<TValue> operator +(CrudResult<TValue> left, Result right)
        => left.HasException
               ? left
               : right.HasException
                   ? new(right.Exception)
                   : new(left._type, left.Value, left.Errors.Union(right.Errors));

    public CrudResult<TNewValue> MapTo<TNewValue>(Func<TValue?, TNewValue?> map) {
        try {
            return HasException
                ? Error<TNewValue>(Exception)
                : Type is CrudResultType.NotFound
                    ? NotFound<TNewValue>()
                    : new(Type, map(Value), Errors);
        }
        catch (Exception ex) {
            return Error<TNewValue>(ex);
        }
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\CrudResultType.cs 
﻿namespace DotNetToolbox.Results;

public enum CrudResultType : byte {
    Invalid = 0, // The request validation failed.
    NotFound = 1, // The requested resource was not found.
    Conflict = 2, // A conflict has occured blocking the operation.
    Success = 3, // The operation was successful.
    Error = 255, // An internal error has occurred.
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\HttpResult.cs 
﻿namespace DotNetToolbox.Results;

public record HttpResult : ResultBase<HttpResultType> {
    private readonly HttpResultType _type = HttpResultType.Ok;

    protected HttpResult(Exception exception)
        : base(exception) {
    }

    protected HttpResult(HttpResultType type, IEnumerable<ValidationError>? errors = default)
        : base(errors) {
        _type = type;
    }

    public override HttpResultType Type => HasException
        ? HttpResultType.Error
        : HasErrors
            ? HttpResultType.BadRequest
            : _type;

    public bool IsSuccess => Type is HttpResultType.Ok or HttpResultType.Created;
    public bool IsInvalid => Type is HttpResultType.BadRequest or HttpResultType.Unauthorized or HttpResultType.NotFound or HttpResultType.Conflict;

    public bool IsOk => Type is HttpResultType.Ok;
    public bool WasCreated => Type is HttpResultType.Created;

    public bool IsBadRequest => Type is HttpResultType.BadRequest;
    public bool IsUnauthorized => Type is HttpResultType.Unauthorized;
    public bool WasNotFound => Type is HttpResultType.NotFound;
    public bool HasConflict => Type is HttpResultType.Conflict;

    public bool IsFaulty => Type is HttpResultType.Error;

    public static HttpResult Ok() => new(HttpResultType.Ok);
    public static HttpResult Created() => new(HttpResultType.Created);
    public static HttpResult BadRequest(Result result) => new(HttpResultType.BadRequest, result.Errors);
    public static HttpResult Unauthorized() => new(HttpResultType.Unauthorized);
    public static HttpResult NotFound() => new(HttpResultType.NotFound);
    public static HttpResult Conflict() => new(HttpResultType.Conflict);
    public static HttpResult InternalError(string error) => InternalError(new Exception(error));
    public static HttpResult InternalError(Exception exception) => new(exception);

    public static Task<HttpResult> OkTask() => Task.FromResult(Ok());
    public static Task<HttpResult> CreatedTask() => Task.FromResult(Created());
    public static Task<HttpResult> BadRequestTask(Result result) => Task.FromResult(BadRequest(result));
    public static Task<HttpResult> UnauthorizedTask() => Task.FromResult(Unauthorized());
    public static Task<HttpResult> NotFoundTask() => Task.FromResult(NotFound());
    public static Task<HttpResult> ConflictTask() => Task.FromResult(Conflict());
    public static Task<HttpResult> InternalErrorTask(string error) => InternalErrorTask(new Exception(error));
    public static Task<HttpResult> InternalErrorTask(Exception exception) => Task.FromResult(InternalError(exception));

    public static implicit operator HttpResult(Exception exception) => new(exception);
    public static implicit operator HttpResult(string error) => (Result)error;
    public static implicit operator HttpResult(ValidationError error) => (Result)error;
    public static implicit operator HttpResult(ValidationErrors errors) => (Result)errors;
    public static implicit operator HttpResult(ValidationError[] errors) => (Result)errors;
    public static implicit operator HttpResult(List<ValidationError> errors) => (Result)errors;
    public static implicit operator HttpResult(HashSet<ValidationError> errors) => (Result)errors;
    public static implicit operator HttpResult(Result result) => new(HttpResultType.Ok, result.Errors);
    public static implicit operator ValidationErrors(HttpResult result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator ValidationError[](HttpResult result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator Exception?(HttpResult result) => result.Exception;

    public static HttpResult operator +(HttpResult left, Result right)
        => left.HasException
               ? left
               : right.HasException
                   ? new(right.Exception)
                   : new(left._type, left.Errors.Union(right.Errors));

    public static HttpResult<TValue> Ok<TValue>(TValue value) => new(HttpResultType.Ok, IsNotNull(value));
    public static HttpResult<TValue> Created<TValue>(TValue value) => new(HttpResultType.Created, IsNotNull(value));
    public static HttpResult<TValue> BadRequest<TValue>(TValue? value, Result result) => new(HttpResultType.BadRequest, value, result.Errors);
    public static HttpResult<TValue> Unauthorized<TValue>() => new(HttpResultType.Unauthorized);
    public static HttpResult<TValue> NotFound<TValue>() => new(HttpResultType.NotFound);
    public static HttpResult<TValue> Conflict<TValue>(TValue value) => new(HttpResultType.Conflict, IsNotNull(value));
    public static HttpResult<TValue> InternalError<TValue>(string error) => InternalError<TValue>(new Exception(error));
    public static HttpResult<TValue> InternalError<TValue>(Exception exception) => new(exception);

    public static Task<HttpResult<TValue>> OkTask<TValue>(TValue value) => Task.FromResult(Ok(value));
    public static Task<HttpResult<TValue>> CreatedTask<TValue>(TValue value) => Task.FromResult(Created(value));
    public static Task<HttpResult<TValue>> BadRequestTask<TValue>(TValue? value, Result result) => Task.FromResult(BadRequest(value, result));
    public static Task<HttpResult<TValue>> UnauthorizedTask<TValue>() => Task.FromResult(Unauthorized<TValue>());
    public static Task<HttpResult<TValue>> NotFoundTask<TValue>() => Task.FromResult(NotFound<TValue>());
    public static Task<HttpResult<TValue>> ConflictTask<TValue>(TValue value) => Task.FromResult(Conflict(value));
    public static Task<HttpResult<TValue>> InternalErrorTask<TValue>(string error) => InternalErrorTask<TValue>(new Exception(error));
    public static Task<HttpResult<TValue>> InternalErrorTask<TValue>(Exception exception) => Task.FromResult(InternalError<TValue>(exception));
}

public record HttpResult<TValue> : HttpResult, IResult<HttpResultType, TValue> {
    private readonly HttpResultType _type = HttpResultType.Ok;

    internal HttpResult(Exception exception)
        : base(exception) {
    }

    internal HttpResult(HttpResultType type, TValue? value = default, IEnumerable<ValidationError>? errors = default)
            : base(type, errors) {
        _type = type;
        Value = value;
    }

    public TValue? Value { get; init; }

    public static implicit operator HttpResult<TValue>(TValue? value) => new(HttpResultType.Ok, value);
    public static implicit operator HttpResult<TValue>(Result<TValue> result) => new(HttpResultType.Ok, result.Value, result.Errors);
    public static implicit operator HttpResult<TValue>(Exception exception) => new(exception);
    public static implicit operator HttpResult<TValue>(ValidationError error) => (ValidationErrors)error;
    public static implicit operator HttpResult<TValue>(ValidationErrors errors) => new(HttpResultType.Ok, default!, errors.AsEnumerable());
    public static implicit operator HttpResult<TValue>(ValidationError[] errors) => (ValidationErrors)errors;
    public static implicit operator HttpResult<TValue>(List<ValidationError> errors) => (ValidationErrors)errors;
    public static implicit operator HttpResult<TValue>(HashSet<ValidationError> errors) => (ValidationErrors)errors;
    public static implicit operator ValidationErrors(HttpResult<TValue> result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator ValidationError[](HttpResult<TValue> result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator Exception?(HttpResult<TValue> result) => result.Exception;
    public static implicit operator TValue?(HttpResult<TValue> result) => result.Value;

    public static HttpResult<TValue> operator +(HttpResult<TValue> left, Result right)
        => left.HasException
               ? left
               : right.HasException
                   ? new(right.Exception)
                   : new(left._type, left.Value, left.Errors.Union(right.Errors));

    public HttpResult<TNewValue> MapTo<TNewValue>(Func<TValue?, TNewValue?> map) {
        try {
            return HasException
                ? InternalError<TNewValue>(Exception)
                : Type is HttpResultType.NotFound
                    ? NotFound<TNewValue>()
                    : new(Type, map(Value), Errors);
        }
        catch (Exception ex) {
            return InternalError<TNewValue>(ex);
        }
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\HttpResultType.cs 
﻿namespace DotNetToolbox.Results;

public enum HttpResultType : ushort {
    Ok = HttpStatusCode.OK, // 200
    Created = HttpStatusCode.Created, // 201

    BadRequest = HttpStatusCode.BadRequest, // 400
    Unauthorized = HttpStatusCode.Unauthorized, // 401
    NotFound = HttpStatusCode.NotFound, // 404
    Conflict = HttpStatusCode.Conflict, // 409

    Error = HttpStatusCode.InternalServerError, // 500
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\IResult.cs 
﻿namespace DotNetToolbox.Results;

public interface IResult {
    IReadOnlyList<ValidationError> Errors { get; }
    Exception? Exception { get; }
    bool HasErrors { get; }
    [MemberNotNullWhen(true, nameof(Exception))]
    bool HasException { get; }
    void EnsureIsSuccess(string? message = null, string? source = null);
}

public interface IResult<out TType>
    : IResult {
    TType Type { get; }
}

public interface IResult<out TType, out TValue>
    : IResult<TType> {
    TValue? Value { get; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\IValidatable.cs 
﻿namespace DotNetToolbox.Results;

public interface IValidatable {
    Result Validate(IDictionary<string, object?>? context = null);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\Result.cs 
﻿namespace DotNetToolbox.Results;

public record Result : ResultBase<ResultType> {
    protected Result(Exception exception)
        : base(exception) {
    }

    protected Result(IEnumerable<ValidationError>? errors = null)
        : base(errors) {
    }

    public override ResultType Type => HasException
                                           ? ResultType.Error
                                           : HasErrors
                                               ? ResultType.Invalid
                                               : ResultType.Success;

    public bool IsFaulty => HasException;
    public bool IsInvalid => !HasException && HasErrors;
    public bool IsSuccess => !HasException && !HasErrors;

    public static Result Success() => new();
    public static Result Invalid(string message) => Invalid(message, string.Empty);
    public static Result Invalid(string message, string source) => Invalid(new ValidationError(message, source));
    public static Result Invalid(ValidationError error) => new([error]);
    public static Result Invalid(Result result) => new(result.Errors);
    public static Result Error(string message) => Error(new Exception(message));
    public static Result Error(Exception exception) => new(exception);

    public static Task<Result> SuccessTask() => Task.FromResult(Success());
    public static Task<Result> InvalidTask(string message) => InvalidTask(message, string.Empty);
    public static Task<Result> InvalidTask(string message, string source) => InvalidTask(new ValidationError(message, source));
    public static Task<Result> InvalidTask(Result result) => Task.FromResult(Invalid(result));
    public static Task<Result> ErrorTask(string message) => ErrorTask(new Exception(message));
    public static Task<Result> ErrorTask(Exception exception)
        => Task.FromResult(Error(exception));

    public static implicit operator Result(Exception exception) => new(exception);
    public static implicit operator Result(string error) => (ValidationErrors)error;
    public static implicit operator Result(ValidationError error) => (ValidationErrors)error;
    public static implicit operator Result(ValidationErrors errors) => new(errors.AsEnumerable());
    public static implicit operator Result(ValidationError[] errors) => (ValidationErrors)errors;
    public static implicit operator Result(List<ValidationError> errors) => (ValidationErrors)errors;
    public static implicit operator Result(HashSet<ValidationError> errors) => (ValidationErrors)errors;
    public static implicit operator ValidationErrors(Result result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator ValidationError[](Result result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator Exception?(Result result) => result.Exception;

    public static Result operator +(Result left, Result right)
        => left.HasException
               ? left
               : right.HasException
                   ? new(right.Exception)
                   : new(left.Errors.Union(right.Errors));

    public virtual bool Equals(Result? other)
        => other is not null
        && Errors.SequenceEqual(other.Errors);

    public override int GetHashCode()
        => Errors.Aggregate(Array.Empty<ValidationError>().GetHashCode(), HashCode.Combine);

    public static Result<TValue> Success<TValue>(TValue? value) => new(value);
    public static Result<TValue> Invalid<TValue>(TValue? value, string message, string? source = null) => Invalid(value, new ValidationError(message, source));
    public static Result<TValue> Invalid<TValue>(TValue? value, Result result) => new(value, result.Errors);
    public static Result<TValue> Error<TValue>(string message) => Error<TValue>(new Exception(message));
    public static Result<TValue> Error<TValue>(Exception exception)
        => new(exception);

    public static Task<Result<TValue>> SuccessTask<TValue>(TValue? value) => Task.FromResult(Success(value));
    public static Task<Result<TValue>> InvalidTask<TValue>(TValue? value, string message, string? source = null) => InvalidTask(value, new ValidationError(message, source));
    public static Task<Result<TValue>> InvalidTask<TValue>(TValue? value, Result result) => Task.FromResult(Invalid(value, result));
    public static Task<Result<TValue>> ErrorTask<TValue>(string message) => ErrorTask<TValue>(new Exception(message));
    public static Task<Result<TValue>> ErrorTask<TValue>(Exception exception)
        => Task.FromResult(Error<TValue>(exception));
}

public record Result<TValue> : Result, IResult<ResultType, TValue> {
    internal Result(Exception exception)
        : base(exception) {
    }

    internal Result(TValue? value = default, IEnumerable<ValidationError>? errors = null)
        : base(errors) {
        Value = value;
    }

    public TValue? Value { get; }

    public static implicit operator Result<TValue>(TValue? value) => new(value);
    public static implicit operator Result<TValue>(Exception exception) => new(exception);
    public static implicit operator Result<TValue>(ValidationError error) => (ValidationErrors)error;
    public static implicit operator Result<TValue>(ValidationErrors errors) => new(default!, errors.AsEnumerable());
    public static implicit operator Result<TValue>(ValidationError[] errors) => (ValidationErrors)errors;
    public static implicit operator Result<TValue>(List<ValidationError> errors) => (ValidationErrors)errors;
    public static implicit operator Result<TValue>(HashSet<ValidationError> errors) => (ValidationErrors)errors;
    public static implicit operator ValidationErrors(Result<TValue> result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator ValidationError[](Result<TValue> result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator Exception?(Result<TValue> result) => result.Exception;
    public static implicit operator TValue?(Result<TValue> result) => result.Value;

    public static Result<TValue> operator +(Result<TValue> left, Result right)
        => left.HasException
               ? left
               : right.HasException
                   ? new(right.Exception)
                   : new(left.Value, left.Errors.Union(right.Errors));

    public Result<TNewValue> MapTo<TNewValue>(Func<TValue?, TNewValue?> map) {
        try {
            return HasException
                ? Error<TNewValue>(Exception)
                : new(map(Value), Errors);
        }
        catch (Exception ex) {
            return Error<TNewValue>(ex);
        }
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\ResultBase.cs 
﻿namespace DotNetToolbox.Results;

public abstract record ResultBase<TType>
    : IResult<TType>
    where TType : Enum {
    private readonly ValidationErrors _errors;

    protected ResultBase(Exception exception)
        : this() {
        Exception = IsNotNull(exception);
    }

    protected ResultBase(IEnumerable<ValidationError>? errors = null) {
        _errors = new(DoesNotContainNullItems(errors ?? []));
    }

    public abstract TType Type { get; }
    public Exception? Exception { get; }
    public IReadOnlyList<ValidationError> Errors => _errors;

    public bool HasErrors => Errors.Count != 0;
    [MemberNotNullWhen(true, nameof(Exception))]
    public bool HasException => Exception is not null;

    public void EnsureIsSuccess(string? message = null, string? source = null) {
        if (Exception is not null) throw new ValidationException(message ?? ValidationException.DefaultMessage, source ?? string.Empty, Exception);
        if (HasErrors) throw new ValidationException(message ?? ValidationException.DefaultMessage, source ?? string.Empty, [.. Errors]);
    }

    public virtual bool Equals(ResultBase<TType>? other)
        => other is not null
        && Equals(Type, other.Type)
        && Errors.SequenceEqual(other.Errors)
        && Equals(Exception, other.Exception);

    public override int GetHashCode()
        => HashCode.Combine(Type, Exception, Errors.Aggregate(Array.Empty<ValidationError>().GetHashCode(), HashCode.Combine));
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\ResultType.cs 
﻿namespace DotNetToolbox.Results;

public enum ResultType : byte {
    Invalid = 0, // The request validation failed.
    Success = 1, // The operation was successful.
    Error = 255, // An exception has occurred.
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\SignInResult.cs 
﻿namespace DotNetToolbox.Results;

public record SignInResult : ResultBase<SignInResultType> {
    private readonly SignInResultType _type = SignInResultType.Success;
    private readonly string? _token;

    private SignInResult(Exception exception)
        : base(exception) {
    }

    private SignInResult(SignInResultType type, string? token = default, IEnumerable<ValidationError>? errors = default)
        : base(errors) {
        _type = type;
        _token = token;
    }

    public override SignInResultType Type => HasException
        ? SignInResultType.Error
        : HasErrors
            ? SignInResultType.Invalid
            : _type;

    public string? Token => !HasException && !HasErrors
                                ? _token
                                : null;

    [MemberNotNullWhen(true, nameof(Token))]
    public bool RequiresConfirmation => Type is SignInResultType.ConfirmationPending;
    [MemberNotNullWhen(true, nameof(Token))]
    public bool RequiresTwoFactor => Type is SignInResultType.TwoFactorRequired;
    [MemberNotNullWhen(true, nameof(Token))]
    public bool IsSuccess => Type is SignInResultType.Success;
    public bool IsInvalid => Type is SignInResultType.Invalid;
    public bool IsLocked => Type is SignInResultType.Locked;
    public bool IsBlocked => Type is SignInResultType.Blocked;
    public bool IsFailure => Type is SignInResultType.Failed;

    [MemberNotNull(nameof(Token))]
    public static SignInResult Success(string token) => new(SignInResultType.Success, IsNotNull(token));
    [MemberNotNull(nameof(Token))]
    public static SignInResult ConfirmationIsPending(string token) => new(SignInResultType.ConfirmationPending, IsNotNull(token));
    [MemberNotNull(nameof(Token))]
    public static SignInResult TwoFactorIsRequired(string token) => new(SignInResultType.TwoFactorRequired, IsNotNull(token));
    public static SignInResult InvalidRequest(Result result) => new(SignInResultType.Invalid, errors: result.Errors);
    public static SignInResult BlockedAccount() => new(SignInResultType.Blocked);
    public static SignInResult LockedAccount() => new(SignInResultType.Locked);
    public static SignInResult FailedAttempt() => new(SignInResultType.Failed);
    public static SignInResult Error(string error) => Error(new Exception(error));
    public static SignInResult Error(Exception exception) => new(exception);

    [MemberNotNull(nameof(Token))]
    public static Task<SignInResult> SuccessTask(string token) => Task.FromResult(Success(token));
    [MemberNotNull(nameof(Token))]
    public static Task<SignInResult> ConfirmationIsPendingTask(string token) => Task.FromResult(ConfirmationIsPending(token));
    [MemberNotNull(nameof(Token))]
    public static Task<SignInResult> TwoFactorIsRequiredTask(string token) => Task.FromResult(TwoFactorIsRequired(token));
    public static Task<SignInResult> InvalidTask(Result result) => Task.FromResult(InvalidRequest(result));
    public static Task<SignInResult> BlockedAccountTask() => Task.FromResult(BlockedAccount());
    public static Task<SignInResult> LockedAccountTask() => Task.FromResult(LockedAccount());
    public static Task<SignInResult> FailedAttemptTask() => Task.FromResult(FailedAttempt());
    public static Task<SignInResult> ErrorTask(string error) => ErrorTask(new Exception(error));
    public static Task<SignInResult> ErrorTask(Exception exception) => Task.FromResult(Error(exception));

    public static implicit operator SignInResult(Exception exception) => new(exception);
    public static implicit operator SignInResult(ValidationError error) => (Result)error;
    public static implicit operator SignInResult(ValidationErrors errors) => (Result)errors;
    public static implicit operator SignInResult(ValidationError[] errors) => (Result)errors;
    public static implicit operator SignInResult(List<ValidationError> errors) => (Result)errors;
    public static implicit operator SignInResult(HashSet<ValidationError> errors) => (Result)errors;
    public static implicit operator SignInResult(Result result) => new(SignInResultType.Success, errors: result.Errors);
    public static implicit operator ValidationErrors(SignInResult result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator ValidationError[](SignInResult result) => result.HasException ? [] : [.. result.Errors];
    public static implicit operator Exception?(SignInResult result) => result.Exception;

    public static SignInResult operator +(SignInResult left, Result right)
        => left.HasException
               ? left
               : right.HasException
                   ? new(right.Exception)
                   : new(left._type, left.Token, left.Errors.Union(right.Errors));
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\SignInResultType.cs 
﻿namespace DotNetToolbox.Results;

[Flags]
public enum SignInResultType : byte {
    Error = 1, // An internal error has occurred.
    Invalid = 2, // request validation failed. No attempt was made.
    Failed = 4, // attempt failed.
    Blocked = 12, // account is blocked. (8 | 4) Counts as Failed.
    Locked = 20, // account is locked. (16 | 4) Counts as Failed.
    Success = 32, // attempt succeeded.
    ConfirmationPending = 96, // attempt succeeded but email is not confirmed. (64 | 32).
    TwoFactorRequired = 160, // attempt succeeded, but requires 2-factor authentication. (128 | 32).
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\ValidationError.cs 
﻿namespace DotNetToolbox.Results;

[DebuggerDisplay("""
                 ValidationError: Message="{Message}, Source="{Source}""
                 """)]
public sealed record ValidationError {
    private readonly string _formattedMessage;
    public const string DefaultErrorMessage = "The value is invalid.";

    public ValidationError()
        : this(DefaultErrorMessage, string.Empty) {
    }

    public ValidationError(string message, string? source = null) {
        Message = IsNotNullOrWhiteSpace(message).Trim();
        Source = IsNotNullOrDefault(source, string.Empty).Trim();
        _formattedMessage = (string.IsNullOrEmpty(Source) ? string.Empty : $"{Source}: ")
                          + Message;
    }

    public string Message { get; }
    public string Source { get; }

    public static implicit operator ValidationError(string message)
        => new(message);

    public bool Equals(ValidationError? other)
        => _formattedMessage.Equals(other?._formattedMessage);

    public override int GetHashCode()
        => _formattedMessage.GetHashCode();

    public override string ToString()
        => _formattedMessage;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\ValidationErrors.cs 
﻿namespace DotNetToolbox.Results;

public class ValidationErrors : IList<ValidationError>, IList, IReadOnlyList<ValidationError> {
    private readonly List<ValidationError> _errors;
    public ValidationErrors() {
        _errors = [];
    }
    public ValidationErrors(IEnumerable<ValidationError> errors) {
        _errors = [..errors.Distinct()];
    }

    public static implicit operator ValidationErrors(string error) => (ValidationError)error;
    public static implicit operator ValidationErrors(ValidationError error) => [error];
    public static implicit operator ValidationErrors(ValidationError[] errors) => new(errors);
    public static implicit operator ValidationErrors(List<ValidationError> errors) => new(errors);
    public static implicit operator ValidationErrors(HashSet<ValidationError> errors) => new(errors);
    public static implicit operator ValidationError[](ValidationErrors errors) => [..errors];
    public static implicit operator List<ValidationError>(ValidationErrors errors) => [..errors];
    public static implicit operator HashSet<ValidationError>(ValidationErrors errors) => [..errors];

    public static ValidationErrors operator +(ValidationErrors left, ValidationErrors right)
        => new(left.Union(right));
    public static ValidationErrors operator +(ValidationErrors left, ValidationError right)
        => new(left.Union([right]));

    public int Count => _errors.Count;
    public int IndexOf(ValidationError error) => _errors.IndexOf(error);
    public int IndexOf(string value) => IndexOf((ValidationError)value);
    public bool Contains(ValidationError error) => _errors.Contains(error);
    public bool Contains(string value) => Contains((ValidationError)value);

    public void Add(ValidationError error) {
        if (Contains(error)) return;
        _errors.Add(error);
    }
    public void Add(string value) => Add((ValidationError)value);

    public void Insert(int index, ValidationError error) {
        var existingIndex = IndexOf(error);
        if (existingIndex == index) return;
        if (existingIndex != -1) throw new InvalidOperationException("Cannot insert duplicate error.");
        ((IList)_errors).Insert(index, error);
    }
    public void Insert(int index, string value) => Insert(index, (ValidationError)value);

    public bool Remove(ValidationError error) => _errors.Remove(error);
    public void Remove(string value) => Remove((ValidationError)value);

    public void RemoveAt(int index) => _errors.RemoveAt(index);

    public ValidationError this[int index] {
        get => _errors[index];
        set => _errors[index] = value;
    }

    object? IList.this[int index] {
        get => ((IList)_errors)[index];
        set => ((IList)_errors)[index] = value is string s ? (ValidationError)s : value;
    }
    public void Clear() => _errors.Clear();

    public IEnumerator<ValidationError> GetEnumerator() => _errors.GetEnumerator();
    public void CopyTo(ValidationError[] array, int arrayIndex) => _errors.CopyTo(array, arrayIndex);
    public void CopyTo(Array array, int index) => ((ICollection)_errors).CopyTo(array, index);
    public bool IsReadOnly => false;

    IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable)_errors).GetEnumerator();
    bool IList.Contains(object? value) => Contains((ValidationError)IsNotNull(value));
    int IList.IndexOf(object? value) => ((IList)_errors).IndexOf(value);
    int IList.Add(object? value) => ((IList)_errors).Add(value);
    void IList.Insert(int index, object? value) => ((IList)_errors).Insert(index, value);
    void IList.Remove(object? value) => ((IList)_errors).Remove(value);
    bool IList.IsFixedSize => ((IList)_errors).IsFixedSize;
    void ICollection<ValidationError>.Clear() => _errors.Clear();
    bool ICollection.IsSynchronized => ((ICollection)_errors).IsSynchronized;
    object ICollection.SyncRoot => ((ICollection)_errors).SyncRoot;
    void IList<ValidationError>.RemoveAt(int index) => RemoveAt(index);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Results\ValidationException.cs 
﻿namespace DotNetToolbox.Results;

public class ValidationException(string message, string source, IEnumerable<ValidationError> errors, Exception? innerException = null)
    : Exception(FormatSource(source) + FormatMessage(message), innerException) {
    public const string DefaultMessage = "Validation failed.";

    public ValidationError[] Errors { get; } = errors.Distinct().ToArray();

    public ValidationException(Exception? innerException = null)
        : this(DefaultMessage, innerException) {
    }

    public ValidationException(ValidationError error, Exception? innerException = null)
        : this(DefaultMessage, error, innerException) {
    }

    public ValidationException(IEnumerable<ValidationError> errors, Exception? innerException = null)
        : this(DefaultMessage, errors, innerException) {
    }

    public ValidationException(string message, Exception? innerException = null)
        : this(message, string.Empty, innerException) {
    }

    public ValidationException(string message, ValidationError error, Exception? innerException = null)
        : this(message, string.Empty, error, innerException) {
    }

    public ValidationException(string message, IEnumerable<ValidationError> errors, Exception? innerException = null)
        : this(message, string.Empty, errors, innerException) {
    }

    public ValidationException(string message, string source, Exception? innerException = null)
        : this(message, source, ValidationError.DefaultErrorMessage, innerException) {
    }

    public ValidationException(string message, string source, ValidationError error, Exception? innerException = null)
        : this(message, source, [error], innerException) {
    }

    private static string FormatMessage(string message) => IsNotNullOrWhiteSpace(message);
    private static string FormatSource(string source) => string.IsNullOrEmpty(source) ? string.Empty : $"{source}: ";
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Singleton\HasDefault.cs 
﻿namespace DotNetToolbox.Singleton;

public class HasDefault<TSelf> : IHasDefault<TSelf>
    where TSelf : HasDefault<TSelf>, new() {
    public static TSelf Default { get; } = new();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Singleton\HasEmpty.cs 
﻿namespace DotNetToolbox.Singleton;

public class HasEmpty<TSelf> : IHasEmpty<TSelf>
    where TSelf : HasEmpty<TSelf>, new() {
    public static TSelf Empty { get; }= new();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Singleton\HasInstance.cs 
﻿namespace DotNetToolbox.Singleton;

public class HasInstance<TSelf> : IHasInstance<TSelf>
    where TSelf : HasInstance<TSelf>, new() {
    public static TSelf Instance { get; } = new();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Singleton\IHasDefault.cs 
﻿namespace DotNetToolbox.Singleton;

public interface IHasDefault<out TSelf>
    where TSelf : IHasDefault<TSelf> {
    public static abstract TSelf Default { get; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Singleton\IHasEmpty.cs 
﻿namespace DotNetToolbox.Singleton;

public interface IHasEmpty<out TSelf>
    where TSelf : IHasEmpty<TSelf> {
    public static abstract TSelf Empty { get; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Singleton\IHasInstance.cs 
﻿namespace DotNetToolbox.Singleton;

public interface IHasInstance<out TSelf>
    where TSelf : IHasInstance<TSelf> {
    public static abstract TSelf Instance { get; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Singleton\INamedOptions.cs 
﻿namespace DotNetToolbox.Singleton;

public interface INamedOptions<out TOptions> : IHasDefault<TOptions>
    where TOptions : INamedOptions<TOptions> {
    public static abstract string SectionName { get; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Singleton\NamedOptions.cs 
﻿namespace DotNetToolbox.Singleton;

public class NamedOptions<TOptions>
    : HasDefault<TOptions>
    , INamedOptions<TOptions>
    where TOptions : NamedOptions<TOptions>, new() {
    private const string _suffix = "Options";
    private static readonly string _typeName = typeof(TOptions).Name;

    // ReSharper disable once StaticMemberInGenericType
    public static string SectionName { get; }
        = _typeName.EndsWith(_suffix)
              ? _typeName.Remove(_typeName.Length - _suffix.Length)
              : _typeName;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core\Threading\TaskExtensions.cs 
﻿namespace DotNetToolbox.Threading;

public static class TaskExtensions {
    public static void FireAndForget(this ValueTask task)
        => HandleFireAndForget(task, default, default(Action<Exception>));
    public static void FireAndForget(this ValueTask task, Action<Exception> onException)
        => HandleFireAndForget(task, default, IsNotNull(onException));
    public static void FireAndForget(this ValueTask task, Action<OperationCanceledException> onCancel)
        => HandleFireAndForget(task, IsNotNull(onCancel), default);
    public static void FireAndForget(this ValueTask task, Action<OperationCanceledException> onCancel, Action<Exception> onException)
        => HandleFireAndForget(task, IsNotNull(onCancel), IsNotNull(onException));
    public static void FireAndForget(this ValueTask task, Action<ValueTask, Exception> onException)
        => HandleFireAndForget(task, default, IsNotNull(onException));
    public static void FireAndForget(this ValueTask task, Action<ValueTask, OperationCanceledException> onCancel)
        => HandleFireAndForget(task, IsNotNull(onCancel), default);
    public static void FireAndForget(this ValueTask task, Action<ValueTask, OperationCanceledException> onCancel, Action<ValueTask, Exception> onException)
        => HandleFireAndForget(task, IsNotNull(onCancel), IsNotNull(onException));

    public static void FireAndForget<TResult>(this ValueTask<TResult> task, Action<TResult> onResult)
        => HandleFireAndForget(task, IsNotNull(onResult), default, default(Action<Exception>));
    public static void FireAndForget<TResult>(this ValueTask<TResult> task, Action<TResult> onResult, Action<Exception> onException)
        => HandleFireAndForget(task, onResult, default, IsNotNull(onException));
    public static void FireAndForget<TResult>(this ValueTask<TResult> task, Action<TResult> onResult, Action<OperationCanceledException> onCancel)
        => HandleFireAndForget(task, onResult, IsNotNull(onCancel), default);
    public static void FireAndForget<TResult>(this ValueTask<TResult> task, Action<TResult> onResult, Action<OperationCanceledException> onCancel, Action<Exception> onException)
        => HandleFireAndForget(task, onResult, IsNotNull(onCancel), IsNotNull(onException));
    public static void FireAndForget<TResult>(this ValueTask<TResult> task, Action<TResult> onResult, Action<ValueTask<TResult>, Exception> onException)
        => HandleFireAndForget(task, IsNotNull(onResult), default, IsNotNull(onException));
    public static void FireAndForget<TResult>(this ValueTask<TResult> task, Action<TResult> onResult, Action<ValueTask<TResult>, OperationCanceledException> onCancel)
        => HandleFireAndForget(task, onResult, IsNotNull(onCancel), default);
    public static void FireAndForget<TResult>(this ValueTask<TResult> task, Action<TResult> onResult, Action<ValueTask<TResult>, OperationCanceledException> onCancel, Action<ValueTask<TResult>, Exception> onException)
        => HandleFireAndForget(task, onResult, IsNotNull(onCancel), IsNotNull(onException));

    public static void FireAndForget(this Task task)
        => HandleFireAndForget(task, default, default(Action<Exception>));
    public static void FireAndForget(this Task task, Action<Exception> onException)
        => HandleFireAndForget(task, default, IsNotNull(onException));
    public static void FireAndForget(this Task task, Action<OperationCanceledException> onCancel)
        => HandleFireAndForget(task, IsNotNull(onCancel), default);
    public static void FireAndForget(this Task task, Action<OperationCanceledException> onCancel, Action<Exception> onException)
        => HandleFireAndForget(task, IsNotNull(onCancel), IsNotNull(onException));
    public static void FireAndForget(this Task task, Action<Task, Exception> onException)
        => HandleFireAndForget(task, default, IsNotNull(onException));
    public static void FireAndForget(this Task task, Action<Task, OperationCanceledException> onCancel)
        => HandleFireAndForget(task, IsNotNull(onCancel), default);
    public static void FireAndForget(this Task task, Action<Task, OperationCanceledException> onCancel, Action<Task, Exception> onException)
        => HandleFireAndForget(task, IsNotNull(onCancel), IsNotNull(onException));

    public static void FireAndForget<TResult>(this Task<TResult> task, Action<TResult> onResult)
        => HandleFireAndForget(task, IsNotNull(onResult), default, default(Action<Exception>));
    public static void FireAndForget<TResult>(this Task<TResult> task, Action<TResult> onResult, Action<Exception> onException)
        => HandleFireAndForget(task, IsNotNull(onResult), default, IsNotNull(onException));
    public static void FireAndForget<TResult>(this Task<TResult> task, Action<TResult> onResult, Action<OperationCanceledException> onCancel)
        => HandleFireAndForget(task, IsNotNull(onResult), IsNotNull(onCancel), default);
    public static void FireAndForget<TResult>(this Task<TResult> task, Action<TResult> onResult, Action<OperationCanceledException> onCancel, Action<Exception> onException)
        => HandleFireAndForget(task, IsNotNull(onResult), IsNotNull(onCancel), IsNotNull(onException));
    public static void FireAndForget<TResult>(this Task<TResult> task, Action<TResult> onResult, Action<Task<TResult>, Exception> onException)
        => HandleFireAndForget(task, IsNotNull(onResult), default, IsNotNull(onException));
    public static void FireAndForget<TResult>(this Task<TResult> task, Action<TResult> onResult, Action<Task<TResult>, OperationCanceledException> onCancel)
        => HandleFireAndForget(task, IsNotNull(onResult), IsNotNull(onCancel), default);
    public static void FireAndForget<TResult>(this Task<TResult> task, Action<TResult> onResult, Action<Task<TResult>, OperationCanceledException> onCancel, Action<Task<TResult>, Exception> onException)
        => HandleFireAndForget(task, IsNotNull(onResult), IsNotNull(onCancel), IsNotNull(onException));

    private static async void HandleFireAndForget(ValueTask task, Action<OperationCanceledException>? onCancel, Action<Exception>? onException) {
        try {
            await IsNotNull(task).ConfigureAwait(false); // Fire and forget do not need to capture the current context
        }
        catch (OperationCanceledException ex) {
            onCancel?.Invoke(ex);
        }
        catch (Exception ex) {
            onException?.Invoke(ex);
        }
    }

    private static async void HandleFireAndForget(ValueTask task, Action<ValueTask, OperationCanceledException>? onCancel, Action<ValueTask, Exception>? onException) {
        try {
            await IsNotNull(task).ConfigureAwait(false); // Fire and forget do not need to capture the current context
        }
        catch (OperationCanceledException ex) {
            if (onCancel is null)
                return;
            onCancel(task, ex);
        }
        catch (Exception ex) {
            onException?.Invoke(task, ex);
        }
    }

    private static async void HandleFireAndForget<TResult>(ValueTask<TResult> task, Action<TResult> onResult, Action<OperationCanceledException>? onCancel, Action<Exception>? onException) {
        try {
            var result = await task.ConfigureAwait(false); // Fire and forget do not need to capture the current context
            onResult(result);
        }
        catch (OperationCanceledException ex) {
            onCancel?.Invoke(ex);
        }
        catch (Exception ex) {
            onException?.Invoke(ex);
        }
    }

    private static async void HandleFireAndForget<TResult>(ValueTask<TResult> task, Action<TResult> onResult, Action<ValueTask<TResult>, OperationCanceledException>? onCancel, Action<ValueTask<TResult>, Exception>? onException) {
        try {
            var result = await task.ConfigureAwait(false); // Fire and forget do not need to capture the current context
            onResult(result);
        }
        catch (OperationCanceledException ex) {
            onCancel?.Invoke(task, ex);
        }
        catch (Exception ex) {
            onException?.Invoke(task, ex);
        }
    }

    private static async void HandleFireAndForget(Task task, Action<OperationCanceledException>? onCancel, Action<Exception>? onException) {
        try {
            await task.ConfigureAwait(false); // Fire and forget do not need to capture the current context
        }
        catch (OperationCanceledException ex) {
            onCancel?.Invoke(ex);
        }
        catch (Exception ex) {
            onException?.Invoke(ex);
        }
    }

    private static async void HandleFireAndForget(Task task, Action<Task, OperationCanceledException>? onCancel, Action<Task, Exception>? onException) {
        try {
            await task.ConfigureAwait(false); // Fire and forget do not need to capture the current context
        }
        catch (OperationCanceledException ex) {
            onCancel?.Invoke(task, ex);
        }
        catch (Exception ex) {
            onException?.Invoke(task, ex);
        }
    }

    private static async void HandleFireAndForget<TResult>(Task<TResult> task, Action<TResult> onResult, Action<OperationCanceledException>? onCancel, Action<Exception>? onException) {
        try {
            var result = await task.ConfigureAwait(false); // Fire and forget do not need to capture the current context
            onResult(result);
        }
        catch (OperationCanceledException ex) {
            onCancel?.Invoke(ex);
        }
        catch (Exception ex) {
            onException?.Invoke(ex);
        }
    }

    private static async void HandleFireAndForget<TResult>(Task<TResult> task, Action<TResult> onResult, Action<Task<TResult>, OperationCanceledException>? onCancel, Action<Task<TResult>, Exception>? onException) {
        try {
            var result = await task.ConfigureAwait(false); // Fire and forget do not need to capture the current context
            onResult(result);
        }
        catch (OperationCanceledException ex) {
            onCancel?.Invoke(task, ex);
        }
        catch (Exception ex) {
            onException?.Invoke(task, ex);
        }
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\CreateInstanceTests.cs 
namespace DotNetToolbox;

public class CreateInstanceTests {
    // ReSharper disable once ClassNeverInstantiated.Local
    private class TestClass;

    [Fact]
    public void Create_NoArgs_CreatesObjectOfTypeT() {
        // Arrange & Act
        var instance = CreateInstance.Of<TestClass>();

        // Assert
        instance.Should().NotBeNull();
        instance.Should().BeOfType<TestClass>();
    }

    // ReSharper disable once ClassNeverInstantiated.Local
    private class TestClassWithArgs(string value) {
        public string Value { get; } = value;
    }

    [Fact]
    public void Create_WithArgs_CreatesObjectOfTypeTAndSetsValues() {
        // Arrange
        const string expectedValue = "Test";

        // Act
        var instance = CreateInstance.Of<TestClassWithArgs>(expectedValue);

        // Assert
        instance.Should().NotBeNull();
        var subject = instance.Should().BeOfType<TestClassWithArgs>().Subject;
        subject.Value.Should().Be(expectedValue);
    }

    [Fact]
    public void Create_WithWrongArgs_Throws() {
        // Act
        var action = () => CreateInstance.Of<TestClassWithArgs>();

        // Assert
        action.Should().Throw<InvalidOperationException>();
    }

    [Fact]
    public void Create_WithProvider_CreatesObjectOfTypeT() {
        // Arrange
        var provider = For<IServiceProvider>();

        // Act
        var instance = CreateInstance.Of<TestClass>(provider);

        // Assert
        instance.Should().NotBeNull();
        instance.Should().BeOfType<TestClass>();
    }

    [Fact]
    public void Create_WithProvider_WithWrongArgs_CreatesObjectOfTypeT() {
        // Arrange
        var provider = For<IServiceProvider>();

        // Act
        var action = () => CreateInstance.Of<TestClassWithArgs>(provider);

        // Assert
        action.Should().Throw<InvalidOperationException>();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\DisposableStateHolderTests.cs 
namespace DotNetToolbox;

public class DisposableStateHolderTests
{
    [Fact]
    public void Dispose_ForDefaultStateType_CallsDisposeOnState() {
        // Arrange
        var disposable = For<IDisposable>();
        var holder = new DisposableStateHolder(disposable);

        // Act
        holder.Dispose();

        // Assert
        disposable.Received(1).Dispose();
    }

    [Fact]
    public void Dispose_WhenStateIsDisposable_CallsDisposeOnState()
    {
        // Arrange
        var disposable = For<IDisposable>();
        var holder = new DisposableStateHolder<IDisposable>(disposable);

        // Act
        holder.Dispose();

        // Assert
        disposable.Received(1).Dispose();
    }

    [Fact]
    public void Dispose_WhenStateIsNotDisposable_DoesNotThrow()
    {
        // Arrange
        var holder = new DisposableStateHolder<int>(42);

        // Act
        var act = holder.Dispose;

        // Assert
        act.Should().NotThrow();
    }

    [Fact]
    public void State_WhenCalled_ReturnsInitialState()
    {
        // Arrange
        const string state = "test";
        var holder = new DisposableStateHolder<string>(state);

        // Act
        var result = holder.State;

        // Assert
        result.Should().Be(state);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\EnsureTests.cs 
namespace DotNetToolbox;

public class EnsureTests {
    [Fact]
    public void IsOfType_WhenArgumentIsOfWrongType_ThrowsArgumentNullException() {
        // Arrange
        const int input = 12;

        // Act
        var action = () => IsOfType<string>(input);

        // Assert
        action.Should().Throw<ArgumentException>().WithMessage("Expected value to be of type 'String'. Found: 'Int32'. (Parameter 'input')");
    }

    [Fact]
    public void IsOfType_WhenArgumentIsOfRightType_ReturnsInput() {
        // Arrange
        const string input = "value";

        // Act
        var result = IsOfType<string>(input);

        // Assert
        result.Should().BeSameAs(input);
    }

    [Fact]
    public void NotNull_WhenArgumentIsNull_ThrowsArgumentNullException() {
        // Arrange
        const object? input = null;

        // Act
        var action = () => IsNotNull(input);

        // Assert
        action.Should().Throw<ArgumentNullException>().WithMessage("The value cannot be null. (Parameter 'input')");
    }

    [Fact]
    public void NotNull_WhenArgumentIsNotNull_ReturnsInput() {
        // Arrange
        var input = new object();

        // Act
        var result = IsNotNull(input);

        // Assert
        result.Should().BeSameAs(input);
    }

    [Fact]
    public void DoesNotHaveValue_WhenArgumentIsNullableValueType_ThrowsArgumentNullException() {
        // Arrange
        int? input = null;

        // Act
        var action = () => IsNotNull(input);

        // Assert
        action.Should().Throw<ArgumentNullException>().WithMessage("The value cannot be null. (Parameter 'input')");
    }

    [Fact]
    public void DoesNotHaveValue_WhenArgumentIsNullableValueType_ReturnsInput() {
        // Arrange
        int? input = 3;

        // Act
        var result = IsNotNull(input);

        // Assert
        result.Should().Be(input);
    }

    [Fact]
    public void NotNullOrEmpty_WhenStringIsNull_ThrowsArgumentException() {
        // Arrange
        const string? input = null;

        // Act
        var action = () => IsNotNullOrEmpty(input);

        // Assert
        action.Should().Throw<ArgumentException>().WithMessage("The value cannot be null. (Parameter 'input')");
    }

    [Fact]
    public void NotNullOrEmpty_WhenStringIsEmpty_ThrowsArgumentException() {
        // Arrange
        var input = string.Empty;

        // Act
        var action = () => IsNotNullOrEmpty(input);

        // Assert
        action.Should().Throw<ArgumentException>().WithMessage("The string cannot be null or empty. (Parameter 'input')");
    }

    [Fact]
    public void NotNullOrEmpty_WhenStringIsNotEmpty_ReturnsInput() {
        // Arrange
        const string input = "Hello";

        // Act
        var result = IsNotNullOrEmpty(input);

        // Assert
        result.Should().Be(input);
    }

    [Fact]
    public void NotNullOrWhiteSpace_WhenStringIsNull_ThrowsArgumentException() {
        // Arrange
        const string? input = null;

        // Act
        var action = () => IsNotNullOrWhiteSpace(input);

        // Assert
        action.Should().Throw<ArgumentException>().WithMessage("The string cannot be null or white space. (Parameter 'input')");
    }

    [Fact]
    public void NotNullOrWhiteSpace_WhenStringIsEmpty_ThrowsArgumentException() {
        // Arrange
        var input = string.Empty;

        // Act
        var action = () => IsNotNullOrWhiteSpace(input);

        // Assert
        action.Should().Throw<ArgumentException>().WithMessage("The string cannot be null or white space. (Parameter 'input')");
    }

    [Fact]
    public void NotNullOrWhiteSpace_WhenStringIsWhiteSpace_ThrowsArgumentException() {
        // Arrange
        const string input = " ";

        // Act
        var action = () => IsNotNullOrWhiteSpace(input);

        // Assert
        action.Should().Throw<ArgumentException>().WithMessage("The string cannot be null or white space. (Parameter 'input')");
    }

    [Fact]
    public void NotNullOrWhiteSpace_WhenStringIsNotEmpty_ReturnsInput() {
        // Arrange
        const string input = "Hello";

        // Act
        var result = IsNotNullOrWhiteSpace(input);

        // Assert
        result.Should().Be(input);
    }

    [Fact]
    public void DoesNotHaveNull_WhenDoesNotHaveNull_ThrowsArgumentException() {
        // Arrange
        var input = new[] { default(int?) };

        // Act
        var action = () => DoesNotContainNullItems(input);

        // Assert
        action.Should().Throw<ValidationException>().WithMessage("input: The collection contains null element(s).");
    }

    [Fact]
    public void NotNullOrDoesNotHaveNull_WhenIsNotEmpty_ReturnsInput() {
        // Arrange
        var input = new[] { 1, 2, 3 };

        // Act
        var result = DoesNotContainNullItems(input);

        // Assert
        result.Should().BeSameAs(input);
    }

    [Fact]
    public void NotNullOrEmpty_WhenIsNull_ThrowsArgumentException() {
        // Arrange
        const ICollection<int> input = default!;

        // Act
        var result = IsNotEmpty(input);

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public void NotNullOrEmpty_WhenIsEmpty_ThrowsArgumentException() {
        // Arrange
        var input = Array.Empty<int>();

        // Act
        var action = () => IsNotNullOrEmpty(input);

        // Assert
        action.Should().Throw<ArgumentException>().WithMessage("The collection cannot be empty. (Parameter 'input')");
    }

    [Fact]
    public void NoEmpty_WhenIsEmpty_ThrowsArgumentException() {
        // Arrange
        var input = Array.Empty<int>();

        // Act
        var action = () => IsNotEmpty(input);

        // Assert
        action.Should().Throw<ArgumentException>().WithMessage("The collection cannot be empty. (Parameter 'input')");
    }

    [Fact]
    public void NotNullOrEmpty_WhenIsNotEmpty_ReturnsInput() {
        // Arrange
        var input = new[] { 1, 2, 3 };

        // Act
        var result = IsNotEmpty(input);

        // Assert
        result.Should().BeSameAs(input);
    }

    [Fact]
    public void DoesNotHaveNulls_WhenDoesNotHaveNull_ThrowsArgumentException() {
        // Arrange
        var input = new[] { default(int?) };

        // Act
        var action = () => DoesNotContainNullItems(input);

        // Assert
        action.Should().Throw<ValidationException>().WithMessage("input: The collection contains null element(s).");
    }

    [Fact]
    public void DoesNotHaveNulls_WhenValid_ReturnsSame() {
        // Arrange
        var input = new[] { "hello" };

        // Act
        var result = DoesNotContainNullItems(input);

        // Assert
        result.Should().BeSameAs(input);
    }

    private class ValidatableObject(bool isValid) : IValidatable {
        public Result Validate(IDictionary<string, object?>? context = null)
            => isValid ? Result.Success() : Result.Invalid("Source", "Is not valid.");
    }

    [Fact]
    public void IsValid_WhenInvalidValidatable_ThrowsValidationException() {
        // Arrange
        var input = new ValidatableObject(isValid: false);

        // Act
        var result = () => IsValid(input);

        // Assert
        result.Should().Throw<ValidationException>();
    }

    [Fact]
    public void IsValid_WhenValidValidatable_ReturnsSame() {
        // Arrange
        var input = new ValidatableObject(isValid: true);

        // Act
        var result = IsValid(input);

        // Assert
        result.Should().BeSameAs(input);
    }

    [Fact]
    public void IsValid_WhenValidSimpleObject_ReturnsSame() {
        var input = new object();

        // Act
        var result = IsValid(input, _ => Result.Success());

        // Assert
        result.Should().BeSameAs(input);
    }

    [Fact]
    public void IsValid_WhenInvalidSimpleObject_ReturnsSame() {
        // Arrange
        var input = new object();

        // Act
        var result = () => IsValid(input, _ => Result.Invalid("Some error."));

        // Assert
        result.Should().Throw<ValidationException>();
    }

    [Fact]
    public void IsValid_WhenValidSimpleObject_AndPredicate_ReturnsSame() {
        // Arrange
        var input = new object();

        // Act
        var result = IsValid(input, _ => true);

        // Assert
        result.Should().BeSameAs(input);
    }

    [Fact]
    public void IsValid_WhenInvalidSimpleObject_AndPredicate_ReturnsSame() {
        // Arrange
        var input = new object();

        // Act
        var result = () => IsValid(input, _ => false);

        // Assert
        result.Should().Throw<ValidationException>();
    }

    [Fact]
    public void IsNotNullOrDefault_WhenArgumentIsNull_ReturnsDefault() {
        // Arrange
        const string? argument = null;
        const string defaultValue = "default";

        // Act
        var result = IsNotNullOrDefault(argument, defaultValue);

        // Assert
        result.Should().Be(defaultValue);
    }

    [Fact]
    public void IsNotNullOrDefault_WhenArgumentIsNotNull_ReturnsArgument() {
        // Arrange
        const string argument = "test";
        const string defaultValue = "default";

        // Act
        var result = IsNotNullOrDefault(argument, defaultValue);

        // Assert
        result.Should().Be(argument);
    }

    [Fact]
    public void IsValidOrDefault_WhenValidatableIsValid_ReturnsArgument() {
        // Arrange
        var argument = For<IValidatable>();
        argument.Validate().Returns(Result.Success());

        // Act
        var result = IsValidOrDefault(argument, argument);

        // Assert
        result.Should().Be(argument);
    }

    [Fact]
    public void IsValidOrDefault_WhenValidatableIsInvalid_ReturnsDefault() {
        // Arrange
        var argument = new ValidatableObject(false);
        var defaultValue = new ValidatableObject(true);

        // Act
        var result = IsValidOrDefault(argument, defaultValue);

        // Assert
        result.Should().Be(defaultValue);
    }

    [Fact]
    public void IsValidOrDefault_WhenValidatableIsNull_ReturnsDefault() {
        // Arrange
        var argument = default(IValidatable);
        var defaultValue = new ValidatableObject(true);

        // Act
        var result = IsValidOrDefault(argument, defaultValue);

        // Assert
        result.Should().Be(defaultValue);
    }

    [Fact]
    public void IsValidOrDefault_WhenArgumentIsValid_ReturnsArgument() {
        // Arrange
        const string argument = "Valid";

        // Act
        var result = IsValidOrDefault(argument, _ => Result.Success(), argument);

        // Assert
        result.Should().Be(argument);
    }

    [Fact]
    public void IsValidOrDefault_WhenArgumentIsInvalid_ReturnsDefault() {
        // Arrange
        const string argument = "Invalid";
        const string defaultValue = "Valid";

        // Act
        var result = IsValidOrDefault(argument, _ => Result.Invalid("Error"), defaultValue);

        // Assert
        result.Should().Be(defaultValue);
    }

    [Fact]
    public void IsValidOrDefault_WhenArgumentIsNull_ReturnsDefault() {
        // Arrange
        const string argument = default!;
        const string defaultValue = "Valid";

        // Act
        var result = IsValidOrDefault(argument, _ => Result.Success(), defaultValue);

        // Assert
        result.Should().Be(defaultValue);
    }

    [Fact]
    public void IsValidOrDefault_WhenIsValid_ReturnsArgument() {
        // Arrange
        const string argument = "Valid";

        // Act
        var result = IsValidOrDefault(argument, _ => true, argument);

        // Assert
        result.Should().Be(argument);
    }

    [Fact]
    public void IsValidOrDefault_WhenIsInvalid_ReturnsDefault() {
        // Arrange
        const string argument = "Invalid";
        const string defaultValue = "Valid";

        // Act
        var result = IsValidOrDefault(argument, _ => false, defaultValue);

        // Assert
        result.Should().Be(defaultValue);
    }

    [Fact]
    public void IsValidOrDefault_WhenIsNull_ReturnsDefault() {
        // Arrange
        const string argument = default!;
        const string defaultValue = "Valid";

        // Act
        var result = IsValidOrDefault(argument, _ => true, defaultValue);

        // Assert
        result.Should().Be(defaultValue);
    }

    [Fact]
    public void DoesNotContainInvalidItems_WhenAllAreValidatableAndValid_ReturnsArgument() {
        // Arrange
        var argument = new List<ValidatableObject> { default!, new(true), new(true) };

        // Act
        var result = DoesNotContainInvalidItems(argument);

        // Assert
        result.Should().BeEquivalentTo(argument);
    }

    [Fact]
    public void DoesNotContainInvalidItems_WhenAllAreValidatableAndAnyIsInvalid_ThrowsValidationException() {
        // Arrange
        var argument = new List<ValidatableObject> { default!, new(true), new(false) };

        // Act
        Action act = () => DoesNotContainInvalidItems(argument);

        // Assert
        act.Should().Throw<ValidationException>().WithMessage($"*{nameof(argument)}*");
    }

    [Fact]
    public void DoesNotContainInvalidItems_WhenAllElementsAreValid_ReturnsArgument() {
        // Arrange
        var argument = new List<string> { default!, "Valid", "Valid" };

        // Act
        var result = DoesNotContainInvalidItems<List<string>, string>(argument, _ => Result.Success());

        // Assert
        result.Should().BeEquivalentTo(argument);
    }

    [Fact]
    public void DoesNotContainInvalidItems_WhenAnyElementIsInvalid_ThrowsValidationException() {
        // Arrange
        var argument = new List<string> { default!, "Valid", "Invalid" };

        // Act
        Action act = () => DoesNotContainInvalidItems<List<string>, string>(argument, _ => Result.Invalid("Error"));

        // Assert
        act.Should().Throw<ValidationException>().WithMessage($"*{nameof(argument)}*");
    }

    [Fact]
    public void DoesNotContainInvalidItems_WhenArgumentIsNull_ReturnsArgument() {
        // Act
        var result = IsValid<string[]>(default, _ => true);

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public void DoesNotContainInvalidItems_WhenDoesNotContainInvalidItems_ReturnsArgument() {
        // Arrange
        string[] argument = [default!, "One", "Two"];

        // Act
        var result = IsValid(argument, _ => true);

        // Assert
        result.Should().BeEquivalentTo(argument);
    }

    [Fact]
    public void DoesNotContainInvalidItems_WhenAnyIsInvalid_ThrowsValidationException() {
        // Arrange
        string[] argument = [default!, "One", "Invalid"];

        // Act
        Action act = () => IsValid(argument, _ => false);

        // Assert
        act.Should().Throw<ValidationException>().WithMessage($"*{nameof(argument)}*");
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\GlobalSuppressions.cs 
﻿// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.

[assembly: SuppressMessage("Reliability", "CA2012:Use ValueTasks correctly", Justification = "<Pending>")]
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\GlobalUsings.cs 
global using System.Collections;
global using System.Collections.ObjectModel;
global using System.Diagnostics.CodeAnalysis;
global using System.Linq.Expressions;

global using DotNetToolbox.Results;

global using FluentAssertions;

global using Microsoft.Extensions.DependencyInjection;

global using NSubstitute;

global using Xunit;

global using static DotNetToolbox.Ensure;
global using static DotNetToolbox.Pagination.BlockSettings;

global using static NSubstitute.Arg;
global using static NSubstitute.Substitute;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\UrlSafeBase64StringTests.cs 
﻿namespace DotNetToolbox;

public class UrlSafeBase64StringTests {
    private static readonly Guid _guidValue = new("34333231-3635-3837-3930-313233343536");
    private const string _stringValue = "1234567890123456";
    private const string _base64Value = "MTIzNDU2Nzg5MDEyMzQ1Ng";
    private static readonly byte[] _bytesValue = "1234567890123456"u8.ToArray();

    [Fact]
    public void DefaultConstructor_ReturnsBase64Guid() {
        // Act
        var result = new UrlSafeBase64String();

        // Assert
        result.Bytes.Should().BeEmpty();
        result.Text.Should().Be(string.Empty);
        result.Base64.Should().Be(string.Empty);
        result.IsGuid.Should().BeTrue();
        result.Guid.Should().Be(Guid.Empty);
    }

    [Fact]
    public void ConstructorWithNullBytes_ReturnsBase64Guid() {
        // Act
        var result = new UrlSafeBase64String(default(byte[]));

        // Assert
        result.Bytes.Should().BeEmpty();
        result.Text.Should().Be(string.Empty);
        result.Base64.Should().Be(string.Empty);
        result.IsGuid.Should().BeTrue();
        result.Guid.Should().Be(Guid.Empty);
    }

    [Fact]
    public void ConstructorWithNullString_ReturnsBase64Guid() {
        // Act
        var result = new UrlSafeBase64String(default(string)!);

        // Assert
        result.Bytes.Should().BeEmpty();
        result.Text.Should().Be(string.Empty);
        result.Base64.Should().Be(string.Empty);
        result.IsGuid.Should().BeTrue();
        result.Guid.Should().Be(Guid.Empty);
    }

    [Fact]
    public void GuidConstructor_ReturnsBase64Guid() {
        // Act
        var result = new UrlSafeBase64String(_guidValue);

        // Assert
        result.Bytes.Should().BeEquivalentTo(_bytesValue);
        result.Text.Should().Be(_stringValue);
        result.Base64.Should().Be(_base64Value);
        result.IsGuid.Should().BeTrue();
        result.Guid.Should().Be(_guidValue);
    }

    [Fact]
    public void StringConstructor_ReturnsBase64Guid() {
        // Act
        var result = new UrlSafeBase64String(_stringValue);

        // Assert
        result.Bytes.Should().BeEquivalentTo(_bytesValue);
        result.Text.Should().Be(_stringValue);
        result.Base64.Should().Be(_base64Value);
        result.IsGuid.Should().BeTrue();
        result.Guid.Should().Be(_guidValue);
    }

    [Fact]
    public void Base64Constructor_ReturnsBase64Guid() {
        // Act
        var result = new UrlSafeBase64String(_base64Value);

        // Assert
        result.Bytes.Should().BeEquivalentTo(_bytesValue);
        result.Text.Should().Be(_stringValue);
        result.Base64.Should().Be(_base64Value);
        result.IsGuid.Should().BeTrue();
        result.Guid.Should().Be(_guidValue);
    }

    [Fact]
    public void BytesConstructor_ReturnsBase64Guid() {
        // Act
        var result = new UrlSafeBase64String(_bytesValue);

        // Assert
        result.Bytes.Should().BeEquivalentTo(_bytesValue);
        result.Text.Should().Be(_stringValue);
        result.Base64.Should().Be(_base64Value);
        result.IsGuid.Should().BeTrue();
        result.Guid.Should().Be(_guidValue);
    }

    [Fact]
    public void StringConstructor_InvalidBase64_ReturnsBase64Guid() {
        // Act
        var result = new UrlSafeBase64String("Not base 64.");

        // Assert
        result.IsGuid.Should().BeFalse();
        result.Invoking(s => s.Guid).Should().Throw<FormatException>();
        result.Text.Should().Be("Not base 64.");
        result.Bytes.Should().BeEquivalentTo("Not base 64."u8.ToArray());
    }

    [Fact]
    public void BytesConstructor_InvalidGuid_ReturnsBase64Guid() {
        var input = new byte[] {
            0xD6, 0xA8, 0x6D, 0x19, 0xC5, 0xAA, 0x06, 0x4F,
            0xD6, 0xA8, 0x6D, 0x19, 0xC5, 0xAA, 0x06, 0x4F,
            0xD6, 0xA8, 0x6D, 0x19, 0xC5, 0xAA, 0x06, 0x4F,
        };

        // Act
        var result = new UrlSafeBase64String(input);

        // Assert
        result.IsGuid.Should().BeFalse();
        result.Invoking(s => s.Guid).Should().Throw<FormatException>();
        result.Text.Should().Be("\u05a8m\u0019Ū\u0006O\u05a8m\u0019Ū\u0006O\u05a8m\u0019Ū\u0006O");
        result.Base64.Should().Be("1qhtGcWqBk_WqG0ZxaoGT9aobRnFqgZP");
        result.Bytes.Should().BeEquivalentTo(input);
    }

    [Fact]
    public void ImplicitConversionTo_ReturnCorrectValues() {
        // Act
        var subject = new UrlSafeBase64String(_bytesValue);

        // Act
        string text = subject;
        Guid guid = subject;
        byte[] bytes = subject;

        // Assert
        subject.IsGuid.Should().BeTrue();
        text.Should().Be(_base64Value);
        guid.Should().Be(_guidValue);
        bytes.Should().BeEquivalentTo(_bytesValue);
    }

    [Fact]
    public void ImplicitConversionFrom_ReturnCorrectValues() {
        // Act
        UrlSafeBase64String value0 = _stringValue;
        UrlSafeBase64String value1 = _base64Value;
        UrlSafeBase64String value2 = _guidValue;
        UrlSafeBase64String value3 = _bytesValue;

        // Assert
        value0.Text.Should().Be(_stringValue);
        value1.Text.Should().Be(_stringValue);
        value2.Text.Should().Be(_stringValue);
        value3.Text.Should().Be(_stringValue);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Collections\Generic\EnumerableExtensionsTests.cs 
namespace DotNetToolbox.Collections.Generic;

public class EnumerableExtensionsTests {
    [Fact]
    public void ToArray_FromNull_Throw() {
        // Arrange
        IEnumerable<int>? subject = default;

        // Act
        var result = () => subject!.ToArray(i => i + 2);

        // Assert
        result.Should().Throw<ArgumentNullException>();
    }

    [Fact]
    public void ToArray_GetsArray() {
        // Act
        var result = Enumerable.Range(0, 100).ToArray(i => i + 2);

        // Assert
        result.Should().BeOfType<int[]>();
        result.Should().HaveCount(100);
    }

    [Fact]
    public void ToArray_WithOutput_FromNull_GetsArray() {
        // Arrange
        IEnumerable<int>? subject = default;

        // Act
        var result = () => subject!.ToArray(i => $"{i + 2}");

        // Assert
        result.Should().Throw<ArgumentNullException>();
    }

    [Fact]
    public void ToArray_WithOutput_GetsArray() {
        // Act
        var result = Enumerable.Range(0, 100).ToArray(i => $"{i + 2}");

        // Assert
        result.Should().BeOfType<string[]>();
        result.Should().HaveCount(100);
    }

    [Fact]
    public void ToDictionary_WithTransformValue_GetsDictionary() {
        // Arrange
        var input = new Dictionary<string, int>() {
            ["One"] = 1,
            ["Two"] = 2,
        };

        // Act
        var result = input.ToDictionary(i => i * 2);

        // Assert
        result.Should().BeOfType<Dictionary<string, int>>();
        result.Should().HaveCount(2);
        result["One"].Should().Be(2);
        result["Two"].Should().Be(4);
    }

    [Fact]
    public void ToDictionary_WithTransformElement_GetsDictionary() {
        // Arrange
        var input = new List<int>() { 1, 2 };

        // Act
        var result = input.ToDictionary(i => i, i => $"Key{i}", i => i * 2);

        // Assert
        result.Should().BeOfType<Dictionary<string, int>>();
        result.Should().HaveCount(2);
        result["Key1"].Should().Be(2);
        result["Key2"].Should().Be(4);
    }

    [Fact]
    public void ToHashSet_GetsHashSet() {
        // Act
        var result = Enumerable.Range(0, 100).ToHashSet(i => i + 2);

        // Assert
        result.Should().BeOfType<HashSet<int>>();
        result.Should().HaveCount(100);
    }

    [Fact]
    public void ToHashSet_WithOutput_GetsHashSet() {
        // Act
        var result = Enumerable.Range(0, 100).ToHashSet(i => $"{i + 2}");

        // Assert
        result.Should().BeOfType<HashSet<string>>();
        result.Should().HaveCount(100);
    }

    [Fact]
    public void ToIndexedItems_FromNull_Throw() {
        // Arrange
        IEnumerable<int>? subject = default;

        // Act
        var result = () => subject!.ToIndexedItems();

        // Assert
        result.Should().Throw<NullReferenceException>();
    }

    [Fact]
    public void ToIndexedItems_GetsArray() {
        // Act
        var result = Enumerable.Range(0, 100).ToIndexedItems();

        // Assert
        result.Should().BeOfType<ReadOnlyCollection<IndexedItem<int>>>();
        result.Should().HaveCount(100);
        result[0].Should().Be(new IndexedItem<int>(0u, 0, false));
        result[99].Should().Be(new IndexedItem<int>(99u, 99, true));
    }

    [Fact]
    public void ToIndexedItems_WithOutput_FromNull_GetsArray() {
        // Arrange
        IEnumerable<int>? subject = default;

        // Act
        var result = () => subject!.ToIndexedItems(i => $"{i + 2}");

        // Assert
        result.Should().Throw<NullReferenceException>();
    }

    [Fact]
    public void ToIndexedItems_WithOutput_GetsArray() {
        // Act
        var result = Enumerable.Range(0, 100).ToIndexedItems(i => $"{i + 2}");

        // Assert
        result.Should().BeOfType<ReadOnlyCollection<IndexedItem<string>>>();
        result.Should().HaveCount(100);
        result[0].Index.Should().Be(0u);
        result[0].Value.Should().Be("2");
        result[0].IsFirst.Should().BeTrue();
        result[0].IsLast.Should().BeFalse();
        result[99].Index.Should().Be(99u);
        result[99].Value.Should().Be("101");
        result[99].IsFirst.Should().BeFalse();
        result[99].IsLast.Should().BeTrue();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Collections\Generic\QueryableExtensionsTests.cs 
namespace DotNetToolbox.Collections.Generic;

public class QueryableExtensionsTests {
    [Fact]
    public void ToArray_WithProject_ReturnsProjectedArray() {
        // Arrange
        var source = new List<int> { 1, 2, 3 }.AsQueryable();
        Expression<Func<int, int>> project = x => x * 2;

        // Act
        var result = source.ToArray(project);

        // Assert
        result.Should().Equal([2, 4, 6]);
    }

    [Fact]
    public void ToDictionary_WithProjectAndSelectors_ReturnsProjectedDictionary() {
        // Arrange
        var source = new List<string> { "one", "two", "three" }.AsQueryable();
        Expression<Func<string, string>> project = x => x.ToUpper();

        // Act
        var result = source.ToDictionary<string, string, int>(project, x => x, x => x.Length);

        // Assert
        result.Should().Equal(new Dictionary<string, int> { { "ONE", 3 }, { "TWO", 3 }, { "THREE", 5 } });
    }

    [Fact]
    public void ToHashSet_WithProject_ReturnsProjectedHashSet() {
        // Arrange
        var source = new List<int> { 1, 2, 3 }.AsQueryable();
        Expression<Func<int, int>> project = x => x * 2;

        // Act
        var result = source.ToHashSet<int>(project);

        // Assert
        result.Should().Equal(new HashSet<int> { 2, 4, 6 });
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\DependencyInjection\ServiceCollectionExtensionsTests.cs 
namespace DotNetToolbox.DependencyInjection;

public class ServiceCollectionExtensionsTests {
    [Fact]
    public void AddEnvironment_RegisterHandlers() {
        var services = new ServiceCollection();
        var result = services.AddEnvironment();
        using var provider = result.BuildServiceProvider();
        var environment = provider.GetRequiredService<IEnvironment>();

        environment.Name.Should().BeEmpty();
        environment.Assembly.Should().NotBeNull();
        environment.DateTime.Should().NotBeNull();
        environment.Output.Should().NotBeNull();
        environment.Input.Should().NotBeNull();
        environment.FileSystem.Should().NotBeNull();

        result.Should().BeSameAs(services);
    }

    [Fact]
    public void AddEnvironment_WithNamedEnvironment_RegisterHandlers() {
        var services = new ServiceCollection();
        var result = services.AddEnvironment("Development");
        var provider = services.BuildServiceProvider();
        var environment = provider.GetRequiredService<IEnvironment>();

        environment.Name.Should().Be("Development");
        environment.Assembly.Should().NotBeNull();
        environment.DateTime.Should().NotBeNull();
        environment.Output.Should().NotBeNull();
        environment.Input.Should().NotBeNull();
        environment.FileSystem.Should().NotBeNull();

        result.Should().BeSameAs(services);
    }

    [Fact]
    public void AddEnvironment_WithFakeEnvironment_RegisterHandlers() {
        var services = new ServiceCollection();
        var environment = Substitute.For<IEnvironment>();
        environment.Name.Returns("Development");
        services.AddEnvironment(environment);
        var provider = services.BuildServiceProvider();

        var env = provider.GetRequiredService<IEnvironment>();

        env.Name.Should().Be("Development");
        env.Assembly.Should().NotBeNull();
        env.DateTime.Should().NotBeNull();
        env.Output.Should().NotBeNull();
        env.Input.Should().NotBeNull();
        env.FileSystem.Should().NotBeNull();
    }

    [Fact]
    public void AddEnvironment_WithDefaultEnvironment_RegisterHandlers() {
        var services = new ServiceCollection();
        services.AddAssemblyDescriptor();
        services.AddDateTimeProvider();
        services.AddGuidProvider();
        services.AddFileSystem();
        services.AddInput();
        services.AddOutput();
        var environment = new Environment(services.BuildServiceProvider());
        services.AddEnvironment(environment);
        var provider = services.BuildServiceProvider();

        var env = provider.GetRequiredService<IEnvironment>();

        env.Name.Should().BeEmpty();
        env.Assembly.Should().NotBeNull();
        env.DateTime.Should().NotBeNull();
        env.Output.Should().NotBeNull();
        env.Input.Should().NotBeNull();
        env.FileSystem.Should().NotBeNull();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Pagination\BlockTests.cs 
﻿namespace DotNetToolbox.Pagination;

public class BlockTests {
    [Fact]
    public void Constructor_WithParams_Passes() {
        var subject = new Block<int>(items: [1, 2, 3, 4, 5],
                                     offset: 6,
                                     size: 5);

        subject.Items.Should().BeEquivalentTo([1, 2, 3, 4, 5]);
        subject.Offset.Should().Be(6);
        subject.Size.Should().Be(5);
    }

    [Fact]
    public void ObjectInitializer_Passes() {
        var subject = new Block<int>() {
            Items = [1, 2, 3, 4],
            Offset = 5,
        };

        subject.Items.Should().BeEquivalentTo([1, 2, 3, 4]);
        subject.Offset.Should().Be(5);
        subject.Size.Should().Be(DefaultBlockSize);
    }

    [Fact]
    public void DefaultConstructor_Passes() {
        var subject = new Block<int>();

        subject.Items.Should().BeEmpty();
        subject.Offset.Should().Be(0);
        subject.Size.Should().Be(DefaultBlockSize);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Pagination\PageTests.cs 
﻿namespace DotNetToolbox.Pagination;

public class PageTests {
    [Fact]
    public void Constructor_WithParams_Passes() {
        var subject = new Page<int>(items: [1, 2, 3, 4, 5],
                                    offset: 1,
                                    size: 5,
                                    totalCount: 12);

        subject.TotalCount.Should().Be(12);
        subject.Items.Should().BeEquivalentTo([1, 2, 3, 4, 5]);
        subject.Offset.Should().Be(1);
        subject.Size.Should().Be(5);
    }

    [Fact]
    public void ObjectInitializer_Passes() {
        var subject = new Page<int>() {
            Items = [1, 2, 3, 4],
            Offset = 5,
            TotalCount = 100,
        };

        subject.Items.Should().BeEquivalentTo([1, 2, 3, 4]);
        subject.Offset.Should().Be(5);
        subject.TotalCount.Should().Be(100);
        subject.Size.Should().Be(DefaultBlockSize);
    }

    [Fact]
    public void DefaultConstructor_Passes() {
        var subject = new Page<int>();

        subject.Items.Should().BeEmpty();
        subject.Offset.Should().Be(0);
        subject.TotalCount.Should().Be(0);
        subject.Size.Should().Be(DefaultBlockSize);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Results\CrudResultTests.cs 
using static DotNetToolbox.Results.CrudResult;

namespace DotNetToolbox.Results;

public class CrudResultTests {
    private static readonly CrudResult _success = Success();
    private static readonly CrudResult _notFound = NotFound();
    private static readonly CrudResult _conflict = Conflict();
    private static readonly CrudResult _invalid = Invalid(new ValidationError("Some error.", "Source"));
    private static readonly CrudResult _invalidWithSameError = Invalid(new ValidationError("Some error.", "Source"));
    private static readonly CrudResult _invalidWithWithOtherError = Invalid(new ValidationError("Other error.", "Source"));
    private static readonly CrudResult _failure = Error(new Exception("Some error."));

    private static readonly CrudResult<string> _successWithValue = Success("Value");
    private static readonly CrudResult<string> _notFoundWithValue = NotFound<string>();
    private static readonly CrudResult<string> _conflictWithValue = Conflict("Value");
    private static readonly CrudResult<string> _invalidWithValue = Invalid("Value", new ValidationError("Some error.", "Source"));
    private static readonly CrudResult<string> _failureWithValue = Error<string>(new Exception("Some error."));

    [Fact]
    public void ImplicitConversion_FromValidationError_ReturnsFailure() {
        // Act
        CrudResult result = new ValidationError("Some error.", nameof(result));

        // Assert
        result.IsSuccess.Should().BeFalse();
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorArray_ReturnsFailure() {
        // Act
        CrudResult result = new[] { new ValidationError("Some error.", nameof(result)) };

        // Assert
        result.IsSuccess.Should().BeFalse();
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorList_ReturnsFailure() {
        // Act
        CrudResult result = new List<ValidationError> { new("Some error.", nameof(result)) };

        // Assert
        result.IsSuccess.Should().BeFalse();
    }

    private class TestDataForProperties : TheoryData<CrudResult, bool, bool, bool> {
        public TestDataForProperties() {
            Add(_invalid, false, false, false);
            Add(_failure, false, false, false);
            Add(_success, true, false, false);
            Add(_notFound, false, true, false);
            Add(_conflict, false, false, true);
            Add(_invalidWithValue, false, false, false);
            Add(_failureWithValue, false, false, false);
            Add(_successWithValue, true, false, false);
            Add(_notFoundWithValue, false, true, false);
            Add(_conflictWithValue, false, false, true);
        }
    }
    [Theory]
    [ClassData(typeof(TestDataForProperties))]
    public void Properties_ShouldReturnAsExpected(CrudResult subject, bool isSuccess, bool isNotFound, bool isConflict) {
        // Assert
        subject.IsSuccess.Should().Be(isSuccess);
        subject.WasNotFound.Should().Be(isNotFound);
        subject.HasConflict.Should().Be(isConflict);
    }

    private class TestDataForEquality : TheoryData<CrudResult, CrudResult?, bool> {
        public TestDataForEquality() {
            Add(_success, null, false);
            Add(_success, _success, true);
            Add(_success, _notFound, false);
            Add(_success, _conflict, false);
            Add(_success, _invalid, false);
            Add(_notFound, null, false);
            Add(_notFound, _success, false);
            Add(_notFound, _notFound, true);
            Add(_notFound, _conflict, false);
            Add(_notFound, _invalid, false);
            Add(_conflict, null, false);
            Add(_conflict, _success, false);
            Add(_conflict, _notFound, false);
            Add(_conflict, _conflict, true);
            Add(_conflict, _invalid, false);
            Add(_invalid, null, false);
            Add(_invalid, _success, false);
            Add(_invalid, _notFound, false);
            Add(_invalid, _conflict, false);
            Add(_invalid, _invalid, true);
            Add(_invalid, _invalidWithSameError, true);
            Add(_invalid, _invalidWithWithOtherError, false);
        }
    }

    [Theory]
    [ClassData(typeof(TestDataForEquality))]
    public void Equals_ReturnsAsExpected(CrudResult subject, CrudResult? other, bool expectedResult) {
        // Act
        var result = subject == other;

        // Assert
        result.Should().Be(expectedResult);
    }

    [Theory]
    [ClassData(typeof(TestDataForEquality))]
    public void NotEquals_ReturnsAsExpected(CrudResult subject, CrudResult? other, bool expectedResult) {
        // Act
        var result = subject != other;

        // Assert
        result.Should().Be(!expectedResult);
    }

    [Fact]
    public void GetHashCode_DifferentiatesAsExpected() {
        var expectedResult = new HashSet<CrudResult> {
            _success,
            _invalid,
            _invalidWithWithOtherError,
        };

        // Act
        var result = new HashSet<CrudResult> {
            Success(),
            Success(),
            _success,
            _success,
            _invalid,
            _invalid,
            _invalidWithSameError,
            _invalidWithWithOtherError,
        };

        // Assert
        result.Should().BeEquivalentTo(expectedResult);
    }

    [Fact]
    public void Success_CreatesResult() {
        // Arrange & Act
        var result = Success();

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }

    [Fact]
    public void Invalid_WithMessageOnly_CreatesResult() {
        // Arrange & Act
        var result = Invalid(new ValidationError("Some error."));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void Invalid_WithSourceAndMessage_CreatesResult() {
        // Arrange & Act
        var result = Invalid(new ValidationError("Some error.", "Field1"));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEquivalentTo(new[] {
            new ValidationError("Some error.", "Field1"),
        });
    }

    [Fact]
    public void Invalid_WithResult_CreatesResult() {
        // Arrange & Act
        var result = Invalid(Result.Invalid("Some error."));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void AddOperator_WithoutError_ReturnsInvalid() {
        // Arrange
        var result = Success();

        // Act
        result += Result.Success();

        // Assert
        result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public void AddOperator_WithError_ReturnsInvalid() {
        // Arrange
        var result = Success("SomeToken");

        // Act
        result += new ValidationError("Some error.", "Source");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void AddOperator_WithOtherError_ReturnsBothErrors() {
        // Arrange
        var result = Invalid(new ValidationError("Some error 42.", "Source"));

        // Act
        result += new ValidationError("Other error 42.", "Source");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().HaveCount(2);
    }

    [Fact]
    public void AddOperator_WithSameError_ReturnsOnlyOneError() {
        // Arrange
        var result = Invalid(new ValidationError("Some error.", "Source"));

        // Act
        result += new ValidationError("Some error.", "Source");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void OfT_CopyConstructor_ClonesObject() {
        // Arrange
        var original = Success(42);

        // Act
        var result = original with {
            Value = 7,
        };

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().Be(7);
    }

    [Fact]
    public void ImplicitConversion_FromValue_ReturnsSuccess() {
        // Act
        CrudResult<string> subject = "Value";

        // Assert
        subject.Value.Should().Be("Value");
        subject.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public void ImplicitConversion_FromSuccessResult_ReturnsSuccess() {
        // Act
        var result = Result.Success("Value");
        CrudResult<string> subject = result;

        // Assert
        subject.Value.Should().Be(result.Value);
        subject.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public void ImplicitConversion_FromInvalidResult_ReturnsSuccess() {
        // Arrange
        var result = Invalid("Some error.");

        // Act
        ValidationErrors errors = result;
        ValidationError[] errorArray = result;
        Exception exception = result!;

        // Assert
        errors.Should().ContainSingle();
        errorArray.Should().ContainSingle();
        exception.Should().BeNull();
    }

    [Fact]
    public void ImplicitConversion_FromExceptionResult_ReturnsSuccess() {
        // Arrange
        var result = Error("Some error.");

        // Act
        ValidationErrors errors = result;
        ValidationError[] errorArray = result;
        Exception exception = result!;

        // Assert
        errors.Should().BeEmpty();
        errorArray.Should().BeEmpty();
        exception.Should().NotBeNull();
    }

    [Fact]
    public void AddOperator_WithValueAndWithoutError_ReturnsInvalid() {
        // Arrange
        var result = Success("Value");

        // Act
        result += Result.Success();

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().Be("Value");
    }

    [Fact]
    public void AddOperator_WithValueAndWithError_ReturnsInvalid() {
        // Arrange
        var result = Success("Value");

        // Act
        result += new ValidationError("Some error.", "result");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Value.Should().Be("Value");
    }

    [Fact]
    public void MapTo_WithoutError_ReturnsSuccess() {
        // Arrange
        var subject = Success("42");

        // Act
        var result = subject.MapTo(s => s is null ? default : int.Parse(s));

        // Assert
        result.Should().BeOfType<CrudResult<int>>();
        result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public void MapTo_FromNotFound_ReturnsSuccess() {
        // Arrange
        var subject = NotFound<string>();

        // Act
        var result = subject.MapTo(s => s is null ? default : int.Parse(s));

        // Assert
        result.Should().BeOfType<CrudResult<int>>();
        result.IsSuccess.Should().BeFalse();
        result.WasNotFound.Should().BeTrue();
    }

    [Fact]
    public void MapTo_WithError_ReturnsInvalid() {
        // Arrange
        var subject = Invalid("42", new ValidationError("Some error.", "Field1"));

        // Act
        var result = subject.MapTo(s => s is null ? default : int.Parse(s));

        // Assert
        result.Should().BeOfType<CrudResult<int>>();
        result.IsSuccess.Should().BeFalse();
    }

    [Fact]
    public void SuccessOfT_CreatesResult() {
        // Arrange & Act
        var result = Success(42);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }

    [Fact]
    public void InvalidOfT_WithMessageOnly_CreatesResult() {
        // Arrange & Act
        var result = Invalid(42, new ValidationError("Some error."));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void InvalidOfT_WithSourceAndMessage_CreatesResult() {
        // Arrange & Act
        var result = Invalid(42, new ValidationError("Some error.", "Field1"));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEquivalentTo(new[] {
            new ValidationError("Some error.", "Field1"),
        });
    }

    [Fact]
    public void InvalidOfT_WithResult_CreatesResult() {
        // Arrange & Act
        var result = Invalid(42, Result.Invalid("Some error."));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_FromResult_SetsTypeBasedOnErrorPresence() {
        // Arrange
        var resultWithErrors = Result.Invalid("Test error");
        var resultWithoutErrors = Result.Success();

        // Act
        CrudResult crudResultWithErrors = resultWithErrors;
        CrudResult crudResultWithoutErrors = resultWithoutErrors;

        // Assert
        crudResultWithErrors.Type.Should().Be(CrudResultType.Invalid);
        crudResultWithoutErrors.Type.Should().Be(CrudResultType.Success);
    }

    [Fact]
    public void AdditionOperator_CombiningDifferentTypes_PreservesErrorType() {
        // Arrange
        var resultError = Error(new Exception("Error"));
        var resultNotFound = Result.Success();

        // Act
        var combinedResult = resultError + resultNotFound;

        // Assert
        combinedResult.Type.Should().Be(CrudResultType.Error);
    }

    [Fact]
    public void AdditionOperator_CombiningCrudResultTValueInstances_PreservesValueType() {
        // Arrange
        var resultWithValue = Conflict("Test");
        var resultWithConflict = Result.Success();

        // Act
        var combinedResult = resultWithValue + resultWithConflict;

        // Assert
        combinedResult.Type.Should().Be(CrudResultType.Conflict);
        combinedResult.Value.Should().Be("Test");
    }

    [Fact]
    public void ResultTValue_Equals_WithDifferentTypes_ReturnsFalse() {
        // Arrange
        var resultSuccess = Success("Value1");
        var resultNotFound = NotFound();

        // Act
        var areEqual = resultSuccess.Equals(resultNotFound);

        // Assert
        areEqual.Should().BeFalse();
    }

    [Fact]
    public void ResultTValue_GetHashCode_WithDifferentTypes_ProducesDifferentHashCodes() {
        // Arrange
        var resultSuccess = Success("Value1");
        var resultNotFound = NotFound();

        // Act
        var hashCodeSuccess = resultSuccess.GetHashCode();
        var hashCodeNotFound = resultNotFound.GetHashCode();

        // Assert
        hashCodeSuccess.Should().NotBe(hashCodeNotFound);
    }

    [Fact]
    public async Task SuccessTask_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = SuccessTask();

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public async Task NotFoundTask_ReturnsTaskWithNotFoundCrudResult() {
        // Act
        var task = NotFoundTask();

        // Assert
        var result = await task;
        result.WasNotFound.Should().BeTrue();
    }

    [Fact]
    public async Task ConflictTask_ReturnsTaskWithConflictCrudResult() {
        // Act
        var task = ConflictTask();

        // Assert
        var result = await task;
        result.HasConflict.Should().BeTrue();
    }

    [Fact]
    public async Task InvalidTask_ReturnsTaskWithInvalidCrudResult() {
        // Act
        var task = InvalidTask("Some error.");

        // Assert
        var result = await task;
        result.IsInvalid.Should().BeTrue();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public async Task SuccessTaskTValue_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = SuccessTask("Test value");

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().Be("Test value");
    }

    [Fact]
    public void MapTo_WhenMappingFunctionThrows_ResultsInErrorCrudResult() {
        // Arrange
        var result = Success("42");
        static int MappingFunction(string _) => throw new InvalidOperationException();

        // Act
        var mappedResult = result.MapTo(MappingFunction!);

        // Assert
        mappedResult.Should().BeOfType<CrudResult<int>>();
        mappedResult.HasException.Should().BeTrue();
        mappedResult.Exception.Should().BeOfType<InvalidOperationException>();
    }

    [Fact]
    public void MapTo_WhenTypeIsNotFound_ReturnsNotFoundCrudResult() {
        // Arrange
        var result = NotFound<string>();

        // Act
        var mappedResult = result.MapTo(s => s!.Length);

        // Assert
        mappedResult.Should().BeOfType<CrudResult<int>>();
        mappedResult.WasNotFound.Should().BeTrue();
    }

    [Fact]
    public void Error_WithString_CreatesResultWithException() {
        // Arrange
        const string errorMessage = "Error message";

        // Act
        var result = Error(errorMessage);

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>();
        result.Exception!.Message.Should().Be(errorMessage);
    }

    [Fact]
    public void Error_WithException_CreatesResultWithException() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        var result = Error(exception);

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public async Task NotFoundTaskTValue_ReturnsTaskWithNotFoundCrudResult() {
        // Act
        var task = NotFoundTask<int>();

        // Assert
        var result = await task;
        result.WasNotFound.Should().BeTrue();
        result.Value.Should().Be(default);
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorToCrudResultTValue_ReturnsInvalid() {
        // Act
        CrudResult<int> result = new ValidationError("Some error.", nameof(result));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
        result.Value.Should().Be(default);
    }

    [Fact]
    public void AdditionOperator_CombiningCrudResultWithError_ReturnsResultWithError() {
        // Arrange
        var result = Success();
        var error = new ValidationError("Error message", "Property");

        // Act
        var combinedResult = result + error;

        // Assert
        combinedResult.HasErrors.Should().BeTrue();
        combinedResult.Errors.Should().ContainSingle(e => e.Message == "Error message" && e.Source == "Property");
    }

    // ... similar tests for other operator overloads ...

    [Fact]
    public void MapTo_WithException_ReturnsCrudResultTNewValueWithSameException() {
        // Arrange
        var exception = new Exception("Error message");
        var subject = Error<int>(exception);

        // Act
        var result = subject.MapTo(value => value * 2);

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void ValueProperty_IsSetCorrectly() {
        // Arrange
        const string expectedValue = "Test value";

        // Act
        var result = Success(expectedValue);

        // Assert
        result.Value.Should().Be(expectedValue);
    }

    // ... similar tests for other factory methods and implicit conversions that set Value ...

    [Fact]
    public void EnsureIsSuccess_WhenHasErrors_ThrowsValidationException() {
        // Arrange
        var result = Invalid(new ValidationError("Error message"));

        // Act & Assert
        var action = () => result.EnsureIsSuccess();

        action.Should().Throw<ValidationException>().WithMessage(ValidationException.DefaultMessage);
    }

    [Fact]
    public void EnsureIsSuccess_WhenHasException_ThrowsValidationException() {
        // Arrange
        var exception = new Exception("Original exception");
        var result = Error(exception);

        // Act & Assert
        var action = () => result.EnsureIsSuccess();

        action.Should().Throw<ValidationException>().WithInnerException<Exception>().WithMessage("Original exception");
    }

    [Fact]
    public void TypeProperty_WhenHasException_ReturnsError() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        var result = Error(exception);

        // Assert
        result.Type.Should().Be(CrudResultType.Error);
    }

    [Fact]
    public async Task ErrorTask_WithString_ReturnsTaskWithErrorCrudResult() {
        // Arrange
        const string errorMessage = "Error message";

        // Act
        var task = ErrorTask(errorMessage);
        var result = await task;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>();
        result.Exception!.Message.Should().Be(errorMessage);
    }

    [Fact]
    public async Task ErrorTask_WithException_ReturnsTaskWithErrorCrudResult() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        var task = ErrorTask(exception);
        var result = await task;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromExceptionToCrudResult_CreatesResultWithException() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        CrudResult result = exception;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromStringToCrudResult_CreatesResultWithException() {
        // Act
        CrudResult result = "Error message";

        // Assert
        result.HasException.Should().BeFalse();
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorsToCrudResult_CreatesResultWithErrors() {
        // Arrange
        var errors = new ValidationErrors {
            new ValidationError("Error message", "Property"),
        };

        // Act
        CrudResult result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromHashSetValidationErrorToCrudResult_CreatesResultWithErrors() {
        // Arrange
        var errors = new HashSet<ValidationError> {
            new("Error message", "Property"),
        };

        // Act
        CrudResult result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromCrudResultToValidationErrorArray_ReturnsErrors() {
        // Arrange
        var errors = new[] { new ValidationError("Error message", "Property") };

        // Act
        ValidationError[] errorArray = Invalid(errors);

        // Assert
        errorArray.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromCrudResultToException_ReturnsException() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        Exception? resultException = Error(exception);

        // Assert
        resultException.Should().BeSameAs(exception);
    }

    [Fact]
    public void ErrorOfT_WithString_CreatesResultWithException() {
        // Arrange
        const string errorMessage = "Error message";

        // Act
        var result = Error<int>(errorMessage);

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>();
        result.Exception!.Message.Should().Be(errorMessage);
    }

    [Fact]
    public async Task ConflictTaskTValue_ReturnsTaskWithConflictCrudResult() {
        // Arrange
        const string value = "Test value";

        // Act
        var task = ConflictTask(value);
        var result = await task;

        // Assert
        result.HasConflict.Should().BeTrue();
        result.Value.Should().Be(value);
    }

    [Fact]
    public async Task InvalidTaskTValue_ReturnsTaskWithInvalidCrudResult() {
        // Arrange
        const string value = "Test value";
        var errors = new[] { new ValidationError("Error message", "Property") };
        var invalidResult = Result.Invalid(errors);

        // Act
        var task = InvalidTask(value, invalidResult);
        var result = await task;

        // Assert
        result.IsInvalid.Should().BeTrue();
        result.Value.Should().Be(value);
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public async Task ErrorTaskTValue_WithString_ReturnsTaskWithErrorCrudResult() {
        // Arrange
        const string errorMessage = "Error message";

        // Act
        var task = ErrorTask<int>(errorMessage);
        var result = await task;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>();
        result.Exception!.Message.Should().Be(errorMessage);
    }

    [Fact]
    public async Task ErrorTaskTValue_WithException_ReturnsTaskWithErrorCrudResult() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        var task = ErrorTask<int>(exception);
        var result = await task;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void AdditionOperator_LeftHasException_ReturnsLeft() {
        // Arrange
        var left = Error(new Exception("Left exception"));
        var right = Result.Success();

        // Act
        var result = left + right;

        // Assert
        result.Should().BeSameAs(left);
        result.HasException.Should().BeTrue();
        result.Exception!.Message.Should().Be("Left exception");
    }

    [Fact]
    public void AdditionOperator_RightHasException_ReturnsNewCrudResultWithRightException() {
        // Arrange
        var left = Success();
        var rightException = new Exception("Right exception");
        var right = Result.Error(rightException);

        // Act
        var result = left + right;

        // Assert
        result.Should().NotBeSameAs(left);
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(rightException);
    }

    [Fact]
    public void AdditionOperator_NeitherHasException_ReturnsCombinedErrors() {
        // Arrange
        var leftErrors = new[] { new ValidationError("Left error", "LeftProperty") };
        var rightErrors = new[] { new ValidationError("Right error", "RightProperty") };
        var left = Invalid(leftErrors);
        var right = Result.Invalid(rightErrors);

        // Act
        var result = left + right;

        // Assert
        result.HasException.Should().BeFalse();
        result.Errors.Should().HaveCount(2);
        result.Errors.Should().Contain(leftErrors.Union(rightErrors));
    }

    [Fact]
    public void AdditionOperator_NeitherHasExceptionAndDuplicateErrors_ReturnsDistinctErrors() {
        // Arrange
        var sharedError = new ValidationError("Shared error", "SharedProperty");
        var leftErrors = new[] { sharedError };
        var rightErrors = new[] { sharedError };
        var left = Invalid(leftErrors);
        var right = Result.Invalid(rightErrors);

        // Act
        var result = left + right;

        // Assert
        result.HasException.Should().BeFalse();
        result.Errors.Should().ContainSingle(); // Only one instance of the shared error
        result.Errors.Should().Contain(sharedError);
    }

    [Fact]
    public void ImplicitConversion_FromExceptionToCrudResultTValue_CreatesResultWithException() {
        // Arrange
        var exception = new Exception("Test exception");

        // Act
        CrudResult<string> result = exception;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorArrayToCrudResultTValue_CreatesResultWithErrors() {
        // Arrange
        var errors = new[] { new ValidationError("Error 1", "Property1"), new ValidationError("Error 2", "Property2") };

        // Act
        CrudResult<string> result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorListToCrudResultTValue_CreatesResultWithErrors() {
        // Arrange
        var errors = new List<ValidationError> { new("Error 1", "Property1"), new("Error 2", "Property2") };

        // Act
        CrudResult<string> result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorHashSetToCrudResultTValue_CreatesResultWithErrors() {
        // Arrange
        var errors = new HashSet<ValidationError> { new("Error 1", "Property1"), new("Error 2", "Property2") };

        // Act
        CrudResult<string> result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromCrudResultTValueToValidationErrorArray_ReturnsErrors() {
        // Arrange
        var errors = new[] { new ValidationError("Error 1", "Property1"), new ValidationError("Error 2", "Property2") };
        var result = Invalid("Value", errors);

        // Act
        ValidationErrors resultErrors = result;
        ValidationError[] errorArray = result;
        Exception? resultException = result;

        // Assert
        resultErrors.Should().BeEquivalentTo(errors);
        errorArray.Should().BeEquivalentTo(errors);
        resultException.Should().BeNull();
    }

    [Fact]
    public void ImplicitConversion_FromCrudResultTValueToException_ReturnsException() {
        // Arrange
        var exception = new Exception("Test exception");
        var result = Error<string>(exception);

        // Act
        ValidationErrors resultErrors = result;
        ValidationError[] errorArray = result;
        Exception? resultException = result;

        // Assert
        resultErrors.Should().BeEmpty();
        errorArray.Should().BeEmpty();
        resultException.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromCrudResultTValueToTValue_ReturnsValue() {
        // Arrange
        const string value = "Test value";
        var result = Success(value);

        // Act
        string? resultValue = result;

        // Assert
        resultValue.Should().Be(value);
    }

    [Fact]
    public void AdditionOperator_CombiningCrudResultTValueWithResult_ReturnsCombinedErrors() {
        // Arrange
        const string value = "Test value";
        var leftErrors = new[] { new ValidationError("Left error", "LeftProperty") };
        var rightErrors = new[] { new ValidationError("Right error", "RightProperty") };
        var left = Invalid(value, leftErrors);
        var right = Result.Invalid(rightErrors);

        // Act
        var result = left + right;

        // Assert
        result.HasException.Should().BeFalse();
        result.Value.Should().Be(value);
        result.Errors.Should().HaveCount(2);
        result.Errors.Should().Contain(leftErrors.Union(rightErrors));
    }

    [Fact]
    public void AdditionOperator_CombiningCrudResultTValueWithResultWhenLeftHasException_ReturnsLeft() {
        // Arrange
        var leftException = new Exception("Left exception");
        var left = Error<string>(leftException);
        var right = Result.Success();

        // Act
        var result = left + right;

        // Assert
        result.Should().BeSameAs(left);
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(leftException);
    }

    [Fact]
    public void AdditionOperator_CombiningCrudResultTValueWithResultWhenRightHasException_ReturnsNewCrudResultTValueWithRightException() {
        // Arrange
        const string value = "Test value";
        var left = Success(value);
        var rightException = new Exception("Right exception");
        var right = Result.Error(rightException);

        // Act
        var result = left + right;

        // Assert
        result.Should().NotBeSameAs(left);
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(rightException);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Results\HttpResultTests.cs 
﻿using static DotNetToolbox.Results.HttpResult;

namespace DotNetToolbox.Results;

public class HttpResultTests {
    private static readonly HttpResult _ok = Ok();
    private static readonly HttpResult _created = Created();
    private static readonly HttpResult _unauthorized = Unauthorized();
    private static readonly HttpResult _notFound = NotFound();
    private static readonly HttpResult _conflict = Conflict();
    private static readonly HttpResult _badRequest = BadRequest(new ValidationError("Some error.", "Source"));
    private static readonly HttpResult _badRequestWithSameError = BadRequest(new ValidationError("Some error.", "Source"));
    private static readonly HttpResult _badRequestWithOtherError = BadRequest(new ValidationError("Other error.", "Source"));
    private static readonly HttpResult _failure = InternalError(new Exception("Some error."));

    private static readonly HttpResult<string> _okWithValue = Ok("Value");
    private static readonly HttpResult<string> _createdWithValue = Created("Value");
    private static readonly HttpResult<string> _unauthorizedWithValue = Unauthorized<string>();
    private static readonly HttpResult<string> _notFoundWithValue = NotFound<string>();
    private static readonly HttpResult<string> _conflictWithValue = Conflict("Value");
    private static readonly HttpResult<string> _badRequestWithValue = BadRequest("Value", new ValidationError("Some error.", "Source"));
    private static readonly HttpResult<string> _failureWithValue = InternalError<string>(new Exception("Some error."));

    [Fact]
    public void ImplicitConversion_FromValidationError_ReturnsFailure() {
        // Act
        HttpResult result = new ValidationError("Some error.", nameof(result));

        // Assert
        result.IsOk.Should().BeFalse();
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorArray_ReturnsFailure() {
        // Act
        HttpResult result = new[] { new ValidationError("Some error.", nameof(result)) };

        // Assert
        result.IsOk.Should().BeFalse();
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorList_ReturnsFailure() {
        // Act
        HttpResult result = new List<ValidationError> { new("Some error.", nameof(result)) };

        // Assert
        result.IsOk.Should().BeFalse();
    }

    private class TestDataForProperties : TheoryData<HttpResult, bool, bool, bool, bool, bool, bool> {
        public TestDataForProperties() {
            Add(_badRequest, true, false, false, false, false, false);
            Add(_failure, false, false, false, false, false, false);
            Add(_ok, false, true, false, false, false, false);
            Add(_notFound, false, false, true, false, false, false);
            Add(_conflict, false, false, false, true, false, false);
            Add(_created, false, false, false, false, true, false);
            Add(_unauthorized, false, false, false, false, false, true);
            Add(_badRequestWithValue, true, false, false, false, false, false);
            Add(_failureWithValue, false, false, false, false, false, false);
            Add(_okWithValue, false, true, false, false, false, false);
            Add(_notFoundWithValue, false, false, true, false, false, false);
            Add(_conflictWithValue, false, false, false, true, false, false);
            Add(_createdWithValue, false, false, false, false, true, false);
            Add(_unauthorizedWithValue, false, false, false, false, false, true);
        }
    }
    [Theory]
    [ClassData(typeof(TestDataForProperties))]
    public void Properties_ShouldReturnAsExpected(HttpResult subject, bool isBadRequest, bool isOk, bool isNotFound, bool isConflict, bool isCreated, bool isUnauthorized) {
        // Assert
        subject.IsBadRequest.Should().Be(isBadRequest);
        subject.IsOk.Should().Be(isOk);
        subject.WasNotFound.Should().Be(isNotFound);
        subject.HasConflict.Should().Be(isConflict);
        subject.WasCreated.Should().Be(isCreated);
        subject.IsUnauthorized.Should().Be(isUnauthorized);
    }

    private class TestDataForEquality : TheoryData<HttpResult, HttpResult?, bool> {
        public TestDataForEquality() {
            Add(_ok, null, false);
            Add(_ok, _ok, true);
            Add(_ok, _notFound, false);
            Add(_ok, _conflict, false);
            Add(_ok, _badRequest, false);
            Add(_notFound, null, false);
            Add(_notFound, _ok, false);
            Add(_notFound, _notFound, true);
            Add(_notFound, _conflict, false);
            Add(_notFound, _badRequest, false);
            Add(_conflict, null, false);
            Add(_conflict, _ok, false);
            Add(_conflict, _notFound, false);
            Add(_conflict, _conflict, true);
            Add(_conflict, _badRequest, false);
            Add(_badRequest, null, false);
            Add(_badRequest, _ok, false);
            Add(_badRequest, _notFound, false);
            Add(_badRequest, _conflict, false);
            Add(_badRequest, _badRequest, true);
            Add(_badRequest, _badRequestWithSameError, true);
            Add(_badRequest, _badRequestWithOtherError, false);
        }
    }

    [Theory]
    [ClassData(typeof(TestDataForEquality))]
    public void Equals_ReturnsAsExpected(HttpResult subject, HttpResult? other, bool expectedResult) {
        // Act
        var result = subject == other;

        // Assert
        result.Should().Be(expectedResult);
    }

    [Theory]
    [ClassData(typeof(TestDataForEquality))]
    public void NotEquals_ReturnsAsExpected(HttpResult subject, HttpResult? other, bool expectedResult) {
        // Act
        var result = subject != other;

        // Assert
        result.Should().Be(!expectedResult);
    }

    [Fact]
    public void GetHashCode_DifferentiatesAsExpected() {
        var expectedResult = new HashSet<HttpResult> {
            _ok,
            _badRequest,
            _badRequestWithOtherError,
        };

        // Act
        var result = new HashSet<HttpResult> {
            Ok(),
            Ok(),
            _ok,
            _ok,
            _badRequest,
            _badRequest,
            _badRequestWithSameError,
            _badRequestWithOtherError,
        };

        // Assert
        result.Should().BeEquivalentTo(expectedResult);
    }

    [Fact]
    public void Ok_CreatesResult() {
        // Arrange & Act
        var result = Ok();

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }

    [Fact]
    public void BadRequest_WithMessageOnly_CreatesResult() {
        // Arrange & Act
        var result = BadRequest(new ValidationError("Some error."));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void BadRequest_WithSourceAndMessage_CreatesResult() {
        // Arrange & Act
        var result = BadRequest(new ValidationError("Some error.", "Field1"));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEquivalentTo(new[] {
            new ValidationError("Some error.", "Field1"),
        });
    }

    [Fact]
    public void BadRequest_WithResult_CreatesResult() {
        // Arrange & Act
        var result = BadRequest(Result.Invalid("Some error."));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void AddOperator_WithoutError_ReturnsBadRequest() {
        // Arrange
        var result = Ok();

        // Act
        result += Result.Success();

        // Assert
        result.IsOk.Should().BeTrue();
        result.IsBadRequest.Should().BeFalse();
    }

    [Fact]
    public void AddOperator_WithOtherError_ReturnsBothErrors() {
        // Arrange
        var result = BadRequest(new ValidationError("Some error.", "Source"));

        // Act
        result += new ValidationError("Source", "Other error.");

        // Assert
        result.IsOk.Should().BeFalse();
        result.Errors.Should().HaveCount(2);
    }

    [Fact]
    public void AddOperator_WithSameError_ReturnsOnlyOneError() {
        // Arrange
        var result = BadRequest(new ValidationError("Some error.", "Source"));

        // Act
        result += new ValidationError("Some error.", "Source");

        // Assert
        result.IsOk.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void OfT_CopyConstructor_ClonesObject() {
        // Arrange
        var original = Ok(42);

        // Act
        var result = original with {
            Value = 7,
        };

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().Be(7);
    }

    [Fact]
    public void AddOperator_WithError_ReturnsBadRequest() {
        // Arrange
        var result = Ok("SomeToken");

        // Act
        result += new ValidationError("Some error.", "Source");

        // Assert
        result.IsOk.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_FromValue_ReturnsOk() {
        // Act
        HttpResult<string> subject = "Value";

        // Assert
        subject.Value.Should().Be("Value");
        subject.IsOk.Should().BeTrue();
    }

    [Fact]
    public void ImplicitConversion_FromOkResult_ReturnsOk() {
        // Act
        HttpResult<string> subject = Result.Success("Value");

        // Assert
        subject.Value.Should().Be("Value");
        subject.IsOk.Should().BeTrue();
    }

    [Fact]
    public void ImplicitConversion_FromBadRequestResult_ReturnsOk() {
        // Act
        var result = Result.Invalid("Value", "Some error.", "SomeProperty");
        HttpResult<string> subject = result;

        // Assert
        subject.Value.Should().Be("Value");
        subject.IsOk.Should().BeFalse();
        subject.Errors.Should().BeEquivalentTo(result.Errors);
    }

    [Fact]
    public void AddOperator_WithValueAndWithoutError_ReturnsBadRequest() {
        // Arrange
        var result = Ok("Value");

        // Act
        result += Result.Success();

        // Assert
        result.IsOk.Should().BeTrue();
        result.IsBadRequest.Should().BeFalse();
        result.Value.Should().Be("Value");
    }

    [Fact]
    public void AddOperator_WithValueAndWithError_ReturnsBadRequest() {
        // Arrange
        var result = Ok("Value");

        // Act
        result += new ValidationError("Some error.", "result");

        // Assert
        result.IsOk.Should().BeFalse();
        result.IsBadRequest.Should().BeTrue();
        result.Value.Should().Be("Value");
    }

    [Fact]
    public void MapTo_WithoutError_ReturnsOk() {
        // Arrange
        var subject = Ok("42");

        // Act
        var result = subject.MapTo(s => s is null ? default : int.Parse(s));

        // Assert
        result.Should().BeOfType<HttpResult<int>>();
        result.IsOk.Should().BeTrue();
    }

    [Fact]
    public void MapTo_FromNotFound_ReturnsOk() {
        // Arrange
        var subject = NotFound<string>();

        // Act
        var result = subject.MapTo(s => s is null ? default : int.Parse(s));

        // Assert
        result.Should().BeOfType<HttpResult<int>>();
        result.IsOk.Should().BeFalse();
        result.IsBadRequest.Should().BeFalse();
        result.WasNotFound.Should().BeTrue();
    }

    [Fact]
    public void MapTo_WithError_ReturnsBadRequest() {
        // Arrange
        var subject = BadRequest("42", new ValidationError("Some error.", "Field1"));

        // Act
        var result = subject.MapTo(s => s is null ? default : int.Parse(s));

        // Assert
        result.Should().BeOfType<HttpResult<int>>();
        result.IsOk.Should().BeFalse();
    }

    [Fact]
    public void OkOfT_CreatesResult() {
        // Arrange & Act
        var result = Ok(42);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }

    [Fact]
    public void BadRequestOfT_WithMessageOnly_CreatesResult() {
        // Arrange & Act
        var result = BadRequest(42, new ValidationError("Some error."));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void BadRequestOfT_WithSourceAndMessage_CreatesResult() {
        // Arrange & Act
        var result = BadRequest(42, new ValidationError("Some error.", "Field1"));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEquivalentTo(new[] {
            new ValidationError("Some error.", "Field1"),
        });
    }

    [Fact]
    public void BadRequestOfT_WithResult_CreatesResult() {
        // Arrange & Act
        var result = BadRequest(42, Result.Invalid("Some error."));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public async Task OkTask_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = OkTask();

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public async Task CreatedTask_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = CreatedTask();

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public async Task UnauthorizedTask_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = UnauthorizedTask();

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeFalse();
    }

    [Fact]
    public async Task NotFoundTask_ReturnsTaskWithNotFoundCrudResult() {
        // Act
        var task = NotFoundTask();

        // Assert
        var result = await task;
        result.WasNotFound.Should().BeTrue();
    }

    [Fact]
    public async Task ConflictTask_ReturnsTaskWithConflictCrudResult() {
        // Act
        var task = ConflictTask();

        // Assert
        var result = await task;
        result.HasConflict.Should().BeTrue();
    }

    [Fact]
    public async Task BadRequestTask_ReturnsTaskWithInvalidCrudResult() {
        // Act
        var task = BadRequestTask("Some error.");

        // Assert
        var result = await task;
        result.IsInvalid.Should().BeTrue();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public async Task OkTaskTValue_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = OkTask("Test value");

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().Be("Test value");
    }

    [Fact]
    public async Task CreatedTaskTValue_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = CreatedTask("Test value");

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().Be("Test value");
    }

    [Fact]
    public async Task UnauthorizedTaskTValue_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = UnauthorizedTask<string>();

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeFalse();
    }

    [Fact]
    public void MapTo_WhenMappingFunctionThrows_ResultsInErrorCrudResult() {
        // Arrange
        var result = Ok("42");
        static int MappingFunction(string _) => throw new InvalidOperationException();

        // Act
        var mappedResult = result.MapTo(MappingFunction!);

        // Assert
        mappedResult.Should().BeOfType<HttpResult<int>>();
        mappedResult.HasException.Should().BeTrue();
        mappedResult.Exception.Should().BeOfType<InvalidOperationException>();
    }

    [Fact]
    public void MapTo_WhenTypeIsNotFound_ReturnsNotFoundCrudResult() {
        // Arrange
        var result = NotFound<string>();

        // Act
        var mappedResult = result.MapTo(s => s!.Length);

        // Assert
        mappedResult.Should().BeOfType<HttpResult<int>>();
        mappedResult.WasNotFound.Should().BeTrue();
    }

    [Fact]
    public void Error_WithString_CreatesResultWithException() {
        // Arrange
        const string errorMessage = "Error message";

        // Act
        var result = InternalError(errorMessage);

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>();
        result.Exception!.Message.Should().Be(errorMessage);
    }

    [Fact]
    public void Error_WithException_CreatesResultWithException() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        var result = InternalError(exception);

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public async Task NotFoundTaskTValue_ReturnsTaskWithNotFoundHttpResult() {
        // Act
        var task = NotFoundTask<int>();

        // Assert
        var result = await task;
        result.WasNotFound.Should().BeTrue();
        result.Value.Should().Be(default);
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorToHttpResultTValue_ReturnsBadRequest() {
        // Act
        HttpResult<int> result = new ValidationError("Some error.", nameof(result));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
        result.Value.Should().Be(default);
    }

    [Fact]
    public void AdditionOperator_CombiningHttpResultWithError_ReturnsResultWithError() {
        // Arrange
        var result = Ok();
        var error = new ValidationError("Error message", "Property");

        // Act
        var combinedResult = result + error;

        // Assert
        combinedResult.HasErrors.Should().BeTrue();
        combinedResult.Errors.Should().ContainSingle(e => e.Message == "Error message" && e.Source == "Property");
    }

    // ... similar tests for other operator overloads ...

    [Fact]
    public void MapTo_WithException_ReturnsHttpResultTNewValueWithSameException() {
        // Arrange
        var exception = new Exception("Error message");
        var subject =  InternalError<int>(exception);

        // Act
        var result = subject.MapTo(value => value * 2);

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void ValueProperty_IsSetCorrectly() {
        // Arrange
        const string expectedValue = "Test value";

        // Act
        var result = Ok(expectedValue);

        // Assert
        result.Value.Should().Be(expectedValue);
    }

    // ... similar tests for other factory methods and implicit conversions that set Value ...

    [Fact]
    public void EnsureIsSuccess_WhenHasErrors_ThrowsValidationException() {
        // Arrange
        var result = BadRequest(new ValidationError("Error message"));

        // Act & Assert
        var action = () => result.EnsureIsSuccess();

        action.Should().Throw<ValidationException>().WithMessage(ValidationException.DefaultMessage);
    }

    [Fact]
    public void EnsureIsSuccess_WhenHasException_ThrowsValidationException() {
        // Arrange
        var exception = new Exception("Original exception");
        var result = InternalError(exception);

        // Act & Assert
        var action = () => result.EnsureIsSuccess();

        action.Should().Throw<ValidationException>().WithInnerException<Exception>().WithMessage("Original exception");
    }

    [Fact]
    public void TypeProperty_WhenHasException_ReturnsError() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        var result = InternalError(exception);

        // Assert
        result.Type.Should().Be(HttpResultType.Error);
    }

    [Fact]
    public async Task InternalErrorTask_WithString_ReturnsTaskWithErrorHttpResult() {
        // Arrange
        const string errorMessage = "Error message";

        // Act
        var task = InternalErrorTask(errorMessage);
        var result = await task;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>();
        result.Exception!.Message.Should().Be(errorMessage);
    }

    [Fact]
    public async Task InternalErrorTask_WithException_ReturnsTaskWithErrorHttpResult() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        var task = InternalErrorTask(exception);
        var result = await task;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromExceptionToHttpResult_CreatesResultWithException() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        HttpResult result = exception;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromStringToHttpResult_CreatesResultWithException() {
        // Act
        HttpResult result = "Error message";

        // Assert
        result.HasException.Should().BeFalse();
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorsToHttpResult_CreatesResultWithErrors() {
        // Arrange
        var errors = new ValidationErrors {
            new ValidationError("Error message", "Property"),
        };

        // Act
        HttpResult result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromHashSetValidationErrorToHttpResult_CreatesResultWithErrors() {
        // Arrange
        var errors = new HashSet<ValidationError> {
            new("Error message", "Property"),
        };

        // Act
        HttpResult result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromHttpResultToValidationErrorArray_ReturnsErrors() {
        // Arrange
        var errors = new[] { new ValidationError("Error message", "Property") };

        // Act
        ValidationErrors resultErrors = BadRequest(errors);
        ValidationError[] errorArray = BadRequest(errors);
        Exception? resultException = BadRequest(errors);

        // Assert
        resultErrors.Should().BeEquivalentTo(errors);
        errorArray.Should().BeEquivalentTo(errors);
        resultException.Should().BeNull();
    }

    [Fact]
    public void ImplicitConversion_FromHttpResultToException_ReturnsException() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        ValidationErrors resultErrors = InternalError(exception);
        ValidationError[] errorArray = InternalError(exception);
        Exception? resultException = InternalError(exception);

        // Assert
        resultErrors.Should().BeEmpty();
        errorArray.Should().BeEmpty();
        resultException.Should().BeSameAs(exception);
    }

    [Fact]
    public void ErrorOfT_WithString_CreatesResultWithException() {
        // Arrange
        const string errorMessage = "Error message";

        // Act
        var result =  InternalError<int>(errorMessage);

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>();
        result.Exception!.Message.Should().Be(errorMessage);
    }

    [Fact]
    public async Task ConflictTaskTValue_ReturnsTaskWithConflictHttpResult() {
        // Arrange
        const string value = "Test value";

        // Act
        var task = ConflictTask(value);
        var result = await task;

        // Assert
        result.HasConflict.Should().BeTrue();
        result.Value.Should().Be(value);
    }

    [Fact]
    public async Task BadRequestTaskTValue_ReturnsTaskWithInvalidHttpResult() {
        // Arrange
        const string value = "Test value";
        var errors = new[] { new ValidationError("Error message", "Property") };
        var invalidResult = Result.Invalid(errors);

        // Act
        var task = BadRequestTask(value, invalidResult);
        var result = await task;

        // Assert
        result.IsInvalid.Should().BeTrue();
        result.Value.Should().Be(value);
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public async Task InternalErrorTaskTValue_WithString_ReturnsTaskWithErrorHttpResult() {
        // Arrange
        const string errorMessage = "Error message";

        // Act
        var task = InternalErrorTask<int>(errorMessage);
        var result = await task;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>();
        result.Exception!.Message.Should().Be(errorMessage);
    }

    [Fact]
    public async Task InternalErrorTaskTValue_WithException_ReturnsTaskWithErrorHttpResult() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        var task = InternalErrorTask<int>(exception);
        var result = await task;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void AdditionOperator_LeftHasException_ReturnsLeft() {
        // Arrange
        var left = InternalError(new Exception("Left exception"));
        var right = Result.Success();

        // Act
        var result = left + right;

        // Assert
        result.Should().BeSameAs(left);
        result.HasException.Should().BeTrue();
        result.Exception!.Message.Should().Be("Left exception");
    }

    [Fact]
    public void AdditionOperator_RightHasException_ReturnsNewHttpResultWithRightException() {
        // Arrange
        var left = Ok();
        var rightException = new Exception("Right exception");
        var right = Result.Error(rightException);

        // Act
        var result = left + right;

        // Assert
        result.Should().NotBeSameAs(left);
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(rightException);
    }

    [Fact]
    public void AdditionOperator_NeitherHasException_ReturnsCombinedErrors() {
        // Arrange
        var leftErrors = new[] { new ValidationError("Left error", "LeftProperty") };
        var rightErrors = new[] { new ValidationError("Right error", "RightProperty") };
        var left = BadRequest(leftErrors);
        var right = Result.Invalid(rightErrors);

        // Act
        var result = left + right;

        // Assert
        result.HasException.Should().BeFalse();
        result.Errors.Should().HaveCount(2);
        result.Errors.Should().Contain(leftErrors.Union(rightErrors));
    }

    [Fact]
    public void AdditionOperator_NeitherHasExceptionAndDuplicateErrors_ReturnsDistinctErrors() {
        // Arrange
        var sharedError = new ValidationError("Shared error", "SharedProperty");
        var leftErrors = new[] { sharedError };
        var rightErrors = new[] { sharedError };
        var left = BadRequest(leftErrors);
        var right = Result.Invalid(rightErrors);

        // Act
        var result = left + right;

        // Assert
        result.HasException.Should().BeFalse();
        result.Errors.Should().ContainSingle(); // Only one instance of the shared error
        result.Errors.Should().Contain(sharedError);
    }

    [Fact]
    public void ImplicitConversion_FromExceptionToHttpResultTValue_CreatesResultWithException() {
        // Arrange
        var exception = new Exception("Test exception");

        // Act
        HttpResult<string> result = exception;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorArrayToHttpResultTValue_CreatesResultWithErrors() {
        // Arrange
        var errors = new[] { new ValidationError("Error 1", "Property1"), new ValidationError("Error 2", "Property2") };

        // Act
        HttpResult<string> result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorListToHttpResultTValue_CreatesResultWithErrors() {
        // Arrange
        var errors = new List<ValidationError> { new("Error 1", "Property1"), new("Error 2", "Property2") };

        // Act
        HttpResult<string> result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorHashSetToHttpResultTValue_CreatesResultWithErrors() {
        // Arrange
        var errors = new HashSet<ValidationError> { new("Error 1", "Property1"), new("Error 2", "Property2") };

        // Act
        HttpResult<string> result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromHttpResultTValueToValidationErrorArray_ReturnsErrors() {
        // Arrange
        var errors = new[] { new ValidationError("Error 1", "Property1"), new ValidationError("Error 2", "Property2") };
        var result = BadRequest("Value", errors);

        // Act
        ValidationErrors resultErrors = result;
        ValidationError[] errorArray = result;
        Exception? resultException = result;

        // Assert
        resultErrors.Should().BeEquivalentTo(errors);
        errorArray.Should().BeEquivalentTo(errors);
        resultException.Should().BeNull();
    }

    [Fact]
    public void ImplicitConversion_FromHttpResultTValueToException_ReturnsException() {
        // Arrange
        var exception = new Exception("Test exception");
        var result = InternalError<string>(exception);

        // Act
        ValidationErrors resultErrors = result;
        ValidationError[] errorArray = result;
        Exception? resultException = result;

        // Assert
        resultErrors.Should().BeEmpty();
        errorArray.Should().BeEmpty();
        resultException.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromHttpResultTValueToTValue_ReturnsValue() {
        // Arrange
        const string value = "Test value";
        var result = Ok(value);

        // Act
        string? resultValue = result;

        // Assert
        resultValue.Should().Be(value);
    }

    [Fact]
    public void AdditionOperator_CombiningHttpResultTValueWithResult_ReturnsCombinedErrors() {
        // Arrange
        const string value = "Test value";
        var leftErrors = new[] { new ValidationError("Left error", "LeftProperty") };
        var rightErrors = new[] { new ValidationError("Right error", "RightProperty") };
        var left = BadRequest(value, leftErrors);
        var right = Result.Invalid(rightErrors);

        // Act
        var result = left + right;

        // Assert
        result.HasException.Should().BeFalse();
        result.Value.Should().Be(value);
        result.Errors.Should().HaveCount(2);
        result.Errors.Should().Contain(leftErrors.Union(rightErrors));
    }

    [Fact]
    public void AdditionOperator_CombiningHttpResultTValueWithResultWhenLeftHasException_ReturnsLeft() {
        // Arrange
        var leftException = new Exception("Left exception");
        var left = InternalError<string>(leftException);
        var right = Result.Success();

        // Act
        var result = left + right;

        // Assert
        result.Should().BeSameAs(left);
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(leftException);
    }

    [Fact]
    public void AdditionOperator_CombiningHttpResultTValueWithResultWhenRightHasException_ReturnsNewHttpResultTValueWithRightException() {
        // Arrange
        const string value = "Test value";
        var left = Ok(value);
        var rightException = new Exception("Right exception");
        var right = Result.Error(rightException);

        // Act
        var result = left + right;

        // Assert
        result.Should().NotBeSameAs(left);
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(rightException);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Results\ResultTests.cs 
namespace DotNetToolbox.Results;

public class ResultTests {
    private static readonly Result _success = Result.Success();
    private static readonly Result _invalid = Result.Invalid("Some error.");
    private static readonly Result _invalidWithSameError = Result.Invalid("Some error.");
    private static readonly Result _invalidWithOtherError = Result.Invalid("Other error.");
    private static readonly Result _failure = Result.Error("Some error.");

    private static readonly Result<string> _successWithValue = Result.Success("42");
    private static readonly Result<string> _invalidWithValue = Result.Invalid<string>("42", "Some error.");
    private static readonly Result<string> _failureWithValue = Result.Error<string>("Some error.");

    [Fact]
    public void Success_CreatesSuccess() {
        // Act
        var result = _success with { };

        // Assert
        result.Type.Should().Be(ResultType.Success);
        result.IsSuccess.Should().BeTrue();
        result.IsInvalid.Should().BeFalse();
        result.IsFaulty.Should().BeFalse();
        result.Errors.Should().BeEmpty();
    }

    [Fact]
    public void ImplicitConversion_FromValidationError_ReturnsFailure() {
        // Act
        Result result = new ValidationError("Some error.", nameof(result));

        // Assert
        result.Type.Should().Be(ResultType.Invalid);
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsFaulty.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorArray_ReturnsFailure() {
        // Act
        Result result = new [] { new ValidationError("Some error.", nameof(result)) };

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsFaulty.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorList_ReturnsFailure() {
        // Act
        Result result = new List<ValidationError> { new("Some error.", nameof(result)) };

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsFaulty.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorSet_ReturnsFailure() {
        // Act
        Result result = new HashSet<ValidationError> { new("Some error.", nameof(result)) };

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsFaulty.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_FromException_ReturnsError() {
        // Act
        Result result = new InvalidOperationException("Some error.");

        // Assert
        result.Type.Should().Be(ResultType.Error);
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsFaulty.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }

    [Fact]
    public void ImplicitConversion_FromSuccess_ReturnsError() {
        // Act
        Exception? exception = _success;
        ValidationErrors errors = _success;

        // Assert
        exception.Should().BeNull();
        errors.Should().BeEmpty();
    }

    [Fact]
    public void ImplicitConversion_FromFailure_ReturnsError() {
        // Act
        ValidationErrors errors = _failure;
        ValidationError[] array = _failure;
        Exception? exception = _failure;

        // Assert
        array.Should().BeEmpty();
        errors.Should().BeEmpty();
        exception.Should().NotBeNull();
    }

    [Fact]
    public void ImplicitConversion_FromInvalid_ReturnsError() {
        // Act
        ValidationErrors errors = _invalid;
        ValidationError[] array = _invalid;
        Exception? exception = _invalid;

        // Assert
        array.Should().NotBeEmpty();
        errors.Should().NotBeEmpty();
        exception.Should().BeNull();
    }

    [Fact]
    public void AddOperator_FromSuccess_WithInvalid_ReturnsException() {
        // Arrange
        var result = Result.Success();

        // Act
        result += Result.Success() + new ValidationError("Some error.", "result");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsFaulty.Should().BeFalse();
    }

    [Fact]
    public void AddOperator_FromError_WithInvalid_ReturnsInvalid() {
        // Arrange
        var result = Result.Error(new Exception("Error"));

        // Act
        result += new ValidationError("Some error.", "result");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsFaulty.Should().BeTrue();
    }

    [Fact]
    public void AddOperator_FromSuccess_WithError_ReturnsException() {
        // Arrange
        var result = Result.Success();

        // Act
        result += new Exception("Some error.");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsFaulty.Should().BeTrue();
    }

    private class TestDataForEquality : TheoryData<Result, Result?, bool> {
        public TestDataForEquality() {
            Add(_success, null, false);
            Add(_success, _success, true);
            Add(_success, _invalid, false);
            Add(_invalid, null, false);
            Add(_invalid, _success, false);
            Add(_invalid, _invalid, true);
            Add(_invalid, _invalidWithSameError, true);
            Add(_invalid, _invalidWithOtherError, false);
        }
    }

    [Theory]
    [ClassData(typeof(TestDataForEquality))]
    public void Equals_ReturnsAsExpected(Result subject, Result? other, bool expectedResult) {
        // Act
        var result = subject == other;

        // Assert
        result.Should().Be(expectedResult);
    }

    [Theory]
    [ClassData(typeof(TestDataForEquality))]
    public void NotEquals_ReturnsAsExpected(Result subject, Result? other, bool expectedResult) {
        // Act
        var result = subject != other;

        // Assert
        result.Should().Be(!expectedResult);
    }

    [Fact]
    public void GetHashCode_DifferentiatesAsExpected() {
        var expectedResult = new HashSet<Result> {
            _success,
            _invalid,
            _invalidWithOtherError,
            _failure,
        };

        // Act
        var result = new HashSet<Result> {
            Result.Success(),
            Result.Success(),
            _success,
            _success,
            _invalid,
            _invalid,
            _invalidWithSameError,
            _invalidWithOtherError,
            _failure,
        };

        // Assert
        result.Should().BeEquivalentTo(expectedResult);
    }

    [Fact]
    public void ImplicitConversion_FromValue_ReturnsSuccess() {
        // Act
        Result<string> subject = "Value";

        // Assert
        subject.Value.Should().Be("Value");
        subject.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public void AddOperator_WithValueAndWithoutError_ReturnsInvalid() {
        // Arrange
        var result = _successWithValue;

        // Act
        result += Result.Success();

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().Be("42");
    }

    [Fact]
    public void AddOperator_WithValueAndWithError_ReturnsInvalid() {
        // Arrange
        var result = _successWithValue;

        // Act
        result += new ValidationError("Some error.", "result");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Value.Should().Be("42");
    }

    [Fact]
    public void MapTo_WithoutError_ReturnsSuccess() {
        // Arrange & Act
        var result = _successWithValue.MapTo(s => s is null ? default : int.Parse(s));

        // Assert
        result.Should().BeOfType<Result<int>>();
        result.IsSuccess.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }

    [Fact]
    public void MapTo_WithError_ReturnsInvalid() {
        // Arrange & Act
        var result = _invalidWithValue.MapTo(s => s is null ? default : int.Parse(s));

        // Assert
        result.Should().BeOfType<Result<int>>();
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().NotBeEmpty();
    }

    [Fact]
    public void MapTo_WithException_ReturnsError() {
        // Arrange & Act
        var result = _failureWithValue.MapTo(s => s is null ? (int?)null : int.Parse(s));

        // Assert
        result.Should().BeOfType<Result<int?>>();
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEmpty();
        result.IsFaulty.Should().BeTrue();
    }

    [Fact]
    public void SuccessWithValue_CreatesSuccess() {
        // Act
        var result = _successWithValue with { };

        // Assert
        result.Type.Should().Be(ResultType.Success);
        result.IsSuccess.Should().BeTrue();
        result.IsInvalid.Should().BeFalse();
        result.IsFaulty.Should().BeFalse();
        result.Errors.Should().BeEmpty();
        result.Value.Should().Be("42");
    }

    [Fact]
    public void ImplicitConversion_FromString_ReturnsInvalidResultWithSingleError() {
        // Act
        Result result = "Test error";

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().ContainSingle(e => e.Message == "Test error");
    }

    [Fact]
    public void ImplicitConversion_WithValue_FromValidationError_ReturnsFailure() {
        // Act
        Result<string> result = new ValidationError("Some error.", nameof(result));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsFaulty.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_WithValue_FromValidationErrorArray_ReturnsFailure() {
        // Act
        Result<string> result = new[] { new ValidationError("Some error.", nameof(result)) };

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsFaulty.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_WithValue_FromValidationErrorList_ReturnsFailure() {
        // Act
        Result<string> result = new List<ValidationError> { new("Some error.", nameof(result)) };

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsFaulty.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_WithValue_FromValidationErrorSet_ReturnsFailure() {
        // Act
        Result<string> result = new HashSet<ValidationError> { new("Some error.", nameof(result)) };

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsFaulty.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public void ImplicitConversion_WithValue_FromException_ReturnsError() {
        // Act
        Result<string> result = new InvalidOperationException("Some error.");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsFaulty.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }

    [Fact]
    public void ImplicitConversion_FromSuccessWithValue_ReturnsError() {
        // Act
        Exception? exception = _successWithValue;
        ValidationErrors errors = _successWithValue;
        string? value = _successWithValue;

        // Assert
        exception.Should().BeNull();
        errors.Should().BeEmpty();
        value.Should().Be("42");
    }

    [Fact]
    public void ImplicitConversion_FromFailureWithValue_ReturnsError() {
        // Act
        Exception? exception = _failureWithValue;
        ValidationErrors errors = _failureWithValue;
        ValidationError[] array = _failureWithValue;
        string? value = _failureWithValue;

        // Assert
        exception.Should().NotBeNull();
        array.Should().BeEmpty();
        errors.Should().BeEmpty();
        value.Should().BeNull();
    }

    [Fact]
    public void ImplicitConversion_FromInvalidWithValue_ReturnsError() {
        // Act
        Exception? exception = _invalidWithValue;
        ValidationErrors errors = _invalidWithValue;
        ValidationError[] array = _invalidWithValue;
        string? value = _invalidWithValue;

        // Assert
        exception.Should().BeNull();
        array.Should().NotBeEmpty();
        errors.Should().NotBeEmpty();
        value.Should().Be("42");
    }

    [Fact]
    public void EnsureIsSuccess_WhenResultHasException_ThrowsValidationException() {
        // Arrange
        var result = Result.Error("Test exception.");

        // Act & Assert
        var action = new Action(() => result.EnsureIsSuccess());

        action.Should().Throw<ValidationException>().WithMessage(ValidationException.DefaultMessage);
    }

    [Fact]
    public void EnsureIsSuccess_WhenResultHasErrors_ThrowsValidationException() {
        // Arrange
        var result = Result.Invalid("Test error");

        // Act & Assert
        var action = new Action(() => result.EnsureIsSuccess());

        action.Should().Throw<ValidationException>().WithMessage(ValidationException.DefaultMessage);
    }

    [Fact]
    public void AddOperator_WithValue_FromSuccess_WithInvalid_ReturnsException() {
        // Arrange
        var result = Result.Success("42");

        // Act
        result += Result.Success() + new ValidationError("Some error.", "result");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsFaulty.Should().BeFalse();
        result.Value.Should().Be("42");
    }

    [Fact]
    public void AddOperator_WithValue_FromError_WithInvalid_ReturnsInvalid() {
        // Arrange
        var result = Result.Error<string>(new Exception("Error"));

        // Act
        result += new ValidationError("Some error.", "result");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsFaulty.Should().BeTrue();
        result.Value.Should().BeNull();
    }

    [Fact]
    public void AddOperator_WithValue_FromSuccess_WithError_ReturnsException() {
        // Arrange
        var result = Result.Success("42");

        // Act
        result += new Exception("Some error.");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsFaulty.Should().BeTrue();
        result.Value.Should().BeNull();
    }

    [Fact]
    public void SuccessTValue_WithValue_SetsValueProperty() {
        // Arrange
        const string value = "Test value";

        // Act
        var result = Result.Success(value);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().Be(value);
    }

    [Fact]
    public void InvalidTValue_WithValue_SetsValueAndErrors() {
        // Arrange
        const string value = "Test value";
        const string message = "Test error";

        // Act
        var result = Result.Invalid<string>(value, message);

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Value.Should().Be(value);
        result.Errors.Should().ContainSingle(e => e.Message == message);
    }

    [Fact]
    public void ErrorTValue_WithValue_SetsExceptionProperty() {
        // Arrange
        var exception = new Exception("Test exception");

        // Act
        var result = Result.Error<string>(exception);

        // Assert
        result.HasException.Should().BeTrue();
        result.Value.Should().BeNull();
    }

    [Fact]
    public void MapTo_WhenMappingFunctionThrows_ResultsInErrorResult() {
        // Arrange
        var result = Result.Success("42");
        static int MappingFunction(string _) => throw new InvalidOperationException();

        // Act
        var mappedResult = result.MapTo(MappingFunction!);

        // Assert
        mappedResult.Should().BeOfType<Result<int>>();
        mappedResult.HasException.Should().BeTrue();
        mappedResult.Exception.Should().BeOfType<InvalidOperationException>();
    }

    // Additional tests for task-based factory methods
    [Fact]
    public async Task SuccessTask_ReturnsTaskWithSuccessResult() {
        // Act
        var task = Result.SuccessTask();

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public async Task InvalidTask_ReturnsTaskWithInvalidResult() {
        // Act
        var task = Result.InvalidTask("Test error");

        // Assert
        var result = await task;
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().ContainSingle(e => e.Message == "Test error");
    }

    [Fact]
    public async Task ErrorTask_ReturnsTaskWithErrorResult() {
        // Act
        var task = Result.ErrorTask("Test exception");

        // Assert
        var result = await task;
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>().Which.Message.Should().Be("Test exception");
    }
    [Fact]
    public void Invalid_WithoutParameters_ReturnsInvalidResultWithDefaultError() {
        // Act
        var result = Result.Invalid<string>("Some value.", "Some error.");

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().NotBeEmpty();
    }

    [Fact]
    public void Error_WithoutParameters_ReturnsErrorResultWithDefaultException() {
        // Act
        var result = Result.Error<string>("Some exception.");

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().NotBeNull();
    }

    [Fact]
    public void ResultTValue_Equals_WithDifferentResults_ReturnsFalse() {
        // Arrange
        var resultWithValue1 = Result.Success("Value1");
        var resultWithValue2 = Result.Invalid("Some error", "Value1");

        // Act
        var areEqual = resultWithValue1.Equals(resultWithValue2);

        // Assert
        areEqual.Should().BeFalse();
    }

    [Fact]
    public void ResultTValue_Equals_WithDifferentValues_ReturnsFalse() {
        // Arrange
        var resultWithValue1 = Result.Success("Value1");
        var resultWithValue2 = Result.Success("Value2");

        // Act
        var areEqual = resultWithValue1.Equals(resultWithValue2);

        // Assert
        areEqual.Should().BeFalse();
    }

    [Fact]
    public void ResultTValue_Equals_WithSameValues_ReturnsTrue() {
        // Arrange
        var resultWithValue1 = Result.Success("Value1");
        var resultWithValue2 = Result.Success("Value1");

        // Act
        var areEqual = resultWithValue1.Equals(resultWithValue2);

        // Assert
        areEqual.Should().BeTrue();
    }

    [Fact]
    public void ResultTValue_GetHashCode_WithDifferentValues_ProducesDifferentHashCodes() {
        // Arrange
        var resultWithValue1 = Result.Success("Value1");
        var resultWithValue2 = Result.Success("Value2");

        // Act
        var hashCode1 = resultWithValue1.GetHashCode();
        var hashCode2 = resultWithValue2.GetHashCode();

        // Assert
        hashCode1.Should().NotBe(hashCode2);
    }

    // Task-based factory methods tests for Result<TValue>
    [Fact]
    public async Task SuccessTaskTValue_ReturnsTaskWithSuccessResult() {
        // Act
        var task = Result.SuccessTask("Test value");

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().Be("Test value");
    }

    [Fact]
    public async Task InvalidTaskTValue_WithMessageAndSource_ReturnsTaskWithInvalidResult() {
        // Act
        var task = Result.InvalidTask("Test value", "Test error", "Test source");

        // Assert
        var result = await task;
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().ContainSingle(e => e.Message == "Test error" && e.Source == "Test source");
        result.Value.Should().Be("Test value");
    }

    [Fact]
    public async Task InvalidTaskTValue_WithResult_ReturnsTaskWithInvalidResult() {
        // Arrange
        var existingResult = Result.Invalid("Existing error");

        // Act
        var task = Result.InvalidTask("Test value", existingResult);

        // Assert
        var result = await task;
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().ContainSingle(e => e.Message == "Existing error");
        result.Value.Should().Be("Test value");
    }

    [Fact]
    public async Task ErrorTaskTValue_WithMessage_ReturnsTaskWithErrorResult() {
        // Act
        var task = Result.ErrorTask<string>("Test exception");

        // Assert
        var result = await task;
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>().Which.Message.Should().Be("Test exception");
        result.Value.Should().BeNull();
    }

    [Fact]
    public async Task ErrorTaskTValue_WithException_ReturnsTaskWithErrorResult() {
        // Arrange
        var exception = new InvalidOperationException("Test exception");

        // Act
        var task = Result.ErrorTask<string>(exception);

        // Assert
        var result = await task;
        result.HasException.Should().BeTrue();
        result.Exception.Should().Be(exception);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Results\SignInResultTests.cs 
using static DotNetToolbox.Results.SignInResult;

namespace DotNetToolbox.Results;

public class SignInResultTests {
    private static readonly SignInResult _invalid = new ValidationError("Some error.", "Source");
    private static readonly SignInResult _invalidWithSameError = new ValidationError("Some error.", "Source");
    private static readonly SignInResult _invalidWithOtherError = new ValidationError("Other error.", "Source");
    private static readonly SignInResult _locked = LockedAccount();
    private static readonly SignInResult _blocked = BlockedAccount();
    private static readonly SignInResult _failure = FailedAttempt();
    private static readonly SignInResult _requiresConfirmation = ConfirmationIsPending("SomeToken");
    private static readonly SignInResult _requires2Factor = TwoFactorIsRequired("SomeToken");
    private static readonly SignInResult _success = Success("SomeToken");
    private static readonly SignInResult _successWithSameToken = Success("SomeToken");
    private static readonly SignInResult _successWithOtherToken = Success("OtherToken");

    [Fact]
    public void Success_CreatesResult() {
        // Arrange & Act
        var result = Success("SomeToken") with { };

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Errors.Should().BeEmpty();
        result.Exception.Should().BeNull();
        result.Token.Should().Be("SomeToken");
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsBlocked.Should().BeFalse();
        result.IsLocked.Should().BeFalse();
        result.IsFailure.Should().BeFalse();
    }

    [Fact]
    public void RequiresTwoFactor_CreatesResult() {
        // Arrange & Act
        var result = TwoFactorIsRequired("SomeToken");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEmpty();
        result.Exception.Should().BeNull();
        result.Token.Should().Be("SomeToken");
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeTrue();
        result.IsInvalid.Should().BeFalse();
        result.IsBlocked.Should().BeFalse();
        result.IsLocked.Should().BeFalse();
        result.IsFailure.Should().BeFalse();
    }

    [Fact]
    public void RequiresConfirmation_CreatesResult() {
        // Arrange & Act
        var result = ConfirmationIsPending("SomeToken");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEmpty();
        result.Exception.Should().BeNull();
        result.Token.Should().Be("SomeToken");
        result.RequiresConfirmation.Should().BeTrue();
        result.RequiresTwoFactor.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsBlocked.Should().BeFalse();
        result.IsLocked.Should().BeFalse();
        result.IsFailure.Should().BeFalse();
    }

    [Fact]
    public void InvalidRequest_WithMessageOnly_CreatesResult() {
        // Arrange & Act
        var result = InvalidRequest("Some error.");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
        result.Exception.Should().BeNull();
        result.Token.Should().BeNull();
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsBlocked.Should().BeFalse();
        result.IsLocked.Should().BeFalse();
        result.IsFailure.Should().BeFalse();
    }

    [Fact]
    public void InvalidRequest_WithSourceAndMessage_CreatesResult() {
        // Arrange & Act
        var result = InvalidRequest(new ValidationError("Some error.", "Field1"));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
        result.Exception.Should().BeNull();
        result.Token.Should().BeNull();
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsBlocked.Should().BeFalse();
        result.IsLocked.Should().BeFalse();
        result.IsFailure.Should().BeFalse();
    }

    [Fact]
    public void InvalidRequest_WithResult_CreatesResult() {
        // Arrange & Act
        var result = InvalidRequest(Result.Invalid("Some error."));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
        result.Exception.Should().BeNull();
        result.Token.Should().BeNull();
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeFalse();
        result.IsInvalid.Should().BeTrue();
        result.IsBlocked.Should().BeFalse();
        result.IsLocked.Should().BeFalse();
        result.IsFailure.Should().BeFalse();
    }

    [Fact]
    public void BlockedAccount_WithMessageOnly_CreatesResult() {
        // Arrange & Act
        var result = BlockedAccount();

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEmpty();
        result.Exception.Should().BeNull();
        result.Token.Should().BeNull();
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsBlocked.Should().BeTrue();
        result.IsLocked.Should().BeFalse();
        result.IsFailure.Should().BeFalse();
    }

    [Fact]
    public void LockedAccount_CreatesResult() {
        // Arrange & Act
        var result = LockedAccount();

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEmpty();
        result.Exception.Should().BeNull();
        result.Token.Should().BeNull();
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsBlocked.Should().BeFalse();
        result.IsLocked.Should().BeTrue();
        result.IsFailure.Should().BeFalse();
    }

    [Fact]
    public void FailedAttempt_CreatesResult() {
        // Arrange & Act
        var result = FailedAttempt();

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEmpty();
        result.Exception.Should().BeNull();
        result.Token.Should().BeNull();
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsBlocked.Should().BeFalse();
        result.IsLocked.Should().BeFalse();
        result.IsFailure.Should().BeTrue();
    }

    [Fact]
    public void ErrorAttempt_CreatesResult() {
        // Arrange & Act
        var result = Error(new Exception("Message"));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEmpty();
        result.Exception.Should().NotBeNull();
        result.Token.Should().BeNull();
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsBlocked.Should().BeFalse();
        result.IsLocked.Should().BeFalse();
        result.IsFailure.Should().BeFalse();
    }

    [Fact]
    public void ErrorAttempt_WithMessage_CreatesResult() {
        // Arrange & Act
        var result = Error("Message");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().BeEmpty();
        result.Exception.Should().NotBeNull();
        result.Token.Should().BeNull();
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeFalse();
        result.IsInvalid.Should().BeFalse();
        result.IsBlocked.Should().BeFalse();
        result.IsLocked.Should().BeFalse();
        result.IsFailure.Should().BeFalse();
    }

    [Fact]
    public void ImplicitConversion_FromValidationError_ReturnsFailure() {
        // Act
        var result = (SignInResult)new ValidationError("Some error.", "Source");

        // Assert
        result.IsInvalid.Should().BeTrue();
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorArray_ReturnsFailure() {
        // Act
        SignInResult result = new[] { new ValidationError("Some error.", "Source") };

        // Assert
        result.IsInvalid.Should().BeTrue();
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorList_ReturnsFailure() {
        // Act
        SignInResult result = new List<ValidationError> { new("Some error.", "Source") };

        // Assert
        result.IsInvalid.Should().BeTrue();
    }

    private class TestDataForProperties : TheoryData<SignInResult, bool, bool, bool, bool, bool, bool, bool> {
        public TestDataForProperties() {
            Add(_invalid, true, false, false, false, false, false, false);
            Add(_blocked, false, true, false, false, false, false, false);
            Add(_locked, false, false, true, false, false, false, false);
            Add(_failure, false, false, false, true, false, false, false);
            Add(_requiresConfirmation, false, false, false, false, true, false, false);
            Add(_requires2Factor, false, false, false, false, false, true, false);
            Add(_success, false, false, false, false, false, false, true);
        }
    }
    [Theory]
    [ClassData(typeof(TestDataForProperties))]
    public void Properties_ShouldReturnAsExpected(SignInResult subject, bool isInvalid, bool isBlocked, bool isLocked, bool isFailure, bool confirmationRequired, bool twoFactorRequired, bool isSuccess) {
        // Assert
        subject.IsInvalid.Should().Be(isInvalid);
        subject.IsLocked.Should().Be(isLocked);
        subject.IsBlocked.Should().Be(isBlocked);
        subject.IsFailure.Should().Be(isFailure);
        subject.RequiresConfirmation.Should().Be(confirmationRequired);
        subject.RequiresTwoFactor.Should().Be(twoFactorRequired);
        subject.IsSuccess.Should().Be(isSuccess);
    }

    [Fact]
    public void GetHashCode_DifferentiatesAsExpected() {
        var expectedResult = new HashSet<SignInResult> {
            _success,
            _successWithOtherToken,
            _requires2Factor,
            _locked,
            _blocked,
            _failure,
            _invalid,
            _invalidWithOtherError,
        };

        // Act
        var result = new HashSet<SignInResult> {
            _success,
            _success,
            _successWithSameToken,
            _successWithOtherToken,
            _requires2Factor,
            _locked,
            _blocked,
            _failure,
            _invalid,
            _invalid,
            _invalidWithSameError,
            _invalidWithOtherError,
        };

        // Assert
        result.Should().BeEquivalentTo(expectedResult);
    }

    [Fact]
    public void AddOperator_WithoutError_ReturnsDoesNothing() {
        // Arrange
        var result = Success("SomeToken");

        // Act
        result += Result.Success();

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.IsInvalid.Should().BeFalse();
        result.Token.Should().Be("SomeToken");
    }

    [Fact]
    public void AddOperator_WithError_ReturnsInvalid() {
        // Arrange
        var result = Success("SomeToken");

        // Act
        result += new ValidationError("Some error.", "Source");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
        result.Token.Should().BeNull();
    }

    [Fact]
    public void AddOperator_WithOtherError_ReturnsBothErrors() {
        // Arrange
        var result = InvalidRequest(new ValidationError("Some error.", "Source"));

        // Act
        result += new ValidationError("Source", "Other error.");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().HaveCount(2);
    }

    [Fact]
    public void AddOperator_WithSameError_ReturnsOnlyOneError() {
        // Arrange
        var result = InvalidRequest(new ValidationError("Some error.", "Source"));

        // Act
        result += new ValidationError("Some error.", "Source");

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public async Task SuccessTask_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = SuccessTask("Test value");

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public async Task TwoFactorRequiredTask_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = TwoFactorIsRequiredTask("Test value");

        // Assert
        var result = await task;
        result.RequiresTwoFactor.Should().BeTrue();
    }

    [Fact]
    public async Task ConfirmationPendingTask_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = ConfirmationIsPendingTask("Test value");

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeFalse();
        result.RequiresConfirmation.Should().BeTrue();
    }

    [Fact]
    public async Task BlockedAccountTask_ReturnsTaskWithNotFoundCrudResult() {
        // Act
        var task = BlockedAccountTask();

        // Assert
        var result = await task;
        result.IsBlocked.Should().BeTrue();
        result.IsFailure.Should().BeFalse();
        result.IsLocked.Should().BeFalse();
    }

    [Fact]
    public async Task LockedAccountTask_ReturnsTaskWithConflictCrudResult() {
        // Act
        var task = LockedAccountTask();

        // Assert
        var result = await task;
        result.IsFailure.Should().BeFalse();
        result.IsLocked.Should().BeTrue();
        result.IsBlocked.Should().BeFalse();
    }

    [Fact]
    public async Task FailedAttemptTask_ReturnsTaskWithConflictCrudResult() {
        // Act
        var task = FailedAttemptTask();

        // Assert
        var result = await task;
        result.IsFailure.Should().BeTrue();
        result.IsLocked.Should().BeFalse();
        result.IsBlocked.Should().BeFalse();
    }

    [Fact]
    public async Task ErrorTask_ReturnsTaskWithConflictCrudResult() {
        // Act
        var task = ErrorTask("Some error.");

        // Assert
        var result = await task;
        result.HasException.Should().BeTrue();
    }

    [Fact]
    public async Task InvalidTask_ReturnsTaskWithInvalidCrudResult() {
        // Act
        var task = InvalidTask("Some error.");

        // Assert
        var result = await task;
        result.IsInvalid.Should().BeTrue();
        result.Errors.Should().ContainSingle();
    }

    [Fact]
    public async Task SuccessTaskTValue_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = SuccessTask("SomeToken");

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeTrue();
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeFalse();
        result.Token.Should().Be("SomeToken");
    }

    [Fact]
    public async Task TwoFactorRequiredTaskTValue_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = TwoFactorIsRequiredTask("SomeToken");

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeFalse();
        result.RequiresConfirmation.Should().BeFalse();
        result.RequiresTwoFactor.Should().BeTrue();
        result.Token.Should().Be("SomeToken");
    }

    [Fact]
    public async Task ConfirmationPendingTaskTValue_ReturnsTaskWithSuccessCrudResult() {
        // Act
        var task = ConfirmationIsPendingTask("SomeToken");

        // Assert
        var result = await task;
        result.IsSuccess.Should().BeFalse();
        result.RequiresConfirmation.Should().BeTrue();
        result.RequiresTwoFactor.Should().BeFalse();
        result.Token.Should().Be("SomeToken");
    }

    [Fact]
    public void Error_WithString_CreatesResultWithException() {
        // Arrange
        const string errorMessage = "Error message";

        // Act
        var result = Error(errorMessage);

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>();
        result.Exception!.Message.Should().Be(errorMessage);
    }

    [Fact]
    public void Error_WithException_CreatesResultWithException() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        var result = Error(exception);

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorToSignInResultTValue_ReturnsInvalid() {
        // Act
        SignInResult result = new ValidationError("Some error.", nameof(result));

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.Errors.Should().ContainSingle();
        result.Token.Should().BeNull();
    }

    [Fact]
    public void AdditionOperator_CombiningSignInResultWithError_ReturnsResultWithError() {
        // Arrange
        var result = Success("SomeToken");
        var error = new ValidationError("Error message", "Property");

        // Act
        var combinedResult = result + error;

        // Assert
        combinedResult.HasErrors.Should().BeTrue();
        combinedResult.Errors.Should().ContainSingle(e => e.Message == "Error message" && e.Source == "Property");
    }

    [Fact]
    public void TokenProperty_IsSetCorrectly() {
        // Arrange
        const string expectedValue = "Test value";

        // Act
        var result = Success(expectedValue);

        // Assert
        result.Token.Should().Be(expectedValue);
    }

    [Fact]
    public void EnsureIsSuccess_WhenHasErrors_ThrowsValidationException() {
        // Arrange
        var result = InvalidRequest(new ValidationError("Error message"));

        // Act & Assert
        var action = () => result.EnsureIsSuccess();

        action.Should().Throw<ValidationException>().WithMessage(ValidationException.DefaultMessage);
    }

    [Fact]
    public void EnsureIsSuccess_WhenHasException_ThrowsValidationException() {
        // Arrange
        var exception = new Exception("Original exception");
        var result = Error(exception);

        // Act & Assert
        var action = () => result.EnsureIsSuccess();

        action.Should().Throw<ValidationException>().WithInnerException<Exception>().WithMessage("Original exception");
    }

    [Fact]
    public void TypeProperty_WhenHasException_ReturnsError() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        var result = Error(exception);

        // Assert
        result.Type.Should().Be(SignInResultType.Error);
    }

    [Fact]
    public async Task ErrorTask_WithString_ReturnsTaskWithErrorSignInResult() {
        // Arrange
        const string errorMessage = "Error message";

        // Act
        var task = ErrorTask(errorMessage);
        var result = await task;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeOfType<Exception>();
        result.Exception!.Message.Should().Be(errorMessage);
    }

    [Fact]
    public async Task ErrorTask_WithException_ReturnsTaskWithErrorSignInResult() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        var task = ErrorTask(exception);
        var result = await task;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromHttpResultToValidationErrorArray_ReturnsErrors() {
        // Arrange
        var errors = new[] { new ValidationError("Error message", "Property") };

        // Act
        ValidationErrors resultErrors = InvalidRequest(errors);
        ValidationError[] errorArray = InvalidRequest(errors);
        Exception? resultException = InvalidRequest(errors);

        // Assert
        resultErrors.Should().BeEquivalentTo(errors);
        errorArray.Should().BeEquivalentTo(errors);
        resultException.Should().BeNull();
    }

    [Fact]
    public void ImplicitConversion_FromHttpResultToException_ReturnsException() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        ValidationErrors resultErrors = Error(exception);
        ValidationError[] errorArray = Error(exception);
        Exception? resultException = Error(exception);

        // Assert
        resultErrors.Should().BeEmpty();
        errorArray.Should().BeEmpty();
        resultException.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromExceptionToSignInResult_CreatesResultWithException() {
        // Arrange
        var exception = new Exception("Error message");

        // Act
        SignInResult result = exception;

        // Assert
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(exception);
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorsToSignInResult_CreatesResultWithErrors() {
        // Arrange
        var errors = new ValidationErrors {
            new ValidationError("Error message", "Property"),
        };

        // Act
        SignInResult result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void ImplicitConversion_FromHashSetValidationErrorToSignInResult_CreatesResultWithErrors() {
        // Arrange
        var errors = new HashSet<ValidationError> {
            new("Error message", "Property"),
        };

        // Act
        SignInResult result = errors;

        // Assert
        result.HasErrors.Should().BeTrue();
        result.Errors.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void AdditionOperator_LeftHasException_ReturnsLeft() {
        // Arrange
        var left = Error(new Exception("Left exception"));
        var right = Result.Success();

        // Act
        var result = left + right;

        // Assert
        result.Should().BeSameAs(left);
        result.HasException.Should().BeTrue();
        result.Exception!.Message.Should().Be("Left exception");
    }

    [Fact]
    public void AdditionOperator_RightHasException_ReturnsNewSignInResultWithRightException() {
        // Arrange
        var left = Success("SomeToken");
        var rightException = new Exception("Right exception");
        var right = Result.Error(rightException);

        // Act
        var result = left + right;

        // Assert
        result.Should().NotBeSameAs(left);
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(rightException);
    }

    [Fact]
    public void AdditionOperator_NeitherHasException_ReturnsCombinedErrors() {
        // Arrange
        var leftErrors = new[] { new ValidationError("Left error", "LeftProperty") };
        var rightErrors = new[] { new ValidationError("Right error", "RightProperty") };
        var left = InvalidRequest(leftErrors);
        var right = Result.Invalid(rightErrors);

        // Act
        var result = left + right;

        // Assert
        result.HasException.Should().BeFalse();
        result.Errors.Should().HaveCount(2);
        result.Errors.Should().Contain(leftErrors.Union(rightErrors));
    }

    [Fact]
    public void AdditionOperator_NeitherHasExceptionAndDuplicateErrors_ReturnsDistinctErrors() {
        // Arrange
        var sharedError = new ValidationError("Shared error", "SharedProperty");
        var leftErrors = new[] { sharedError };
        var rightErrors = new[] { sharedError };
        var left = InvalidRequest(leftErrors);
        var right = Result.Invalid(rightErrors);

        // Act
        var result = left + right;

        // Assert
        result.HasException.Should().BeFalse();
        result.Errors.Should().ContainSingle(); // Only one instance of the shared error
        result.Errors.Should().Contain(sharedError);
    }

    [Fact]
    public void AdditionOperator_CombiningSignInResultTValueWithResultWhenRightHasException_ReturnsNewSignInResultTValueWithRightException() {
        // Arrange
        const string value = "Test value";
        var left = Success(value);
        var rightException = new Exception("Right exception");
        var right = Result.Error(rightException);

        // Act
        var result = left + right;

        // Assert
        result.Should().NotBeSameAs(left);
        result.HasException.Should().BeTrue();
        result.Exception.Should().BeSameAs(rightException);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Results\ValidationErrorsTests.cs 
namespace DotNetToolbox.Results;

public class ValidationErrorsTests {
    [Fact]
    public void DefaultConstructor_ShouldCreateEmptyCollection() {
        // Arrange & Act
        // ReSharper disable once CollectionNeverUpdated.Local
        var errors = new ValidationErrors();

        // Assert
        errors.Should().BeEmpty();
    }

    [Fact]
    public void Constructor_WithIEnumerable_ShouldCreateCollectionWithDistinctErrors() {
        // Arrange
        var errorList = new List<ValidationError>
        {
            new("Error1"),
            new("Error1"),
            new("Error2"),
        };

        // Act
        var errors = new ValidationErrors(errorList);

        // Assert
        errors.Should().HaveCount(2);
        errors.Should().Contain(new ValidationError("Error1"));
        errors.Should().Contain(new ValidationError("Error2"));
    }

    [Fact]
    public void ImplicitConversion_FromString_ShouldCreateCollectionWithSingleError() {
        // Arrange & Act
        ValidationErrors errors = "Error1";

        // Assert
        errors.Should().ContainSingle(e => e.Message == "Error1");
    }

    [Fact]
    public void ImplicitConversion_ToList_ShouldCreateCollectionWithSingleError() {
        // Arrange & Act
        ValidationErrors errors = "Error1";

        // Act
        List<ValidationError> list = errors;

        // Assert
        list.Should().ContainSingle(e => e.Message == "Error1");
    }

    [Fact]
    public void ImplicitConversion_ToHashSetString_ShouldCreateCollectionWithSingleError() {
        // Arrange & Act
        ValidationErrors errors = "Error1";

        // Act
        HashSet<ValidationError> set = errors;

        // Assert
        set.Should().ContainSingle(e => e.Message == "Error1");
    }

    [Fact]
    public void AdditionOperator_ShouldCombineDistinctErrorsFromTwoCollections() {
        // Arrange
        ValidationErrors errors1 = new ValidationError("Error1");
        ValidationErrors errors2 = new ValidationError("Error2");

        // Act
        var combinedErrors = errors1 + errors2;

        // Assert
        combinedErrors.Should().HaveCount(2);
        combinedErrors.Should().Contain(new ValidationError("Error1"));
        combinedErrors.Should().Contain(new ValidationError("Error2"));
    }

    [Fact]
    public void Add_ShouldAddErrorIfNotAlreadyPresent() {
        // Arrange
        var errors = new ValidationErrors();
        var error = new ValidationError("Error1");

        // Act
        errors.Add(error);

        // Assert
        errors.Should().ContainSingle(e => e.Message == "Error1");
    }

    [Fact]
    public void IListAdd_ShouldAddErrorIfNotAlreadyPresent() {
        // Arrange
        IList errors = new ValidationErrors();
        object error = new ValidationError("Error1");

        // Act
        errors.Add(error);

        // Assert
        errors.Cast<ValidationError>().Should().ContainSingle(e => e.Message == "Error1");
    }

    [Fact]
    public void IReadOnlyListIndexer_ShouldReturnCorrectError() {
        // Arrange
        IReadOnlyList<ValidationError> errors = new ValidationErrors(new[] { new ValidationError("Error1") });

        // Act
        var error = errors[0];

        // Assert
        error.Message.Should().Be("Error1");
    }

    [Fact]
    public void ImplicitConversion_FromValidationErrorArray_ShouldCreateCollectionWithDistinctErrors() {
        // Arrange
        // Act
        ValidationErrors errors = new[] {
            new ValidationError("Error1"),
            new ValidationError("Error1"),
        };

        // Assert
        errors.Should().ContainSingle();
        errors.Should().Contain(new ValidationError("Error1"));
    }

    [Fact]
    public void ImplicitConversion_ToValidationErrorArray_ShouldReturnArrayWithAllErrors() {
        // Arrange
        var errors = new ValidationErrors(new[] {
            new ValidationError("Error1"),
            new ValidationError("Error2"),
        });

        // Act
        ValidationError[] errorArray = errors;

        // Assert
        errorArray.Should().BeEquivalentTo(errors);
    }

    [Fact]
    public void AdditionOperator_WithSingleValidationError_ShouldAddErrorIfNotPresent() {
        // Arrange
        var errors = new ValidationErrors();
        var error = new ValidationError("Error1");

        // Act
        errors += error;

        // Assert
        errors.Should().ContainSingle(e => e.Message == "Error1");
    }

    [Fact]
    public void Indexer_GetterAndSetter_ShouldGetAndSetCorrectly() {
        // Arrange
        var errors = new ValidationErrors();
        var error = new ValidationError("Error1");
        errors.Add(error);

        // Act
        var retrievedError = errors[0];
        errors[0] = new("Error2");
        var updatedError = errors[0];

        // Assert
        retrievedError.Should().Be(error);
        updatedError.Message.Should().Be("Error2");
    }

    [Fact]
    public void IListAdd_WithNonValidationError_ShouldThrowArgumentException() {
        // Arrange
        // ReSharper disable once CollectionNeverQueried.Local
        IList errors = new ValidationErrors();

        // Act
        Action act = () => errors.Add("Not a ValidationError");

        // Assert
        act.Should().Throw<ArgumentException>();
    }

    [Fact]
    public void Add_WithDuplicateError_ShouldNotChangeCollection() {
        // Arrange
        var errors = new ValidationErrors();
        var error = new ValidationError("Error1");
        errors.Add(error);

        // Act
        errors.Add(error);

        // Assert
        errors.Should().ContainSingle();
    }

    [Fact]
    public void Insert_AddsItem() {
        // Arrange
        // ReSharper disable once CollectionNeverQueried.Local
        var errors = new ValidationErrors();
        var error1 = new ValidationError("Error1");
        var error2 = new ValidationError("Error2");
        errors.Add(error1);

        // Act
        errors.Insert(0, error2);

        // Assert
        errors[0].Should().BeEquivalentTo(error2);
        errors[1].Should().BeEquivalentTo(error1);
    }

    [Fact]
    public void Insert_WithDuplicateErrorAtSameIndex_ShouldNotThrow() {
        // Arrange
        // ReSharper disable once CollectionNeverQueried.Local
        var errors = new ValidationErrors();
        var error1 = new ValidationError("Error1");
        var error2 = new ValidationError("Error2");
        errors.Add(error1);
        errors.Add(error2);

        // Act
        var act1 = () => errors.Insert(0, error1);

        // Assert
        act1.Should().NotThrow();
    }

    [Fact]
    public void Insert_WithDuplicateErrorAtDifferentIndex_ShouldThrow() {
        // Arrange
        // ReSharper disable once CollectionNeverQueried.Local
        var errors = new ValidationErrors();
        var error1 = new ValidationError("Error1");
        var error2 = new ValidationError("Error2");
        errors.Add(error1);
        errors.Add(error2);

        // Act
        var act1 = () => errors.Insert(1, error1);

        // Assert
        act1.Should().Throw<InvalidOperationException>();
    }

    [Fact]
    public void Remove_RemovesItem() {
        // Arrange
        // ReSharper disable once CollectionNeverQueried.Local
        var errors = new ValidationErrors();
        var error1 = new ValidationError("Error1");
        var error2 = new ValidationError("Error2");
        errors.Add(error1);
        errors.Add(error2);

        // Act
        errors.Remove(error1);

        // Assert
        errors.Should().ContainSingle();
        errors[0].Should().BeEquivalentTo(error2);
    }

    [Fact]
    public void RemoveAt_RemovesItem() {
        // Arrange
        // ReSharper disable once CollectionNeverQueried.Local
        var errors = new ValidationErrors();
        var error1 = new ValidationError("Error1");
        var error2 = new ValidationError("Error2");
        errors.Add(error1);
        errors.Add(error2);

        // Act
        errors.RemoveAt(0);

        // Assert
        errors.Should().ContainSingle();
        errors[0].Should().BeEquivalentTo(error2);
    }

    [Fact]
    public void Clear_RemovesAllItems() {
        // Arrange
        // ReSharper disable once CollectionNeverQueried.Local
        var errors = new ValidationErrors();
        var error1 = new ValidationError("Error1");
        var error2 = new ValidationError("Error2");
        errors.Add(error1);
        errors.Add(error2);

        // Act
        errors.Clear();

        // Assert
        errors.Should().BeEmpty();
    }
    [Fact]
    public void Add_WithString_ShouldCreateValidationErrorAndAddIfNotPresent() {
        // Arrange
        #pragma warning disable IDE0028
        var errors = new ValidationErrors();
        #pragma warning restore IDE0028

        // Act
        errors.Add("Error1");

        // Assert
        errors.Should().ContainSingle(e => e.Message == "Error1");
    }

    [Fact]
    public void Contains_WithString_ShouldReturnTrueIfErrorPresent() {
        // Arrange
        var errors = new ValidationErrors { new ValidationError("Error1") };

        // Act
        var contains = errors.Contains("Error1");

        // Assert
        contains.Should().BeTrue();
    }

    [Fact]
    public void IndexOf_WithString_ShouldReturnCorrectIndexIfErrorPresent() {
        // Arrange
        var errors = new ValidationErrors { "Error1" };

        // Act
        var index = errors.IndexOf("Error1");

        // Assert
        index.Should().Be(0);
    }

    [Fact]
    public void Insert_WithString_ShouldCreateValidationErrorAndInsertAtSpecifiedIndex() {
        // Arrange
        var errors = new ValidationErrors { "Error1" };

        // Act
        errors.Insert(0, "Error2");

        // Assert
        errors.IndexOf("Error2").Should().Be(0);
    }

    [Fact]
    public void Remove_WithString_ShouldRemoveValidationErrorIfPresent() {
        // Arrange
        var errors = new ValidationErrors { "Error1" };

        // Act
        errors.Remove("Error1");

        // Assert
        errors.Should().BeEmpty();
    }

    // Tests for explicit interface implementations
    [Fact]
    public void IList_Contains_WithValidationError_ShouldReturnTrueIfPresent() {
        // Arrange
        IList errors = new ValidationErrors();
        var error = new ValidationError("Error1");
        errors.Add(error);

        // Act
        var contains = errors.Contains(error);

        // Assert
        contains.Should().BeTrue();
    }

    [Fact]
    public void IList_IndexOf_WithValidationError_ShouldReturnCorrectIndex() {
        // Arrange
        IList errors = new ValidationErrors();
        var error = new ValidationError("Error1");
        errors.Add(error);

        // Act
        var index = errors.IndexOf(error);

        // Assert
        index.Should().Be(0);
    }

    [Fact]
    public void IList_Insert_WithValidationError_ShouldInsertAtSpecifiedIndex() {
        // Arrange
        IList errors = new ValidationErrors();
        var error = new ValidationError("Error1");

        // Act
        errors.Insert(0, error);

        // Assert
        errors[0].Should().Be(error);
    }

    [Fact]
    public void IList_Remove_WithValidationError_ShouldRemoveIfPresent() {
        // Arrange
        IList errors = new ValidationErrors();
        var error = new ValidationError("Error1");
        errors.Add(error);

        // Act
        errors.Remove(error);

        // Assert
        errors.Cast<ValidationError>().Should().BeEmpty();
    }

    [Fact]
    public void ICollection_IsSynchronized_ShouldReturnFalse() {
        // Arrange
        // ReSharper disable once CollectionNeverUpdated.Local
        ICollection errors = new ValidationErrors();

        // Act & Assert
        errors.IsSynchronized.Should().BeFalse();
    }

    [Fact]
    public void ICollection_SyncRoot_ShouldNotBeNull() {
        // Arrange
        // ReSharper disable once CollectionNeverUpdated.Local
        ICollection errors = new ValidationErrors();

        // Act & Assert
        errors.SyncRoot.Should().NotBeNull();
    }

    [Fact]
    public void IList_SetterAtIndex_ShouldUpdateValidationError() {
        // Arrange
        #pragma warning disable IDE0028
        IList errors = new ValidationErrors();
        errors.Add(new ValidationError("Error1"));
        #pragma warning restore IDE0028
        var newError = new ValidationError("Error2");

        // Act
        errors[0] = newError;

        // Assert
        errors[0].Should().Be(newError);
    }

    [Fact]
    public void IList_SetterAtIndex_WithString_ShouldUpdateValidationError() {
        // Arrange
        #pragma warning disable IDE0028
        IList errors = new ValidationErrors();
        errors.Add(new ValidationError("Error1"));
        #pragma warning restore IDE0028

        // Act
        errors[0] = "Error2";

        // Assert
        errors.Cast<ValidationError>().ToArray()[0].Message.Should().Be("Error2");
    }

    [Fact]
    public void CopyTo_NonGenericArray_ShouldCopyAllElementsToSpecifiedArrayIndex() {
        // Arrange
        var errors = new ValidationErrors(new[] { new ValidationError("Error1"), new ValidationError("Error2") });
        Array array = new ValidationError[3];

        // Act
        errors.CopyTo(array, 1);

        // Assert
        array.GetValue(1).Should().BeEquivalentTo(new ValidationError("Error1"));
        array.GetValue(2).Should().BeEquivalentTo(new ValidationError("Error2"));
    }

    [Fact]
    public void IsReadOnly_ShouldReturnFalse() {
        // Arrange
        // ReSharper disable once CollectionNeverUpdated.Local
        var errors = new ValidationErrors();

        // Act & Assert
        errors.IsReadOnly.Should().BeFalse();
    }

    [Fact]
    public void IList_IsFixedSize_ShouldReturnFalse() {
        // Arrange
        // ReSharper disable once CollectionNeverUpdated.Local
        IList errors = new ValidationErrors();

        // Act & Assert
        errors.IsFixedSize.Should().BeFalse();
    }

    [Fact]
    public void ICollectionOfValidationError_Clear_ShouldRemoveAllErrors() {
        // Arrange
        #pragma warning disable IDE0028
        ICollection<ValidationError> errors = new ValidationErrors();
        errors.Add(new("Error1"));
        #pragma warning restore IDE0028

        // Act
        errors.Clear();

        // Assert
        errors.Should().BeEmpty();
    }

    [Fact]
    public void IListOfValidationError_RemoveAt_ShouldRemoveErrorAtIndex() {
        // Arrange
        #pragma warning disable IDE0028
        IList<ValidationError> errors = new ValidationErrors();
        errors.Add(new("Error1"));
        errors.Add(new("Error2"));
        #pragma warning restore IDE0028

        // Act
        errors.RemoveAt(0);

        // Assert
        errors.Should().ContainSingle();
        errors[0].Message.Should().Be("Error2");
    }

    [Fact]
    public void IEnumerable_GetEnumerator_ShouldReturnEnumeratorThatIteratesOverAllErrors() {
        // Arrange
        IEnumerable errorsEnumerable = new ValidationErrors(new[] {
            new ValidationError("Error1"),
            new ValidationError("Error2"),
        });
        var expectedErrors = new List<ValidationError> {
           new("Error1"),
           new("Error2"),
        };

        // Act
        var errorsList = new List<ValidationError>();
        // ReSharper disable once LoopCanBeConvertedToQuery
        foreach (ValidationError error in errorsEnumerable) {
            errorsList.Add(error);
        }

        // Assert
        errorsList.Should().BeEquivalentTo(expectedErrors);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Results\ValidationErrorTests.cs 
namespace DotNetToolbox.Results;

public class ValidationErrorTests {
    [Fact]
    public void DefaultConstructor_CreatesNewError() {
        // Arrange
        var error1 = new ValidationError();

        // Act
        var error2 = error1 with { };

        // Assert
        error2.Should().NotBeSameAs(error1);
        error1.Message.Should().Be(ValidationError.DefaultErrorMessage);
        error1.Source.Should().BeEmpty();
        error1.ToString().Should().Be("The value is invalid.");
    }

    [Fact]
    public void WithSourceAndMessage_ReturnsFormattedMessage() {
        // Arrange
        var error1 = new ValidationError("Some message.", "Field");

        // Act
        var error2 = error1 with { };

        // Assert
        error2.Should().NotBeSameAs(error1);
        error1.Message.Should().Be("Some message.");
        error1.Source.Should().Be("Field");
        error1.ToString().Should().Be("Field: Some message.");
    }

    [Theory]
    [InlineData("Some message 1.")]
    [InlineData("Some message with 42.")]
    public void FormattedMessage_WithoutSource_ReturnsMessage(string message) {
        // Act
        var error = new ValidationError(message);

        // Assert
        error.Source.Should().Be(string.Empty);
        error.Message.Should().Be(message);
    }

    [Fact]
    public void Equality_ShouldReturnAsExpected() {
        var subject = new ValidationError("Break message data", "field");
        var same = new ValidationError("Break message data", "field");
        var otherSource = new ValidationError("Break message data", "otherField");
        var otherMessage = new ValidationError("Other message data", "field");

        //Act
        var resultForNull = subject == null!;
        var resultForOtherSource = subject != otherSource;
        var resultForOtherTemplate = subject != otherMessage;
        var resultForSame = subject == same;

        //Assert
        resultForNull.Should().BeFalse();
        resultForOtherSource.Should().BeTrue();
        resultForOtherTemplate.Should().BeTrue();
        resultForSame.Should().BeTrue();
    }

    [Fact]
    public void GetHashCode_ShouldReturnAsExpected() {
        // Arrange & Act
        var errorSet = new HashSet<ValidationError> {
            new("Source 1", "Some message 1 42."),
            new("Source 1", "Some message 1 42."),
            new(" Source 1 ", "Some message 1 42."),
            new("Source 1", "Some message 1 42."),
            new("Source 2", "Some message 1 42."),
            new("Source 1", "Some message 2 42."),
            new("Source 1", "Some message 1 7."),
        };

        // Assert
        errorSet.Should().BeEquivalentTo(new ValidationError[] {
            new("Source 1", "Some message 1 42."),
            new("Source 2", "Some message 1 42."),
            new("Source 1", "Some message 2 42."),
            new("Source 1", "Some message 1 7."),
        });
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Results\ValidationExceptionTests.cs 
namespace DotNetToolbox.Results;

public class ValidationExceptionTests {
    [Fact]
    public void Constructor_WithMessageOnly_CreatesException() {
        // Arrange & Act
        var exception = new ValidationException("Some error.");

        // Assert
        exception.Errors.Should().ContainSingle();
        exception.Message.Should().Be("Some error.");
        exception.InnerException.Should().BeNull();
    }

    [Fact]
    public void Constructor_WithMessageAndInnerException_CreatesException() {
        // Arrange & Act
        var exception = new ValidationException("Some error.", new InvalidOperationException());

        // Assert
        exception.Errors.Should().ContainSingle();
        exception.Message.Should().Be("Some error.");
        exception.InnerException.Should().NotBeNull();
    }

    [Fact]
    public void Constructor_WithInnerException_CreatesException() {
        // Arrange
        var inner = new InvalidOperationException();

        // Act
        var exception = new ValidationException(inner);

        // Assert
        exception.Errors.Should().ContainSingle();
        exception.Errors[0].Message.Should().Be(ValidationError.DefaultErrorMessage);
        exception.Message.Should().Be(ValidationException.DefaultMessage);
        exception.InnerException.Should().NotBeNull();
    }

    [Fact]
    public void Constructor_WithSourceAndMessage_CreatesException() {
        // Arrange & Act
        var exception = new ValidationException("Some error.", "Field1");

        // Assert
        exception.Errors.Should().ContainSingle();
        exception.Message.Should().Be("Field1: Some error.");
        exception.InnerException.Should().BeNull();
    }

    [Fact]
    public void Constructor_WithSourceAndMessageAndInnerException_CreatesException() {
        // Arrange & Act
        var exception = new ValidationException("Some error.", "Field1", new InvalidOperationException());

        // Assert
        exception.Errors.Should().ContainSingle();
        exception.Message.Should().Be("Field1: Some error.");
        exception.InnerException.Should().NotBeNull();
    }

    [Fact]
    public void Constructor_WithOneError_CreatesException() {
        // Arrange
        var error1 = new ValidationError("Some error 42.");

        // Act
        var exception = new ValidationException(error1);

        // Assert
        exception.Errors.Should().BeEquivalentTo(new[] { error1 });
        exception.Message.Should().Be("Validation failed.");
        exception.InnerException.Should().BeNull();
    }

    [Fact]
    public void Constructor_WithOneErrorAndException_CreatesException() {
        // Arrange
        var error1 = new ValidationError("Some error 42.");

        // Act
        var exception = new ValidationException(error1, new InvalidOperationException());

        // Assert
        exception.Errors.Should().BeEquivalentTo(new[] { error1 });
        exception.Message.Should().Be("Validation failed.");
        exception.InnerException.Should().NotBeNull();
    }

    [Fact]
    public void Constructor_WithErrorCollection_CreatesException() {
        // Arrange
        var error1 = new ValidationError("Some global error 42.");
        var error2 = new ValidationError("Some other error 13.", "Field1");

        // Act
        var exception = new ValidationException(new[] { error1, error2 });

        // Assert
        exception.Errors.Should().BeEquivalentTo(new[] { error1, error2 });
        exception.Message.Should().Be("Validation failed.");
        exception.InnerException.Should().BeNull();
    }

    [Fact]
    public void Constructor_WithErrorCollectionAndException_CreatesException() {
        // Arrange
        var error1 = new ValidationError("Some global error 42.");
        var error2 = new ValidationError("Some other error 13.", "Field1");

        // Act
        var exception = new ValidationException(new[] { error1, error2 }, new InvalidOperationException());

        // Assert
        exception.Errors.Should().BeEquivalentTo(new[] { error1, error2 });
        exception.Message.Should().Be("Validation failed.");
        exception.InnerException.Should().NotBeNull();
    }

    [Fact]
    public void Constructor_WithAllButSingleError_CreatesException() {
        // Arrange
        var error1 = new ValidationError("Some global error 42.");

        // Act
        var exception = new ValidationException("Some message.", "Field1", error1);

        // Assert
        exception.Errors.Should().BeEquivalentTo(new[] { error1 });
        exception.Message.Should().Be("Field1: Some message.");
        exception.InnerException.Should().BeNull();
    }

    [Fact]
    public void Constructor_WithAllButSingleErrorAndException_CreatesException() {
        // Arrange
        var error1 = new ValidationError("Some global error 42.");

        // Act
        var exception = new ValidationException("Some message.", "Field1", error1, new InvalidOperationException());

        // Assert
        exception.Errors.Should().BeEquivalentTo(new[] { error1 });
        exception.Message.Should().Be("Field1: Some message.");
        exception.InnerException.Should().NotBeNull();
    }

    [Fact]
    public void Constructor_WithAllArguments_CreatesException() {
        // Arrange
        var error1 = new ValidationError("Some global error 42.");
        var error2 = new ValidationError("Some other error 13.", "Field1");

        // Act
        var exception = new ValidationException("Some message.", "Field1", new[] { error1, error2 }, new InvalidOperationException());

        // Assert
        exception.Errors.Should().BeEquivalentTo(new[] { error1, error2 });
        exception.Message.Should().Be("Field1: Some message.");
        exception.InnerException.Should().NotBeNull();
    }

    [Fact]
    public void Constructor_WithNullSource_CreatesException() {
        // Arrange
        var error1 = new ValidationError("Some global error 42.");

        // Act
        var exception = new ValidationException("Some message.", null!, error1);

        // Assert
        exception.Errors.Should().BeEquivalentTo(new[] { error1 });
        exception.Message.Should().Be("Some message.");
        exception.InnerException.Should().BeNull();
    }

    [Fact]
    public void Constructor_WithNullSourceAndException_CreatesException() {
        // Arrange
        var error1 = new ValidationError("Some global error 42.");

        // Act
        var exception = new ValidationException("Some message.", null!, error1, new InvalidOperationException());

        // Assert
        exception.Errors.Should().BeEquivalentTo(new[] { error1 });
        exception.Message.Should().Be("Some message.");
        exception.InnerException.Should().NotBeNull();
    }

    [Fact]
    public void Constructor_WithAllArgumentsAndNullSource_CreatesException() {
        // Arrange
        var error1 = new ValidationError("Some global error 42.");
        var error2 = new ValidationError("Some other error 13.", "Field1");

        // Act
        var exception = new ValidationException("Some message.", null!, new[] { error1, error2 }, new InvalidOperationException());

        // Assert
        exception.Errors.Should().BeEquivalentTo(new[] { error1, error2 });
        exception.Message.Should().Be("Some message.");
        exception.InnerException.Should().NotBeNull();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Singleton\HasDefaultTests.cs 
﻿namespace DotNetToolbox.Singleton;

public class HasDefaultTests {
    private class ClassHasDefault : HasDefault<ClassHasDefault>;

    [Fact]
    public void Static_Default_ReturnsSingleton() {
        // Arrange & Act
        var instance1 = ClassHasDefault.Default;
        var instance2 = ClassHasDefault.Default;

        // Assert
        instance1.Should().BeOfType<ClassHasDefault>();
        instance1.Should().BeSameAs(instance2);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Singleton\HasEmptyTests.cs 
﻿namespace DotNetToolbox.Singleton;

public class HasEmptyTests {
    private class ClassWithEmpty : HasEmpty<ClassWithEmpty>;

    [Fact]
    public void Static_Empty_ReturnsSingleton() {
        // Arrange & Act
        var instance1 = ClassWithEmpty.Empty;
        var instance2 = ClassWithEmpty.Empty;

        // Assert
        instance1.Should().BeOfType<ClassWithEmpty>();
        instance1.Should().BeSameAs(instance2);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Singleton\HasInstanceTests.cs 
﻿namespace DotNetToolbox.Singleton;

public class HasInstanceTests {
    private class ClassWithInstance : HasInstance<ClassWithInstance>;

    [Fact]
    public void Static_Instance_ReturnsSingleton() {
        // Arrange & Act
        var instance1 = ClassWithInstance.Instance;
        var instance2 = ClassWithInstance.Instance;

        // Assert
        instance1.Should().BeOfType<ClassWithInstance>();
        instance1.Should().BeSameAs(instance2);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Singleton\NamedOptionsTests.cs 
﻿namespace DotNetToolbox.Singleton;

public class NamedOptionsTests {
    private class TestOptions : NamedOptions<TestOptions>;
    private class SomeObject : NamedOptions<SomeObject>;

    [Fact]
    public void Static_Default_ReturnsSingleton() {
        // Arrange & Act
        var instance1 = TestOptions.Default;
        var instance2 = TestOptions.Default;

        // Assert
        instance1.Should().BeOfType<TestOptions>();
        instance1.Should().BeSameAs(instance2);
    }

    [Fact]
    public void SectionName_ReturnsName() {
        // Arrange & Act & Assert
        TestOptions.SectionName.Should().Be("Test");
        SomeObject.SectionName.Should().Be("SomeObject");
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Core.UnitTests\Threading\TaskExtensionsTests.cs 
namespace DotNetToolbox.Threading;

public class TaskExtensionsTests {
    private static readonly CancellationTokenSource _tokenSource = new();
    private static readonly CancellationToken _token = _tokenSource.Token;

    static TaskExtensionsTests() {
        _tokenSource.Cancel();
    }

    private static ValueTask TestValueTask() => ValueTask.CompletedTask;
    private static ValueTask TestFaultyValueTask() => ValueTask.FromException(new InvalidOperationException());
    private static ValueTask TestCanceledValueTask() => ValueTask.FromCanceled(_token);

    private static ValueTask<int> TestValueTaskOfT() => ValueTask.FromResult(42);
    private static ValueTask<int> TestFaultyValueTaskOfT() => ValueTask.FromException<int>(new InvalidOperationException());
    private static ValueTask<int> TestCanceledValueTaskOfT() => ValueTask.FromCanceled<int>(_token);

    private static Task TestTask() => Task.CompletedTask;
    private static Task TestFaultyTask() => Task.FromException(new InvalidOperationException());
    private static Task TestCanceledTask() => Task.FromCanceled(_token);

    private static Task<int> TestTaskOfT() => Task.FromResult(42);
    private static Task<int> TestFaultyTaskOfT() => Task.FromException<int>(new InvalidOperationException());
    private static Task<int> TestCanceledTaskOfT() => Task.FromCanceled<int>(_token);

    [Fact]
    public void FireAndForget_ForValueTask_ShouldCallAppropriateHandler() {
        // Arrange
        var goodTask = TestValueTask();
        var faultyTask = TestFaultyValueTask();
        var canceledTask = TestCanceledValueTask();

        var onException = For<Action<Exception>>();
        var onExceptionAndTask = For<Action<ValueTask, Exception>>();

        var onCancel = For<Action<OperationCanceledException>>();
        var onCancelAndTask = For<Action<ValueTask, OperationCanceledException>>();

        // Act & Assert
        goodTask.FireAndForget();
        canceledTask.FireAndForget();
        faultyTask.FireAndForget();

        goodTask.FireAndForget(onCancel);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());

        canceledTask.FireAndForget(onCancel);
        onCancel.Received(1).Invoke(Any<OperationCanceledException>());
        onCancel.ClearReceivedCalls();

        faultyTask.FireAndForget(onCancel);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());

        goodTask.FireAndForget(onCancelAndTask);
        onCancelAndTask.DidNotReceive().Invoke(goodTask, Any<OperationCanceledException>());

        canceledTask.FireAndForget(onCancelAndTask);
        onCancelAndTask.Received(1).Invoke(canceledTask, Any<OperationCanceledException>());
        onCancelAndTask.ClearReceivedCalls();

        faultyTask.FireAndForget(onCancelAndTask);
        onCancelAndTask.DidNotReceive().Invoke(faultyTask, Any<OperationCanceledException>());

        goodTask.FireAndForget(onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        canceledTask.FireAndForget(onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        faultyTask.FireAndForget(onException);
        onException.Received(1).Invoke(Any<Exception>());
        onException.ClearReceivedCalls();

        goodTask.FireAndForget(onExceptionAndTask);
        onExceptionAndTask.DidNotReceive().Invoke(goodTask, Any<Exception>());

        canceledTask.FireAndForget(onExceptionAndTask);
        onExceptionAndTask.DidNotReceive().Invoke(canceledTask, Any<Exception>());

        faultyTask.FireAndForget(onExceptionAndTask);
        onExceptionAndTask.Received(1).Invoke(faultyTask, Any<Exception>());
        onExceptionAndTask.ClearReceivedCalls();

        goodTask.FireAndForget(onCancel, onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        canceledTask.FireAndForget(onCancel, onException);
        onCancel.Received(1).Invoke(Any<OperationCanceledException>());
        onCancel.ClearReceivedCalls();
        onException.DidNotReceive().Invoke(Any<Exception>());

        faultyTask.FireAndForget(onCancel, onException);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());
        onException.Received(1).Invoke(Any<Exception>());
        onException.ClearReceivedCalls();

        goodTask.FireAndForget(onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.DidNotReceive().Invoke(goodTask, Any<OperationCanceledException>());
        onExceptionAndTask.DidNotReceive().Invoke(goodTask, Any<Exception>());

        canceledTask.FireAndForget(onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.Received(1).Invoke(canceledTask, Any<OperationCanceledException>());
        onCancelAndTask.ClearReceivedCalls();
        onExceptionAndTask.DidNotReceive().Invoke(canceledTask, Any<Exception>());

        faultyTask.FireAndForget(onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.DidNotReceive().Invoke(faultyTask, Any<OperationCanceledException>());
        onExceptionAndTask.Received(1).Invoke(faultyTask, Any<Exception>());
        onExceptionAndTask.ClearReceivedCalls();
    }

    [Fact]
    public void FireAndForget_ForValueTaskOfT_ShouldCallAppropriateHandler() {
        // Arrange
        var goodTask = TestValueTaskOfT();
        var faultyTask = TestFaultyValueTaskOfT();
        var canceledTask = TestCanceledValueTaskOfT();

        var onResult = For<Action<int>>();

        var onException = For<Action<Exception>>();
        var onExceptionAndTask = For<Action<ValueTask<int>, Exception>>();

        var onCancel = For<Action<OperationCanceledException>>();
        var onCancelAndTask = For<Action<ValueTask<int>, OperationCanceledException>>();

        // Act & Assert
        goodTask.FireAndForget(onResult);
        canceledTask.FireAndForget(onResult);
        faultyTask.FireAndForget(onResult);

        goodTask.FireAndForget(onResult, onCancel);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());

        canceledTask.FireAndForget(onResult, onCancel);
        onCancel.Received(1).Invoke(Any<OperationCanceledException>());
        onCancel.ClearReceivedCalls();

        faultyTask.FireAndForget(onResult, onCancel);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());

        goodTask.FireAndForget(onResult, onCancelAndTask);
        onCancelAndTask.DidNotReceive().Invoke(goodTask, Any<OperationCanceledException>());

        canceledTask.FireAndForget(onResult, onCancelAndTask);
        onCancelAndTask.Received(1).Invoke(canceledTask, Any<OperationCanceledException>());
        onCancelAndTask.ClearReceivedCalls();

        faultyTask.FireAndForget(onResult, onCancelAndTask);
        onCancelAndTask.DidNotReceive().Invoke(faultyTask, Any<OperationCanceledException>());

        goodTask.FireAndForget(onResult, onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        canceledTask.FireAndForget(onResult, onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        faultyTask.FireAndForget(onResult, onException);
        onException.Received(1).Invoke(Any<Exception>());
        onException.ClearReceivedCalls();

        goodTask.FireAndForget(onResult, onExceptionAndTask);
        onExceptionAndTask.DidNotReceive().Invoke(goodTask, Any<Exception>());

        canceledTask.FireAndForget(onResult, onExceptionAndTask);
        onExceptionAndTask.DidNotReceive().Invoke(canceledTask, Any<Exception>());

        faultyTask.FireAndForget(onResult, onExceptionAndTask);
        onExceptionAndTask.Received(1).Invoke(faultyTask, Any<Exception>());
        onExceptionAndTask.ClearReceivedCalls();

        goodTask.FireAndForget(onResult, onCancel, onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        canceledTask.FireAndForget(onResult, onCancel, onException);
        onCancel.Received(1).Invoke(Any<OperationCanceledException>());
        onCancel.ClearReceivedCalls();
        onException.DidNotReceive().Invoke(Any<Exception>());

        faultyTask.FireAndForget(onResult, onCancel, onException);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());
        onException.Received(1).Invoke(Any<Exception>());
        onException.ClearReceivedCalls();

        goodTask.FireAndForget(onResult, onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.DidNotReceive().Invoke(goodTask, Any<OperationCanceledException>());
        onExceptionAndTask.DidNotReceive().Invoke(goodTask, Any<Exception>());

        canceledTask.FireAndForget(onResult, onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.Received(1).Invoke(canceledTask, Any<OperationCanceledException>());
        onCancelAndTask.ClearReceivedCalls();
        onExceptionAndTask.DidNotReceive().Invoke(canceledTask, Any<Exception>());

        faultyTask.FireAndForget(onResult, onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.DidNotReceive().Invoke(faultyTask, Any<OperationCanceledException>());
        onExceptionAndTask.Received(1).Invoke(faultyTask, Any<Exception>());
        onExceptionAndTask.ClearReceivedCalls();
    }

    [Fact]
    public void FireAndForget_ForTask_ShouldCallAppropriateHandler() {
        // Arrange
        var goodTask = TestTask();
        var faultyTask = TestFaultyTask();
        var canceledTask = TestCanceledTask();

        var onException = For<Action<Exception>>();
        var onExceptionAndTask = For<Action<Task, Exception>>();

        var onCancel = For<Action<OperationCanceledException>>();
        var onCancelAndTask = For<Action<Task, OperationCanceledException>>();

        // Act & Assert
        goodTask.FireAndForget();
        canceledTask.FireAndForget();
        faultyTask.FireAndForget();

        goodTask.FireAndForget(onCancel);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());

        canceledTask.FireAndForget(onCancel);
        onCancel.Received(1).Invoke(Any<OperationCanceledException>());
        onCancel.ClearReceivedCalls();

        faultyTask.FireAndForget(onCancel);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());

        goodTask.FireAndForget(onCancelAndTask);
        onCancelAndTask.DidNotReceive().Invoke(goodTask, Any<OperationCanceledException>());

        canceledTask.FireAndForget(onCancelAndTask);
        onCancelAndTask.Received(1).Invoke(canceledTask, Any<OperationCanceledException>());
        onCancelAndTask.ClearReceivedCalls();

        faultyTask.FireAndForget(onCancelAndTask);
        onCancelAndTask.DidNotReceive().Invoke(faultyTask, Any<OperationCanceledException>());

        goodTask.FireAndForget(onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        canceledTask.FireAndForget(onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        faultyTask.FireAndForget(onException);
        onException.Received(1).Invoke(Any<Exception>());
        onException.ClearReceivedCalls();

        goodTask.FireAndForget(onExceptionAndTask);
        onExceptionAndTask.DidNotReceive().Invoke(goodTask, Any<Exception>());

        canceledTask.FireAndForget(onExceptionAndTask);
        onExceptionAndTask.DidNotReceive().Invoke(canceledTask, Any<Exception>());

        faultyTask.FireAndForget(onExceptionAndTask);
        onExceptionAndTask.Received(1).Invoke(faultyTask, Any<Exception>());
        onExceptionAndTask.ClearReceivedCalls();

        goodTask.FireAndForget(onCancel, onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        canceledTask.FireAndForget(onCancel, onException);
        onCancel.Received(1).Invoke(Any<OperationCanceledException>());
        onCancel.ClearReceivedCalls();
        onException.DidNotReceive().Invoke(Any<Exception>());

        faultyTask.FireAndForget(onCancel, onException);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());
        onException.Received(1).Invoke(Any<Exception>());
        onException.ClearReceivedCalls();

        goodTask.FireAndForget(onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.DidNotReceive().Invoke(goodTask, Any<OperationCanceledException>());
        onExceptionAndTask.DidNotReceive().Invoke(goodTask, Any<Exception>());

        canceledTask.FireAndForget(onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.Received(1).Invoke(canceledTask, Any<OperationCanceledException>());
        onCancelAndTask.ClearReceivedCalls();
        onExceptionAndTask.DidNotReceive().Invoke(canceledTask, Any<Exception>());

        faultyTask.FireAndForget(onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.DidNotReceive().Invoke(faultyTask, Any<OperationCanceledException>());
        onExceptionAndTask.Received(1).Invoke(faultyTask, Any<Exception>());
        onExceptionAndTask.ClearReceivedCalls();
    }

    [Fact]
    public void FireAndForget_ForTaskOfT_ShouldCallAppropriateHandler() {
        // Arrange
        var goodTask = TestTaskOfT();
        var faultyTask = TestFaultyTaskOfT();
        var canceledTask = TestCanceledTaskOfT();

        var onResult = For<Action<int>>();

        var onException = For<Action<Exception>>();
        var onExceptionAndTask = For<Action<Task<int>, Exception>>();

        var onCancel = For<Action<OperationCanceledException>>();
        var onCancelAndTask = For<Action<Task<int>, OperationCanceledException>>();

        // Act & Assert
        goodTask.FireAndForget(onResult);
        canceledTask.FireAndForget(onResult);
        faultyTask.FireAndForget(onResult);

        goodTask.FireAndForget(onResult, onCancel);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());

        canceledTask.FireAndForget(onResult, onCancel);
        onCancel.Received(1).Invoke(Any<OperationCanceledException>());
        onCancel.ClearReceivedCalls();

        faultyTask.FireAndForget(onResult, onCancel);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());

        goodTask.FireAndForget(onResult, onCancelAndTask);
        onCancelAndTask.DidNotReceive().Invoke(goodTask, Any<OperationCanceledException>());

        canceledTask.FireAndForget(onResult, onCancelAndTask);
        onCancelAndTask.Received(1).Invoke(canceledTask, Any<OperationCanceledException>());
        onCancelAndTask.ClearReceivedCalls();

        faultyTask.FireAndForget(onResult, onCancelAndTask);
        onCancelAndTask.DidNotReceive().Invoke(faultyTask, Any<OperationCanceledException>());

        goodTask.FireAndForget(onResult, onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        canceledTask.FireAndForget(onResult, onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        faultyTask.FireAndForget(onResult, onException);
        onException.Received(1).Invoke(Any<Exception>());
        onException.ClearReceivedCalls();

        goodTask.FireAndForget(onResult, onExceptionAndTask);
        onExceptionAndTask.DidNotReceive().Invoke(goodTask, Any<Exception>());

        canceledTask.FireAndForget(onResult, onExceptionAndTask);
        onExceptionAndTask.DidNotReceive().Invoke(canceledTask, Any<Exception>());

        faultyTask.FireAndForget(onResult, onExceptionAndTask);
        onExceptionAndTask.Received(1).Invoke(faultyTask, Any<Exception>());
        onExceptionAndTask.ClearReceivedCalls();

        goodTask.FireAndForget(onResult, onCancel, onException);
        onException.DidNotReceive().Invoke(Any<Exception>());

        canceledTask.FireAndForget(onResult, onCancel, onException);
        onCancel.Received(1).Invoke(Any<OperationCanceledException>());
        onCancel.ClearReceivedCalls();
        onException.DidNotReceive().Invoke(Any<Exception>());

        faultyTask.FireAndForget(onResult, onCancel, onException);
        onCancel.DidNotReceive().Invoke(Any<OperationCanceledException>());
        onException.Received(1).Invoke(Any<Exception>());
        onException.ClearReceivedCalls();

        goodTask.FireAndForget(onResult, onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.DidNotReceive().Invoke(goodTask, Any<OperationCanceledException>());
        onExceptionAndTask.DidNotReceive().Invoke(goodTask, Any<Exception>());

        canceledTask.FireAndForget(onResult, onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.Received(1).Invoke(canceledTask, Any<OperationCanceledException>());
        onCancelAndTask.ClearReceivedCalls();
        onExceptionAndTask.DidNotReceive().Invoke(canceledTask, Any<Exception>());

        faultyTask.FireAndForget(onResult, onCancelAndTask, onExceptionAndTask);
        onCancelAndTask.DidNotReceive().Invoke(faultyTask, Any<OperationCanceledException>());
        onExceptionAndTask.Received(1).Invoke(faultyTask, Any<Exception>());
        onExceptionAndTask.ClearReceivedCalls();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\FluentAssertions\GlobalUsings.cs 
// Global using directives

global using DotNetToolbox.TestUtilities.Logging;

global using FluentAssertions;

global using Microsoft.Extensions.Logging;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\FluentAssertions\LoggerAssertions.cs 
﻿namespace FluentAssertions;

public class LoggerAssertions(ITrackedLogger logger) {
    private readonly IReadOnlyList<Log> _logs = logger.Logs;

    public void BeEmpty() => _logs.Should().BeEmpty();

    public AndConstraint<LoggerAssertions> NotBeEmpty() {
        _logs.Should().NotBeEmpty();
        return new(this);
    }

    public AndWhichConstraint<LoggerAssertions, IEnumerable<Log>> Contain(LogLevel level, string? message = null) {
        _logs.Should().Contain(log => log.With(level, message));
        var matches = _logs.Where(log => log.With(level, message)).ToArray();
        return new(this, matches);
    }

    public AndWhichConstraint<LoggerAssertions, IEnumerable<Log>> Contain(string message) {
        _logs.Should().Contain(log => log.With(null, EmptyIfNull(message)));
        var matches = _logs.Where(log => log.With(null, EmptyIfNull(message))).ToArray();
        return new(this, matches);
    }

    public AndConstraint<LoggerAssertions> NotContain(LogLevel level, string? message = null) {
        _logs.Should().NotContain(log => log.With(level, message));
        return new(this);
    }

    public AndConstraint<LoggerAssertions> NotContain(string? message) {
        _logs.Should().NotContain(log => log.With(null, EmptyIfNull(message)));
        return new(this);
    }

    public AndConstraint<LoggerAssertions> ContainExactly(ushort expectedCount) {
        if (expectedCount == 0) {
            _logs.Should().BeEmpty();
            return new(this);
        }

        _logs.Should().HaveCount(expectedCount);
        return new(this);
    }

    public AndWhichConstraint<LoggerAssertions, IEnumerable<Log>> ContainExactly(ushort expectedCount, LogLevel level, string? message = null) {
        if (expectedCount == 0) {
            _logs.Should().NotContain(log => log.With(level, message));
            return new(this, Array.Empty<Log>());
        }

        _logs.Should().Contain(log => log.With(level, message));
        var matches = _logs.Where(log => log.With(level, message)).ToArray();
        matches.Should().HaveCount(expectedCount);
        return new(this, matches);
    }

    public AndWhichConstraint<LoggerAssertions, IEnumerable<Log>> ContainExactly(ushort expectedCount, string message) {
        if (expectedCount == 0) {
            _logs.Should().NotContain(log => log.With(null, EmptyIfNull(message)));
            return new(this, Array.Empty<Log>());
        }

        _logs.Should().Contain(log => log.With(null, EmptyIfNull(message)));
        var matches = _logs.Where(log => log.With(null, EmptyIfNull(message))).ToArray();
        matches.Should().HaveCount(expectedCount);
        return new(this, matches);
    }

    public AndConstraint<LoggerAssertions> ContainAtLeast(ushort expectedCount) {
        _logs.Should().HaveCountGreaterOrEqualTo(expectedCount);
        return new(this);
    }

    public AndConstraint<LoggerAssertions> ContainAtMost(ushort expectedCount) {
        _logs.Should().HaveCountLessOrEqualTo(expectedCount);
        return new(this);
    }

    private static string EmptyIfNull(string? message) => message ?? string.Empty;
}

internal static class LogExtensions {
    public static bool With(this Log log, LogLevel? level, string? message) {
        var result = true;
        result &= !level.HasValue || log.Level == level.Value;
        result &= message is null || log.Message == message;
        return result;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\FluentAssertions\LoggerExtensions.cs 
﻿namespace FluentAssertions;

public static class LoggerExtensions {
    public static LoggerAssertions Should(this ILogger logger)
        => logger is ITrackedLogger trackedLogger
               ? new(trackedLogger)
               : throw new ArgumentException($"The logger to be tested must be of type {nameof(ITrackedLogger)}", nameof(logger));
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\FluentAssertions.UnitTests\GlobalUsings.cs 
global using DotNetToolbox.TestUtilities.Logging;

global using FluentAssertions;

global using Microsoft.Extensions.Logging;

global using Xunit; 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\FluentAssertions.UnitTests\LoggerAssertionsTests.cs 
﻿namespace DotNetToolbox;

public class LoggerAssertionsTests {
    private readonly ITrackedLogger _logger;
    private readonly LoggerAssertions _loggerAssertions;

    public LoggerAssertionsTests() {
        _logger = new TrackedNullLogger(LogLevel.Information);
        _loggerAssertions = new(_logger);
    }

    [Fact]
    public void BeEmpty_ThrowsOnlyWhenFails() {
        // Arrange
        _logger.LogDebug("Test 1."); // Not added, because MinimumLevel is Information

        // Act & Assert
        _loggerAssertions.Invoking(x => x.BeEmpty()).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.ContainExactly(0)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.NotBeEmpty()).Should().Throw<Exception>();
    }

    [Fact]
    public void NotBeEmpty_ThrowsOnlyWhenFails() {
        // Arrange
        _logger.LogInformation("Test 1.");
        _logger.LogInformation("Test 2.");
        _logger.LogError("Test 2.");

        // Act & Assert
        _loggerAssertions.Invoking(x => x.BeEmpty()).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.ContainExactly(0)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.NotBeEmpty()).Should().NotThrow();
    }

    [Fact]
    public void HaveExactly_ThrowsOnlyWhenFails() {
        // Arrange
        _logger.LogDebug("Test 1."); // Not added, because MinimumLevel is Information
        _logger.LogInformation("Test 1.");
        _logger.LogInformation("Test 2.");
        _logger.LogError("Test 2.");

        // Act & Assert
        _loggerAssertions.Invoking(x => x.ContainExactly(2)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.ContainExactly(3)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.ContainExactly(4)).Should().Throw<Exception>();
    }

    [Fact]
    public void HaveAtLeast_ThrowsOnlyWhenFails() {
        // Arrange
        _logger.LogDebug("Test 1."); // Not added, because MinimumLevel is Information
        _logger.LogInformation("Test 1.");
        _logger.LogInformation("Test 2.");
        _logger.LogError("Test 2.");

        // Act & Assert
        _loggerAssertions.Invoking(x => x.ContainAtLeast(2)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.ContainAtLeast(3)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.ContainAtLeast(4)).Should().Throw<Exception>();
    }

    [Fact]
    public void HaveAtMost_ThrowsOnlyWhenFails() {
        // Arrange
        _logger.LogDebug("Test 1."); // Not added, because MinimumLevel is Information
        _logger.LogInformation("Test 1.");
        _logger.LogInformation("Test 2.");
        _logger.LogError("Test 2.");

        // Act & Assert
        _loggerAssertions.Invoking(x => x.ContainAtMost(2)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.ContainAtMost(3)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.ContainAtMost(4)).Should().NotThrow();
    }

    [Fact]
    public void Contain_ThrowsOnlyWhenFails() {
        // Arrange
        _logger.LogDebug("Test 1."); // Not added, because MinimumLevel is Information
        _logger.LogInformation("Test 1.");
        _logger.LogInformation("Test 2.");
        _logger.LogError("Test 2.");

        // Act & Assert
        _loggerAssertions.Invoking(x => x.Contain(LogLevel.Trace)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.Contain(LogLevel.Debug)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.Contain(LogLevel.Information)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.Contain(LogLevel.Warning)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.Contain(LogLevel.Error)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.Contain(LogLevel.Critical)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.Contain(null!)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.Contain("Test 1.")).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.Contain("Test 2.")).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.Contain("Test 3.")).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.Contain(LogLevel.Debug, "Test 1.")).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.Contain(LogLevel.Information, "Test 1.")).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.Contain(LogLevel.Error, "Test 2.")).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.Contain(LogLevel.Error, "Test 1.")).Should().Throw<Exception>();
    }

    [Fact]
    public void NotContain_ThrowsOnlyWhenFails() {
        // Arrange
        _logger.LogDebug("Test 1."); // Not added, because MinimumLevel is Information
        _logger.LogInformation("Test 1.");
        _logger.LogInformation("Test 2.");
        _logger.LogError("Test 2.");

        // Act & Assert
        _loggerAssertions.Invoking(x => x.NotContain(LogLevel.Trace)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.NotContain(LogLevel.Debug)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.NotContain(LogLevel.Information)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.NotContain(LogLevel.Warning)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.NotContain(LogLevel.Error)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.NotContain(LogLevel.Critical)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.NotContain(null)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.NotContain("Test 1.")).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.NotContain("Test 2.")).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.NotContain("Test 3.")).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.NotContain(LogLevel.Debug, "Test 1.")).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.NotContain(LogLevel.Information, "Test 1.")).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.NotContain(LogLevel.Error, "Test 2.")).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.NotContain(LogLevel.Error, "Test 1.")).Should().NotThrow();
    }

    [Fact]
    public void ContainExactly_ThrowsOnlyWhenFails() {
        // Arrange
        _logger.LogDebug("Test 1."); // Not added, because MinimumLevel is Information
        _logger.LogInformation("Test 1.");
        _logger.LogInformation("Test 2.");
        _logger.LogError("Test 2.");

        // Act & Assert
        _loggerAssertions.Invoking(x => x.ContainExactly(0, LogLevel.Trace)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.ContainExactly(1, LogLevel.Debug)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.ContainExactly(1, LogLevel.Information)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.ContainExactly(2, LogLevel.Information)).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.ContainExactly(3, LogLevel.Information)).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.ContainExactly(0, "Test 4.")).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.ContainExactly(1, "Test 2.")).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.ContainExactly(2, "Test 2.")).Should().NotThrow();
        _loggerAssertions.Invoking(x => x.ContainExactly(3, "Test 2.")).Should().Throw<Exception>();
        _loggerAssertions.Invoking(x => x.ContainExactly(1, LogLevel.Information, "Test 1.")).Should().NotThrow();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\FluentAssertions.UnitTests\LoggerExtensionsTests.cs 
﻿namespace DotNetToolbox;

public class LoggerExtensionsTests {
    [Fact]
    public void Should_ForNotTrackedLogger_Throws() {
        // Arrange
        ILogger logger = default!;

        // Act
        var action = () => logger.Should();

        // Assert
        action.Should().Throw<ArgumentException>();
    }

    [Fact]
    public void Should_ForTrackedLogger_DoesNotThrows() {
        // Arrange
        ILogger logger = new TrackedNullLogger();

        // Act
        var action = () => logger.Should();

        // Assert
        action.Should().NotThrow();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\AuthenticationScheme.cs 
﻿namespace DotNetToolbox.Http;

public enum AuthenticationScheme {
    Basic,
    Bearer,
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\AuthenticationType.cs 
﻿namespace DotNetToolbox.Http;

public enum AuthenticationType {
    None,
    ApiKey,
    StaticToken,
    Jwt,
    OAuth2,
    //Client,
    //ByCode,
    //Account,
    //Digest,
    //Windows,
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\GlobalUsings.cs 
// Global using directives

global using System.Diagnostics.CodeAnalysis;
global using System.IdentityModel.Tokens.Jwt;
global using System.Net.Http.Headers;
global using System.Security.Claims;
global using System.Text;

global using DotNetToolbox.Http.Options;
global using DotNetToolbox.Results;
global using DotNetToolbox.Singleton;

global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.DependencyInjection.Extensions;
global using Microsoft.Extensions.Options;
global using Microsoft.Identity.Client;
global using Microsoft.IdentityModel.Tokens;

global using static DotNetToolbox.Constants.Messages;
global using static DotNetToolbox.Ensure;
global using static DotNetToolbox.Http.AuthenticationScheme;
global using static DotNetToolbox.Http.AuthenticationType;
global using static DotNetToolbox.Results.Result;

global using Result = DotNetToolbox.Results.Result;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\HttpAuthentication.cs 
﻿namespace DotNetToolbox.Http;

public class HttpAuthentication {
    public AuthenticationType Type { get; init; } = None;
    public string Value { get; init; } = string.Empty;
    public AuthenticationScheme Scheme { get; init; } = Basic;
    public DateTime? ExpiresOn { get; init; }

    internal DateTimeProvider DateTimeProvider { get; set; } = new();

    public bool IsValid(AuthenticationType type)
        => !string.IsNullOrWhiteSpace(Value)
        && Type == type
        && (ExpiresOn is null || ExpiresOn.Value > DateTimeProvider.UtcNow);

    public static implicit operator AuthenticationHeaderValue(HttpAuthentication auth)
        => new(auth.Scheme.ToString(), auth.Value);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\HttpClientOptionsBuilder.cs 
﻿namespace DotNetToolbox.Http;

public class HttpClientOptionsBuilder(HttpClientOptions? options = null) {
    protected HttpClientOptions Options { get; } = options ?? new HttpClientOptions();

    public HttpClientOptionsBuilder SetBaseAddress(Uri baseAddress) {
        Options.BaseAddress = baseAddress;
        return this;
    }

    public HttpClientOptionsBuilder SetResponseFormat(string responseFormat) {
        Options.ResponseFormat = IsNotNullOrWhiteSpace(responseFormat);
        return this;
    }

    public HttpClientOptionsBuilder AddCustomHeader(string key, string value) {
        if (Options.CustomHeaders.TryGetValue(key, out var values)) {
            if (values.Contains(value)) return this;
            Options.CustomHeaders[key] = [.. values, value];
            return this;
        }
        Options.CustomHeaders[key] = [value];
        return this;
    }

    public HttpClientOptionsBuilder UseApiKeyAuthentication(string apiKey)
        => UseApiKeyAuthentication(options => options.ApiKey = apiKey);

    public HttpClientOptionsBuilder UseApiKeyAuthentication(Action<ApiKeyAuthenticationOptions> options)
        => SetAuthentication(options);

    public HttpClientOptionsBuilder UseSimpleTokenAuthentication(Action<StaticTokenAuthenticationOptions> options)
        => SetAuthentication(options);

    public HttpClientOptionsBuilder UseJsonWebTokenAuthentication(Action<JwtAuthenticationOptions> options)
        => SetAuthentication(options);

    public HttpClientOptionsBuilder UseOAuth2TokenAuthentication(Action<OAuth2TokenAuthenticationOptions> options, IMsalHttpClientFactory identityClientFactory)
        => SetAuthentication(options, IsNotNull(identityClientFactory));

    public HttpClientOptions Build(string? name = null) {
        if (name is null) return IsValid(Options);
        if (!Options.NamedClients.TryGetValue(name, out var clientOptions))
            throw new ArgumentException("Client '{name}' not found.", nameof(name));
        clientOptions.BaseAddress ??= Options.BaseAddress;
        clientOptions.Authentication ??= Options.Authentication;
        return IsValid(clientOptions);
    }

    private HttpClientOptionsBuilder SetAuthentication<T>(Action<T> configAuthentication, IMsalHttpClientFactory? identityClientFactory = null)
        where T : AuthenticationOptions, new() {
        Options.Authentication ??= new T();
        configAuthentication((T)Options.Authentication);
        if (Options.Authentication is OAuth2TokenAuthenticationOptions oAuth2Options)
            oAuth2Options.HttpClientFactory = identityClientFactory;
        return this;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\HttpClientProvider.cs 
﻿namespace DotNetToolbox.Http;

//public class HttpClientProvider(IHttpClientFactory clientFactory, IOptions<HttpClientOptions> options)
//    : HttpClientProvider<HttpClientOptionsBuilder, HttpClientOptions>(clientFactory, options),
//      IHttpClientProvider {
//    public HttpClient GetHttpClient(string name, Action<HttpClientOptionsBuilder>? configureBuilder = null) {
//        var builder = CreateInstance.Of<HttpClientOptionsBuilder>(Options);
//        configureBuilder?.Invoke(builder);
//        return CreateHttpClient(builder.Build(name));
//    }
//}

public class HttpClientProvider(IHttpClientFactory clientFactory, IOptions<HttpClientOptions> options)
    : IHttpClientProvider {
    private HttpAuthentication _authentication = new();

    protected HttpClientOptions Options { get; set; } = IsNotNull(options).Value;

    public void RevokeAuthentication() => _authentication = new();

    public HttpClient GetHttpClient(string? name = null, Action<HttpClientOptionsBuilder>? configureBuilder = null) {
        var builder = CreateInstance.Of<HttpClientOptionsBuilder>(Options);
        configureBuilder?.Invoke(builder);
        Options = builder.Build(name);
        return CreateHttpClient();
    }

    protected virtual HttpClient CreateHttpClient() {
        var client = clientFactory.CreateClient();
        client.BaseAddress = Options.BaseAddress;
        client.DefaultRequestHeaders.Accept.Clear();
        client.DefaultRequestHeaders.Accept.Add(new(Options.ResponseFormat));
        foreach ((var key, var value) in Options.CustomHeaders)
            client.DefaultRequestHeaders.Add(key, value);

        _authentication = Options.Authentication?.Configure(client, _authentication)!;

        return client;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\IHttpClientProvider.cs 
﻿namespace DotNetToolbox.Http;

public interface IHttpClientProvider {
    HttpClient GetHttpClient(string? name = null, Action<HttpClientOptionsBuilder>? configureBuilder = null);
    void RevokeAuthentication();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\Extensions\HttpClientOptionsExtensions.cs 
﻿namespace DotNetToolbox.Http.Extensions;

public static class HttpClientOptionsExtensions;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\Extensions\HttpRequestHeadersExtensions.cs 
﻿namespace DotNetToolbox.Http.Extensions;

public static class HttpRequestHeadersExtensions {
    public static bool TryGetValue<T>(this HttpRequestHeaders headers, string key, out T value) {
        try {
            value = headers.GetValue<T>(key);
            return true;
        }
        catch {
            value = default!;
            return false;
        }
    }

    public static bool TryGetValue(this HttpRequestHeaders headers, string key, out string value) {
        try {
            value = headers.GetValue(key);
            return true;
        }
        catch {
            value = default!;
            return false;
        }
    }

    public static T GetValue<T>(this HttpRequestHeaders headers, string key)
        => (T)Convert.ChangeType(headers.GetValue(key), typeof(T));

    public static string GetValue(this HttpRequestHeaders headers, string key)
        => IsNotNull(headers).TryGetValues(IsNotNullOrWhiteSpace(key), out var values)
            ? values.Single()
            : throw new InvalidOperationException($"Header '{key}' not found.");
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\Extensions\ServiceCollectionExtensions.cs 
﻿namespace DotNetToolbox.Http.Extensions;

public static class ServiceCollectionExtensions {
    public static IServiceCollection AddHttpClientProvider(this IServiceCollection services, IConfiguration configuration)
        => services.AddHttpClientProvider<IHttpClientProvider, HttpClientProvider>(configuration);

    public static IServiceCollection AddHttpClientProvider<TProviderInterface, TProvider>(this IServiceCollection services, IConfiguration configuration)
        where TProviderInterface : class, IHttpClientProvider
        where TProvider : class, TProviderInterface {
        services.AddHttpClient();
        services.AddOptions();
        services.Configure<HttpClientOptions>(configuration.GetSection(HttpClientOptions.SectionName));
        services.TryAddSingleton<TProviderInterface, TProvider>();
        return services;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\Options\ApiKeyAuthenticationOptions.cs 
﻿namespace DotNetToolbox.Http.Options;

public class ApiKeyAuthenticationOptions : AuthenticationOptions {
    private const string _apiKeyHeaderKey = "x-api-key";

    public string ApiKey { get; set; } = string.Empty;

    public override Result Validate(IDictionary<string, object?>? context = null) {
        var result = base.Validate(context);

        if (string.IsNullOrWhiteSpace(ApiKey))
            result += new ValidationError(StringCannotBeNullOrWhiteSpace, GetSourcePath(nameof(ApiKey)));

        return result;

        string GetSourcePath(string source)
            => context is null || !context.TryGetValue("ClientName", out var name)
                   ? source
                   : $"{name}.{source}";
    }

    public override HttpAuthentication Configure(HttpClient client, HttpAuthentication _) {
        var authentication = new HttpAuthentication {
            Type = AuthenticationType.ApiKey,
            Value = ApiKey,
        };
        client.DefaultRequestHeaders.Add(_apiKeyHeaderKey, authentication.Value);
        return authentication;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\Options\AuthenticationOptions.cs 
﻿namespace DotNetToolbox.Http.Options;

public abstract class AuthenticationOptions : IValidatable {
    public virtual Result Validate(IDictionary<string, object?>? context = null)
        => Success();

    public abstract HttpAuthentication Configure(HttpClient client, HttpAuthentication authentication);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\Options\HttpClientOptions.cs 
﻿namespace DotNetToolbox.Http.Options;

public class HttpClientOptions
    : NamedOptions<HttpClientOptions>, IValidatable {
    public const string DefaultResponseFormat = "application/json";

    public Dictionary<string, HttpClientOptions> NamedClients { get; set; } = [];

    public virtual Uri? BaseAddress { get; set; }

    public virtual string ResponseFormat { get; set; } = DefaultResponseFormat;

    public virtual Dictionary<string, string[]> CustomHeaders { get; set; } = [];

    public virtual AuthenticationOptions? Authentication { get; set; }

    public virtual Result Validate(IDictionary<string, object?>? context = null) {
        var result = Success();

        if (BaseAddress is null)
            result += new ValidationError(StringCannotBeNullOrWhiteSpace, GetSourcePath(nameof(BaseAddress)));

        result += Authentication?.Validate(context) ?? Success();

        foreach (var client in NamedClients) {
            var clientContext = new Dictionary<string, object?> { ["ClientName"] = GetSourcePath(client.Key) };
            result += client.Value.Validate(clientContext);
        }

        return result;

        string GetSourcePath(string source)
            => context is null || !context.TryGetValue("ClientName", out var name)
                   ? source
                   : $"{name}.{source}";
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\Options\JwtAuthenticationOptions.cs 
﻿namespace DotNetToolbox.Http.Options;

public class JwtAuthenticationOptions : AuthenticationOptions {
    public string? PrivateKey { get; set; }
    public string? Issuer { get; set; }
    public string? Audience { get; set; }
    public IReadOnlyList<Claim> Claims { get; set; } = Array.Empty<Claim>();
    public TimeSpan? ExpiresAfter { get; set; }

    public override Result Validate(IDictionary<string, object?>? context = null) {
        var result = base.Validate(context);

        if (string.IsNullOrWhiteSpace(PrivateKey))
            result += new ValidationError(StringCannotBeNullOrWhiteSpace, GetSourcePath(nameof(PrivateKey)));

        return result;

        string GetSourcePath(string source)
            => context is null || !context.TryGetValue("ClientName", out var name)
                   ? source
                   : $"{name}.{source}";
    }

    public override HttpAuthentication Configure(HttpClient client, HttpAuthentication authentication) {
        if (!authentication.IsValid(Jwt)) authentication = CreateJwtToken();
        client.DefaultRequestHeaders.Authorization = authentication;
        return authentication;
    }

    internal DateTimeProvider DateTimeProvider { get; set; } = new();

    private HttpAuthentication CreateJwtToken() {
        var secretKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(PrivateKey!));
        var signingCredentials = new SigningCredentials(secretKey, SecurityAlgorithms.HmacSha256);

        var now = DateTimeProvider.UtcNow;
        var expiration = now.DateTime + ExpiresAfter;
        var tokenOptions = new JwtSecurityToken(Issuer,
                                                Audience,
                                                Claims,
                                                now.DateTime,
                                                expiration,
                                                signingCredentials);

        return new() {
            DateTimeProvider = DateTimeProvider,
            Type = Jwt,
            Value = new JwtSecurityTokenHandler().WriteToken(tokenOptions),
            Scheme = Bearer,
            ExpiresOn = expiration,
        };
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\Options\OAuth2TokenAuthenticationOptions.cs 
﻿namespace DotNetToolbox.Http.Options;

public class OAuth2TokenAuthenticationOptions : AuthenticationOptions {
    public string? TenantId { get; set; }
    public string? ClientId { get; set; }
    public string? ClientSecret { get; set; }
    public string? Authority { get; set; }
    public string[] Scopes { get; set; } = [];
    public Guid CorrelationId { get; private set; }

    internal IMsalHttpClientFactory? HttpClientFactory { get; set; }

    public override Result Validate(IDictionary<string, object?>? context = null) {
        var result = base.Validate(context);

        if (string.IsNullOrWhiteSpace(ClientId))
            result += new ValidationError(StringCannotBeNullOrWhiteSpace, GetSourcePath(nameof(ClientId)));

        if (string.IsNullOrEmpty(ClientSecret))
            result += new ValidationError(StringCannotBeNullOrEmpty, GetSourcePath(nameof(ClientSecret)));

        if (Scopes.Length == 0)
            result += new ValidationError(StringCannotBeNullOrEmpty, GetSourcePath(nameof(Scopes)));

        return result;

        string GetSourcePath(string source)
            => context is null || !context.TryGetValue("ClientName", out var name)
                   ? source
                   : $"{name}.{source}";
    }

    public override HttpAuthentication Configure(HttpClient client, HttpAuthentication authentication) {
        if (!authentication.IsValid(OAuth2)) authentication = AcquireOauth2Token();
        client.DefaultRequestHeaders.Authorization = authentication;
        return authentication;
    }

    internal DateTimeProvider DateTimeProvider { get; set; } = new();

    private HttpAuthentication AcquireOauth2Token() {
        try {
            var result = AuthenticateClient();
            return new() {
                DateTimeProvider = DateTimeProvider,
                Type = OAuth2,
                Value = result.AccessToken,
                Scheme = Bearer,
                ExpiresOn = result.ExpiresOn.DateTime,
            };
        }
        catch (Exception ex) {
            throw new InvalidOperationException("Failed to set authorization header.", ex);
        }
    }

    internal AuthenticationResult? AuthenticationResult { get; set; }

    [ExcludeFromCodeCoverage]
    private AuthenticationResult AuthenticateClient()
        => AuthenticationResult
        ?? CreateApplication()
        .AcquireTokenForClient(Scopes)
        .WithCorrelationId(CorrelationId)
        .ExecuteAsync(CancellationToken.None)
        .Result;

    private IConfidentialClientApplication CreateApplication() {
        var builder = ConfidentialClientApplicationBuilder
                     .Create(ClientId)
                     .WithHttpClientFactory(HttpClientFactory)
                     .WithClientSecret(ClientSecret);
        if (!string.IsNullOrWhiteSpace(TenantId))
            builder.WithTenantId(TenantId);
        if (!string.IsNullOrWhiteSpace(Authority))
            builder.WithAuthority(Authority);
        CorrelationId = Guid.NewGuid();
        return builder.Build();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http\Options\StaticTokenAuthenticationOptions.cs 
﻿namespace DotNetToolbox.Http.Options;

public class StaticTokenAuthenticationOptions : AuthenticationOptions {
    public AuthenticationScheme Scheme { get; set; } = Basic;
    public string Token { get; set; } = string.Empty;

    public override Result Validate(IDictionary<string, object?>? context = null) {
        var result = base.Validate(context);

        if (string.IsNullOrWhiteSpace(Token))
            result += new ValidationError(StringCannotBeNullOrWhiteSpace, GetSourcePath(nameof(Token)));

        return result;

        string GetSourcePath(string source)
            => context is null || !context.TryGetValue("ClientName", out var name)
                   ? source
                   : $"{name}.{source}";
    }

    public override HttpAuthentication Configure(HttpClient client, HttpAuthentication _) {
        var authentication = new HttpAuthentication() {
            Type = Jwt,
            Scheme = Scheme,
            Value = Token,
        };
        client.DefaultRequestHeaders.Authorization = authentication;
        return authentication;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http.UnitTests\GlobalUsings.cs 
global using System.Net.Http.Headers;
global using System.Security.Claims;

global using DotNetToolbox.Http.Extensions;
global using DotNetToolbox.Http.Options;
global using DotNetToolbox.Results;

global using FluentAssertions;

global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.Options;
global using Microsoft.Identity.Client;

global using NSubstitute;

global using Xunit;

global using static DotNetToolbox.Http.AuthenticationScheme;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http.UnitTests\HttpClientProviderTests.cs 
namespace DotNetToolbox.Http;

public sealed class HttpClientProviderTests : IDisposable {
    private readonly HttpClientProvider _provider;
    private readonly IHttpClientFactory _clientFactory;

    public HttpClientProviderTests() {
        _clientFactory = Substitute.For<IHttpClientFactory>();
        var client = new HttpClient();
        _clientFactory.CreateClient(Arg.Any<string>()).Returns(client);
        _provider = CreateHttpClientBuilder();
    }

    private readonly HttpClientOptions _defaultOptions = new() {
        BaseAddress = new("http://example.com/api/"),
    };

    private HttpClientProvider CreateHttpClientBuilder(HttpClientOptions? clientOptions = null) {
        clientOptions ??= _defaultOptions;
        var options = Substitute.For<IOptions<HttpClientOptions>>();
        options.Value.Returns(clientOptions);
        return new(_clientFactory, options);
    }

    private bool _isDisposed;
    public void Dispose() {
        if (_isDisposed) return;
        _provider.RevokeAuthentication();
        _isDisposed = true;
    }

    private static AuthenticationResult GenerateResult(string token, Guid correlationId)
        => new(accessToken: token,
            isExtendedLifeTimeToken: false,
            uniqueId: null,
            expiresOn: DateTime.Parse("2022-01-01").AddMinutes(5),
            extendedExpiresOn: default!,
            tenantId: "a4d9d2af-cd3d-40de-945f-0be9ad34658a",
            account: null,
            idToken: Guid.NewGuid().ToString(),
            scopes: ["https://graph.microsoft.com/.default"],
            correlationId: correlationId);

    [Fact]
    public void GetHttpClient_WithDefaultOptions_Throws() {
        // Arrange
        var builder = CreateHttpClientBuilder(new());

        // Act
        var result = () => builder.GetHttpClient();

        // Assert
        var exception = result.Should().Throw<ValidationException>().Subject.First();
        exception.Errors.Should().ContainSingle();
        exception.Errors[0].Message.Should().Be("The value is invalid.");
    }

    [Fact]
    public void GetHttpClient_WithInvalidOptions_Throws() {
        // Arrange
        _defaultOptions.BaseAddress = null;

        // Act
        var result = () => _provider.GetHttpClient();

        // Assert
        var exception = result.Should().Throw<ValidationException>().Subject.First();
        exception.Errors.Should().ContainSingle();
        exception.Errors[0].Message.Should().Be("The value is invalid.");
    }

    [Fact]
    public void GetHttpClient_MinimumOptions_ReturnsHttpClient() {
        // Act
        var result = _provider.GetHttpClient();

        // Assert
        result.BaseAddress.Should().Be("http://example.com/api/");
        result.DefaultRequestHeaders.Accept.Should().Contain(new MediaTypeWithQualityHeaderValue("application/json"));
    }

    [Fact]
    public void GetHttpClient_FromOptions_ReturnsHttpClient() {
        // Arrange
        _defaultOptions.ResponseFormat = "text/xml";
        _defaultOptions.CustomHeaders = new() {
            ["x-custom-string"] = ["SomeValue"],
            ["x-custom-int"] = ["42"],
        };

        // Act
        var result = _provider.GetHttpClient();

        // Assert
        result.BaseAddress.Should().Be("http://example.com/api/");
        result.DefaultRequestHeaders.Accept.Should().Contain(new MediaTypeWithQualityHeaderValue("text/xml"));
        result.DefaultRequestHeaders.GetValue("x-custom-string").Should().Be("SomeValue");
        result.DefaultRequestHeaders.GetValue<int>("x-custom-int").Should().Be(42);
        result.DefaultRequestHeaders.TryGetValue("x-custom-string", out var stringValue).Should().BeTrue();
        stringValue.Should().Be("SomeValue");
        result.DefaultRequestHeaders.TryGetValue<int>("x-custom-int", out var intValue).Should().BeTrue();
        intValue.Should().Be(42);
        result.DefaultRequestHeaders.TryGetValue("x-invalid", out _).Should().BeFalse();
        result.DefaultRequestHeaders.TryGetValue<int>("x-invalid", out _).Should().BeFalse();
        result.DefaultRequestHeaders.TryGetValue<int>("x-custom-string", out _).Should().BeFalse();
    }

    [Fact]
    public void GetHttpClient_FromParameters_ReturnsHttpClient() {
        // Arrange
        // Act
        var result = _provider.GetHttpClient(configureBuilder: opt => {
            opt.SetBaseAddress(new("http://example.com/api/v2/"));
            opt.SetResponseFormat("text/xml");
            opt.AddCustomHeader("x-custom-string", "SomeValue");
            opt.AddCustomHeader("x-custom-string", "SomeValue");
            opt.AddCustomHeader("x-custom-string", "SomeOtherValue");
            opt.AddCustomHeader("x-custom-int", "42");
        });

        // Assert
        result.BaseAddress.Should().Be("http://example.com/api/v2/");
        result.DefaultRequestHeaders.Accept.Should().Contain(new MediaTypeWithQualityHeaderValue("text/xml"));
        result.DefaultRequestHeaders.GetValues("x-custom-string").Should().BeEquivalentTo("SomeValue", "SomeOtherValue");
    }

    [Fact]
    public void GetHttpClient_WithInvalidName_Throws() {
        // Arrange
        _defaultOptions.BaseAddress = null;

        // Act
        var result = () => _provider.GetHttpClient("Invalid");

        // Assert
        result.Should().Throw<ArgumentException>();
    }

    [Fact]
    public void GetHttpClient_WithNamedClient_ReturnsHttpClient() {
        // Arrange
        _defaultOptions.NamedClients = new() {
            ["NamedClient1"] = new() {
                BaseAddress = _defaultOptions.BaseAddress,
                ResponseFormat = "text/xml",
                CustomHeaders = new() {
                    ["x-custom-string"] = ["SomeValue"],
                    ["x-custom-int"] = ["42"],
                },
            },
        };

        // Act
        var result = _provider.GetHttpClient("NamedClient1");

        // Assert
        result.BaseAddress.Should().Be("http://example.com/api/");
        result.DefaultRequestHeaders.GetValue("x-custom-string").Should().Be("SomeValue");
        result.DefaultRequestHeaders.GetValue<int>("x-custom-int").Should().Be(42);
        result.DefaultRequestHeaders.TryGetValue("x-custom-string", out var stringValue).Should().BeTrue();
        stringValue.Should().Be("SomeValue");
        result.DefaultRequestHeaders.TryGetValue<int>("x-custom-int", out var intValue).Should().BeTrue();
        intValue.Should().Be(42);
        result.DefaultRequestHeaders.TryGetValue("x-invalid", out _).Should().BeFalse();
        result.DefaultRequestHeaders.TryGetValue<int>("x-invalid", out _).Should().BeFalse();
        result.DefaultRequestHeaders.TryGetValue<int>("x-custom-string", out _).Should().BeFalse();
    }

    [Fact]
    public void GetHttpClient_WithInvalidNamedClient_ReturnsHttpClient() {
        // Arrange
        _defaultOptions.BaseAddress = null;
        _defaultOptions.NamedClients = new() {
            ["NamedClient1"] = new() {
                BaseAddress = _defaultOptions.BaseAddress,
                ResponseFormat = "text/xml",
                CustomHeaders = new() {
                    ["x-custom-string"] = ["SomeValue"],
                    ["x-custom-int"] = ["42"],
                },
            },
            ["NamedClient2"] = new(),
        };

        // Act
        var result = () => _provider.GetHttpClient("NamedClient2");

        // Assert
        var exception = result.Should().Throw<ValidationException>().Subject.First();
        exception.Errors.Should().ContainSingle();
        exception.Errors[0].Message.Should().Be("The value is invalid.");
    }

    [Fact]
    public void UseApiKey_FromOptions_AddsApiKeyHeader() {
        // Arrange
        _defaultOptions.Authentication = new ApiKeyAuthenticationOptions {
            ApiKey = "abc123",
        };

        // Act
        var result = _provider.GetHttpClient();

        // Assert
        result.DefaultRequestHeaders.GetValue("x-api-key").Should().Be("abc123");
    }

    [Fact]
    public void UseApiKey_FromParameter_OverridesOptions() {
        // Act
        var result = _provider.GetHttpClient(configureBuilder: options => options.UseApiKeyAuthentication(opt => opt.ApiKey = "abc123"));

        // Assert
        result.DefaultRequestHeaders.GetValue("x-api-key").Should().Be("abc123");
    }

    [Fact]
    public void UseApiKey_WithInvalidOptions_Throws() {
        // Arrange
        _defaultOptions.Authentication = new ApiKeyAuthenticationOptions();

        // Act
        var result = () => _provider.GetHttpClient();

        // Assert
        var exception = result.Should().Throw<ValidationException>().Subject.First();
        exception.Errors.Should().ContainSingle();
    }

    [Fact]
    public void UseSimpleToken_FromOptions_AddsAuthorizationHeader() {
        // Arrange
        // ReSharper disable StringLiteralTypo - HttpToken
        const string expectedToken = "SomeToken";
        // ReSharper restore StringLiteralTypo

        _defaultOptions.Authentication = new StaticTokenAuthenticationOptions {
            Token = expectedToken,
        };

        // Act
        var result = _provider.GetHttpClient();

        // Assert
        var authorization = result.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject;
        authorization.Scheme.Should().Be("Basic");
        authorization.Parameter.Should().Be(expectedToken);
    }

    [Fact]
    public void UseSimpleToken_FromParameter_OverridesOptions() {
        // Arrange
        // ReSharper disable StringLiteralTypo - HttpToken
        const string expectedToken = "SomeToken";
        // ReSharper restore StringLiteralTypo

        _defaultOptions.Authentication = new StaticTokenAuthenticationOptions {
            Token = "OtherToken",
        };

        // Act
        var result = _provider.GetHttpClient(configureBuilder: options => options.UseSimpleTokenAuthentication(opt => {
            opt.Token = expectedToken;
            opt.Scheme = Bearer;
        }));

        // Assert
        var authorization = result.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject;
        authorization.Scheme.Should().Be(Bearer.ToString());
        authorization.Parameter.Should().Be(expectedToken);
    }

    [Fact]
    public void UseSimpleToken_WithInvalidOptions_Throws() {
        // Arrange
        _defaultOptions.Authentication = new StaticTokenAuthenticationOptions();

        // Act
        var result = () => _provider.GetHttpClient();

        // Assert
        var exception = result.Should().Throw<ValidationException>().Subject.First();
        exception.Errors.Should().ContainSingle();
    }

    [Fact]
    public void UseJsonWebToken_FromOptions_AddsAuthorizationHeader() {
        // Arrange
        // ReSharper disable StringLiteralTypo - HttpToken
        const string expectedToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"
                                   + ".e30"
                                   + ".QhB54iWGzYFFKAjbZvfd6OMKYxVpG0wLJgxuI9OICN4";
        // ReSharper restore StringLiteralTypo

        _defaultOptions.Authentication = new JwtAuthenticationOptions {
            PrivateKey = "ASecretValueWith256BitsOr32Chars",
        };

        // Act
        var result = _provider.GetHttpClient();

        // Assert
        var authorization = result.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject;
        authorization.Scheme.Should().Be(Bearer.ToString());
        authorization.Parameter.Should().Be(expectedToken);
    }

    [Fact]
    public void UseJsonWebToken_AfterASimpleCall_CreatesNewToken() {
        // Arrange
        var dateTimeProvider = Substitute.For<DateTimeProvider>();
        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01"));
        _defaultOptions.Authentication = new JwtAuthenticationOptions {
            PrivateKey = "ASecretValueWith256BitsOr32Chars",
        };
        var firstClient = _provider.GetHttpClient(); // The token is generated on the first call;
        var firstToken = firstClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;

        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01").AddMinutes(2));
        ((JwtAuthenticationOptions)_defaultOptions.Authentication).DateTimeProvider = dateTimeProvider;

        // Act
        var secondClient = _provider.GetHttpClient();

        // Assert
        var secondToken = secondClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;
        firstToken.Should().Be(secondToken);
    }

    [Fact]
    public void UseJsonWebToken_TokenWithoutExpiration_ReusesSameToken() {
        // Arrange
        var dateTimeProvider = Substitute.For<DateTimeProvider>();
        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01"));
        _defaultOptions.Authentication = new JwtAuthenticationOptions {
            PrivateKey = "ASecretValueWith256BitsOr32Chars",
        };
        var firstClient = _provider.GetHttpClient(); // The token is generated on the first call;
        var firstToken = firstClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;

        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01").AddMinutes(2));
        ((JwtAuthenticationOptions)_defaultOptions.Authentication).DateTimeProvider = dateTimeProvider;

        // Act
        var secondClient = _provider.GetHttpClient();

        // Assert
        var secondToken = secondClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;
        firstToken.Should().Be(secondToken);
    }

    [Fact]
    public void UseJsonWebToken_PreviousTokenStillValid_ReusesSameToken() {
        // Arrange
        var dateTimeProvider = Substitute.For<DateTimeProvider>();
        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01"));
        _defaultOptions.Authentication = new JwtAuthenticationOptions {
            PrivateKey = "ASecretValueWith256BitsOr32Chars",
            DateTimeProvider = dateTimeProvider,
            ExpiresAfter = TimeSpan.FromMinutes(5),
        };
        var firstClient = _provider.GetHttpClient(); // The token is generated on the first call;
        var firstToken = firstClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;

        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01").AddMinutes(2));
        ((JwtAuthenticationOptions)_defaultOptions.Authentication).DateTimeProvider = dateTimeProvider;

        // Act
        var secondClient = _provider.GetHttpClient();

        // Assert
        var secondToken = secondClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;
        firstToken.Should().Be(secondToken);
    }

    [Fact]
    public void UseJsonWebToken_PreviousTokenExpired_CreatedNewToken() {
        // Arrange
        var dateTimeProvider = Substitute.For<DateTimeProvider>();
        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01"));
        _defaultOptions.Authentication = new JwtAuthenticationOptions {
            PrivateKey = "ASecretValueWith256BitsOr32Chars",
            DateTimeProvider = dateTimeProvider,
            ExpiresAfter = TimeSpan.FromMinutes(5),
        };
        var firstClient = _provider.GetHttpClient(); // The token is generated on the first call;
        var firstToken = firstClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;

        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01").AddMinutes(6));
        ((JwtAuthenticationOptions)_defaultOptions.Authentication).DateTimeProvider = dateTimeProvider;

        // Act
        var secondClient = _provider.GetHttpClient();

        // Assert
        var secondToken = secondClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;
        firstToken.Should().NotBe(secondToken);
    }

    [Fact]
    public void UseJsonWebToken_FromParameter_OverridesOptions() {
        // Arrange
        _defaultOptions.Authentication = new JwtAuthenticationOptions {
            PrivateKey = "OtherSecretValue256BitsOr32Chars",
        };
        var dateTimeProvider = Substitute.For<DateTimeProvider>();
        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01"));

        // Act
        var result = _provider.GetHttpClient(configureBuilder: options => options.UseJsonWebTokenAuthentication(opt => {
            opt.DateTimeProvider = dateTimeProvider;
            opt.PrivateKey = "ASecretValueWith256BitsOr32Chars";
            opt.Audience = "SomeAudience";
            opt.Issuer = "SomeIssue";
            opt.Claims = new Claim[] {
                                                                                                                                                 new ("SubmittedClaim", "ClaimValue"),
                                                                                                                                                 new ("RequestedClaim", string.Empty),
                                                                                                                                             };
            opt.ExpiresAfter = TimeSpan.FromMinutes(5);
        }));

        // Assert
        var authorization = result.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject;
        authorization.Scheme.Should().Be(Bearer.ToString());
        authorization.Parameter.Should().NotBeNull();
    }

    [Fact]
    public void UseJsonWebToken_WithInvalidOptions_Throws() {
        // Arrange
        _defaultOptions.Authentication = new JwtAuthenticationOptions();

        // Act
        var result = () => _provider.GetHttpClient();

        // Assert
        var exception = result.Should().Throw<ValidationException>().Subject.First();
        exception.Errors.Should().ContainSingle();
    }

    [Fact]
    public void UseOAuth2Token_FromOptions_AddsAuthorizationHeader() {
        // Arrange
        _defaultOptions.Authentication = new OAuth2TokenAuthenticationOptions {
            TenantId = "a4d9d2af-cd3d-40de-945f-0be9ad34658a",
            ClientId = "SomeClient",
            ClientSecret = "SomeSecret",
            Authority = "https://login.microsoftonline.com/a4d9d2af-cd3d-40de-945f-0be9ad34658a",
            Scopes = ["https://graph.microsoft.com/.default"],
            AuthenticationResult = GenerateResult("SomeToken", Guid.NewGuid()),
        };

        // Act
        var result = _provider.GetHttpClient();

        // Assert
        var authorization = result.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject;
        authorization.Scheme.Should().Be(Bearer.ToString());
        authorization.Parameter.Should().Be("SomeToken");
    }

    [Fact]
    public void UseOAuth2Token_PreviousTokenStillValid_ReusesSameToken() {
        // Arrange
        var dateTimeProvider = Substitute.For<DateTimeProvider>();
        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01"));
        _defaultOptions.Authentication = new OAuth2TokenAuthenticationOptions {
            TenantId = "a4d9d2af-cd3d-40de-945f-0be9ad34658a",
            ClientId = "SomeClient",
            ClientSecret = "SomeSecret",
            Authority = "https://login.microsoftonline.com/a4d9d2af-cd3d-40de-945f-0be9ad34658a",
            Scopes = ["https://graph.microsoft.com/.default"],
            AuthenticationResult = GenerateResult("SomeToken", Guid.NewGuid()),
            DateTimeProvider = dateTimeProvider,
        };
        var firstClient = _provider.GetHttpClient(); // The token is generated on the first call;
        var firstToken = firstClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;

        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01").AddMinutes(2));
        ((OAuth2TokenAuthenticationOptions)_defaultOptions.Authentication).DateTimeProvider = dateTimeProvider;

        // Act
        var secondClient = _provider.GetHttpClient();

        // Assert
        var secondToken = secondClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;
        firstToken.Should().Be(secondToken);
    }

    [Fact]
    public void UseOAuth2Token_PreviousTokenExpired_CreatedNewToken() {
        // Arrange
        var dateTimeProvider = Substitute.For<DateTimeProvider>();
        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01"));
        _defaultOptions.Authentication = new OAuth2TokenAuthenticationOptions {
            TenantId = "a4d9d2af-cd3d-40de-945f-0be9ad34658a",
            ClientId = "SomeClient",
            ClientSecret = "SomeSecret",
            Authority = "https://login.microsoftonline.com/a4d9d2af-cd3d-40de-945f-0be9ad34658a",
            Scopes = ["https://graph.microsoft.com/.default"],
            AuthenticationResult = GenerateResult("SomeToken", Guid.NewGuid()),
            DateTimeProvider = dateTimeProvider,
        };
        var firstClient = _provider.GetHttpClient(); // The token is generated on the first call;
        var firstToken = firstClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;

        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01").AddMinutes(6));
        ((OAuth2TokenAuthenticationOptions)_defaultOptions.Authentication).DateTimeProvider = dateTimeProvider;
        ((OAuth2TokenAuthenticationOptions)_defaultOptions.Authentication).AuthenticationResult = GenerateResult("SomeOtherToken", Guid.NewGuid());

        // Act
        var secondClient = _provider.GetHttpClient();

        // Assert
        var secondToken = secondClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;
        firstToken.Should().NotBe(secondToken);
    }

    [Fact]
    public void UseOAuth2Token_PreviousTokenOfDifferentType_CreatedNewToken() {
        // Arrange
        var dateTimeProvider = Substitute.For<DateTimeProvider>();
        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01"));
        _defaultOptions.Authentication = new JwtAuthenticationOptions {
            PrivateKey = "ASecretValueWith256BitsOr32Chars",
            DateTimeProvider = dateTimeProvider,
            ExpiresAfter = TimeSpan.FromMinutes(5),
        };
        var firstClient = _provider.GetHttpClient(); // The token is generated on the first call;
        var firstToken = firstClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;

        dateTimeProvider.UtcNow.Returns(DateTime.Parse("2022-01-01").AddMinutes(6));
        _defaultOptions.Authentication = new OAuth2TokenAuthenticationOptions {
            TenantId = "a4d9d2af-cd3d-40de-945f-0be9ad34658a",
            ClientId = "SomeClient",
            ClientSecret = "SomeSecret",
            Authority = "https://login.microsoftonline.com/a4d9d2af-cd3d-40de-945f-0be9ad34658a",
            Scopes = ["https://graph.microsoft.com/.default"],
            AuthenticationResult = GenerateResult("SomeToken", Guid.NewGuid()),
            DateTimeProvider = dateTimeProvider,
        };

        // Act
        var secondClient = _provider.GetHttpClient();

        // Assert
        var secondToken = secondClient.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject.Parameter;
        firstToken.Should().NotBe(secondToken);
    }

    [Fact]
    public void UseOAuth2Token_FromParameter_OverridesOptions() {
        // Arrange
        _defaultOptions.Authentication = new OAuth2TokenAuthenticationOptions {
            TenantId = "OtherTenant",
            ClientId = "OtherClient",
            ClientSecret = "OtherSecret",
            Authority = "OtherAuthority",
        };
        var identityFactory = Substitute.For<IMsalHttpClientFactory>();

        var identityClient = new HttpClient();
        identityFactory.GetHttpClient().Returns(identityClient);

        // Act
        var result = _provider.GetHttpClient(configureBuilder: options => options.UseOAuth2TokenAuthentication(opt => {
            opt.TenantId = "a4d9d2af-cd3d-40de-945f-0be9ad34658a";
            opt.ClientId = "SomeClient";
            opt.ClientSecret = "SomeSecret";
            opt.Authority = "https://login.microsoftonline.com/a4d9d2af-cd3d-40de-945f-0be9ad34658a";
            opt.Scopes = ["https://graph.microsoft.com/Directory.Read"];
            opt.AuthenticationResult = GenerateResult("SomeToken", Guid.NewGuid());
        }, identityFactory));

        // Assert
        var authorization = result.DefaultRequestHeaders.Authorization.Should().BeOfType<AuthenticationHeaderValue>().Subject;
        authorization.Scheme.Should().Be(Bearer.ToString());
        authorization.Parameter.Should().Be("SomeToken");
    }

    [Fact]
    public void UseOAuth2Token_WithInvalidOptions_Throws() {
        // Arrange
        _defaultOptions.Authentication = new OAuth2TokenAuthenticationOptions {
            TenantId = "a4d9d2af-cd3d-40de-945f-0be9ad34658a",
            ClientId = "SomeClient",
            ClientSecret = "SomeSecret",
            Authority = "https://login.microsoftonline.com/a4d9d2af-cd3d-40de-945f-0be9ad34658a",
            Scopes = ["https://graph.microsoft.com/.default"],
        };

        // Act
        var result = () => _provider.GetHttpClient();

        // Assert
        result.Should().Throw<InvalidOperationException>();
    }

    [Fact]
    public void UseOAuth2Token_WithFailedAuthorization_Throws() {
        // Arrange
        _defaultOptions.Authentication = new OAuth2TokenAuthenticationOptions();

        // Act
        var result = () => _provider.GetHttpClient();

        // Assert
        var exception = result.Should().Throw<ValidationException>().Subject.First();
        exception.Errors.Should().HaveCount(1);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Http.UnitTests\Extensions\ServiceCollectionExtensionsTests.cs 
namespace DotNetToolbox.Http.Extensions;

public sealed class ServiceCollectionExtensionsTests {
    [Fact]
    public void AddHttpClientProvider_AddServices() {
        // Arrange
        var services = new ServiceCollection();
        var configuration = Substitute.For<IConfiguration>();

        // Act
        services.AddHttpClientProvider(configuration);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ObjectDumper\BasicDumpBuilderOptions.cs 
﻿namespace DotNetToolbox;

public record BasicDumpBuilderOptions {
    public virtual byte MaxDepth { get; set; } = 1;
    public virtual bool Indented { get; set; } = true;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ObjectDumper\DumpBuilder.cs 
﻿namespace DotNetToolbox;

internal sealed class DumpBuilder : IDisposable {
    private readonly DumpBuilderOptions _options;
    private readonly Stack<object> _ancestors;

    private readonly byte _level;
    private readonly Member _member;
    private readonly StringBuilder _builder;

    private bool _memberIsHidden;

    private DumpBuilder(byte level, Member member, DumpBuilderOptions options, Stack<object>? ancestors = null) {
        _options = options;
        _level = level;
        _member = member;
        _builder = new();
        _ancestors = ancestors ?? [];
        if (_member.Value is not null) _ancestors.Push(_member.Value);
    }

    void IDisposable.Dispose() {
        if (_member.Value is not null) _ancestors.Pop();
    }

    public static string Build(object? value, DumpBuilderOptions options) {
        if (value is null) return "null";
        var member = new Member(MemberKind.Object, null, value.GetType(), value);
        using var dumper = new DumpBuilder(0, member, options);
        dumper.AddType(member.Type);
        dumper.AddFormattedValue(member);
        return dumper._builder.ToString();
    }

    private void AddType(Type? type) {
        if (type is null) return;
        AddSymbol('<');
        _builder.Append(type.IsSubclassOf(typeof(Attribute))
                            ? nameof(Attribute)
                            : GetDescription(type));
        AddSymbol('>');
        AddSpacer();
    }

    private bool AddFormattedValue(Member member) {
        if (TryAddKeyWord(member)) return true;
        if (TryUseCustomFormatter(member)) return true;
        if (TryUseDefaultFormatter(member.Value)) return true;
        if (TryFormatSpecialType(member.Value)) return true;
        if (_memberIsHidden) return false;
        AddFormattedComplexType(member.Value);
        return true;
    }

    private bool TryAddKeyWord(Member member) {
        if (member.Kind != MemberKind.KeyWord) return false;
        AddSymbol('#');
        _builder.Append(member.Value);
        AddSymbol('#');
        return true;
    }

    private bool TryUseCustomFormatter(Member member) {
        if (member.Type is null) return false;
        var formattedValue = _options
                            .CustomFormatters
                            .TryGetValue(member.Type, out var formatter)
                                 ? formatter(member.Value)
                                 : null;
        if (formattedValue is null) return false;

        _builder.Append(formattedValue);
        return true;
    }

    private bool TryUseDefaultFormatter([NotNullWhen(false)] object? value) {
        var formattedValue = value switch {
            null => "null",
            bool => $"{value}".ToLower(),
            nint => $"{value}",
            nuint => $"{value}",
            string => $"\"{value}\"",
            char => $"'{value}'",
            Guid => $"{value}",
            TimeSpan => $"{value}",
            DateTime v => v.ToString(CultureInfo.CurrentCulture),
            DateTimeOffset v => v.ToString(CultureInfo.CurrentCulture),
            DateOnly v => v.ToString(CultureInfo.CurrentCulture),
            TimeOnly v => v.ToString(CultureInfo.CurrentCulture),
            IConvertible v => v.ToString(CultureInfo.CurrentCulture),
            _ => null,
        };

        if (formattedValue is null) return false;
        _builder.Append(formattedValue);
        return true;
    }

    private string GetDescription(Type type) {
        var typeName = (_options.UseFullNames ? type.FullName : null) ?? type.Name;
        var genericStart = typeName.IndexOf('`');
        if (genericStart < 0) return typeName;
        var genericArguments = type.GetGenericArguments();
        var genericArgumentsNames = string.Join(", ", genericArguments.Select(GetDescription));
        var declaringType = type.DeclaringType is null ? string.Empty : $"{GetDescription(type.DeclaringType!)}+";
        return $"{declaringType}{typeName[..typeName.IndexOf('`')]}<{genericArgumentsNames}>";
    }

    public string GetDescription(Assembly assembly)
        => _options.UseFullNames
               ? assembly.GetName().FullName
               : $"{assembly.GetName().Name} v{assembly.GetName().Version}";

    #pragma warning disable CS8509 // The switch expression does not handle all possible values of its input type (it is not exhaustive).
    public string? GetDescription(MemberInfo member)
        => member switch {
               FieldInfo { IsPublic: false }
                 or MethodBase { IsPublic: false }
                 or PropertyInfo { GetMethod: null or { IsPublic: false } }
                 or Type { IsPublic: false } => HideMember(),
               ConstructorInfo m => $"<{member.MemberType}> {m.Name}({string.Join(", ", m.GetParameters().Select(p => $"{GetDescription(p.ParameterType)} {p.Name}"))})",
               FieldInfo f => $"<{member.MemberType}> {GetDescription(f.FieldType)} {f.Name}",
               MethodInfo m => $"<{member.MemberType}> {GetDescription(m.ReturnType)} {m.Name}({string.Join(", ", m.GetParameters().Select(p => $"{GetDescription(p.ParameterType)} {p.Name}"))})",
               EventInfo e => $"<{member.MemberType}> {GetDescription(e.EventHandlerType!)} {e.Name}",
               PropertyInfo p => $"<{member.MemberType}> {GetDescription(p.PropertyType)} {p.Name}",
               Type t => GetDescription(t),
           };
    #pragma warning restore CS8509

    public string GetDescription(CustomAttributeData data)
        => GetDescription(data.AttributeType);

    public string GetDescription(Attribute attribute)
        => GetDescription(attribute.GetType());

    private string? HideMember() {
        _memberIsHidden = true;
        return null;
    }

    private bool TryFormatSpecialType(object value) {
        var formattedValue = value switch {
            RuntimeTypeHandle when _level > 0 => HideMember(),
            Module when _level > 0 => HideMember(),
            Assembly a when _level > 0 => GetDescription(a),
            MemberInfo m when _level > 0 => GetDescription(m),
            Attribute m when _level > 0 => GetDescription(m),
            CustomAttributeData m when _level > 0 => GetDescription(m),
            _ => null,
        };

        if (formattedValue is null) return false;
        _builder.Append(formattedValue);
        return true;
    }

    private void AddFormattedComplexType(object value) {
        if (MaxDepthReached()) return;
        StartBlock(value);
        AddMembers(value);
        EndBlock(value);
    }

    private bool MaxDepthReached() {
        if (_level < _options.MaxDepth) return false;
        _builder.Append("...");
        return true;
    }

    private void AddMembers(object parent) {
        var items = GetItems(parent).Cast<object?>().Select((item, index) => (Value: item, Index: index)).ToArray();
        var lastIndex = items.Length > 0 ? items.Max(i => i.Index) : 0;
        foreach (var item in items) {
            var member = GetElementOrDefault(parent, item.Value);
            if (!TryAddValue(member)) continue;
            if (item.Index != lastIndex) AddSymbol(',');
            AddNewLine();
        }
        RemoveExtraComma();
    }

    private static readonly int _commaAndNewLineLength = Environment.NewLine.Length + 1;
    private void RemoveExtraComma() {
        if (!_options.Indented) return;
        if (_builder[^_commaAndNewLineLength] != ',') return;
        _builder.Remove(_builder.Length - _commaAndNewLineLength, _commaAndNewLineLength);
        AddNewLine();
    }

    private static IEnumerable GetItems(object value)
        => value switch {
            IEnumerable list => list,
            _ => GetMembers(value.GetType()).AsEnumerable(),
        };

    private const BindingFlags _allPublic = BindingFlags.Public | BindingFlags.Instance;
    // ReSharper disable once SuggestBaseTypeForParameter
    // ReSharper disable once ReturnTypeCanBeEnumerable.Local
    private static PropertyInfo[] GetMembers(Type type)
        => [.. type.GetProperties(_allPublic)];

    private Member? GetElementOrDefault(object? member, object? item) {
        try {
            if (HasCircularReference()) return new(MemberKind.KeyWord, null, null, "CircularReference");
            if (member is IDictionary dic) {
                var itemType = item?.GetType() ?? dic.GetType().GetElementType()!;
                var key = itemType.GetProperty("Key")!.GetValue(item);
                var value = itemType.GetProperty("Value")!.GetValue(item);
                return new(MemberKind.KeyValuePair, key, null, value);
            }

            if (member is IEnumerable)
                return new(MemberKind.Element, null, null, item);

            var prop = (PropertyInfo)item!;
            return new(MemberKind.Property, prop.Name, prop.PropertyType, prop.GetValue(member));

            bool HasCircularReference() => _ancestors.Any(a => ReferenceEquals(a, item));
        }
        catch {
            return null;
        }
    }

    private void StartBlock(object value) {
        AddSymbol(value is IEnumerable ? '[' : '{');
        AddNewLine();
    }

    private bool TryAddValue(Member? member) {
        if (member is null) return false;
        if (_ancestors.Any(a => ReferenceEquals(a, member.Value))) return false;

        using var dumper = new DumpBuilder((byte)(_level + 1), member, _options, _ancestors);
        dumper.AddIndentation();
        dumper.AddFormattedName(member);
        dumper.AddType(member.Type);
        var success = dumper.AddFormattedValue(member);
        if (dumper._memberIsHidden) return false;
        if (success) _builder.Append(dumper._builder);
        return success;
    }

    private void AddFormattedName(Member member) {
        // ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
        switch (member.Kind) {
            case MemberKind.KeyValuePair:
                AddSymbol('[');
                var key = new Member(MemberKind.Object, null, null, member.Name);
                AddFormattedValue(key);
                AddSymbol(']');
                AddSpacer();
                AddSymbol('=');
                AddSpacer();
                break;
            case MemberKind.Property:
                _builder.Append('"').Append(_member.Name).Append('"');
                AddSymbol(':');
                AddSpacer();
                break;
        }
    }

    private void AddSpacer() {
        if (!_options.Indented) return;
        AddSymbol(' ');
    }

    private void AddSymbol(char symbol)
        => _builder.Append(symbol);

    private void EndBlock(object value) {
        AddIndentation();
        AddSymbol(value is IEnumerable ? ']' : '}');
    }

    private void AddIndentation() {
        if (!_options.Indented) return;
        if (_options.UseTabs) _builder.Append('\t', _level);
        else _builder.Append(' ', _level * _options.IndentSize);
    }

    private void AddNewLine() {
        if (!_options.Indented) return;
        _builder.Append(Environment.NewLine);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ObjectDumper\DumpBuilderOptions.cs 
﻿namespace DotNetToolbox;

public record DumpBuilderOptions : BasicDumpBuilderOptions {
    public bool UseTabs { get; set; }
    public int IndentSize { get; set; } = 4;
    public bool UseFullNames { get; set; }

    public Dictionary<Type, Func<object?, string>> CustomFormatters { get; } = [];
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ObjectDumper\GlobalUsings.cs 
// Global using directives

global using System.Collections;
global using System.Diagnostics.CodeAnalysis;
global using System.Globalization;
global using System.Reflection;
global using System.Text;
global using System.Text.Json;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ObjectDumper\JsonDumpBuilder.cs 
﻿namespace DotNetToolbox;

internal static class JsonDumpBuilder {
    private static readonly Dictionary<JsonDumpBuilderOptions, JsonSerializerOptions> _cache = [];
    public static string Build(object? value, JsonDumpBuilderOptions options) {
        if (value is null) return "null";
        if (!_cache.TryGetValue(options, out var jsonOptions)) {
            _cache[options] = jsonOptions = new() {
                WriteIndented = options.Indented,
                MaxDepth = options.MaxDepth,
            };
        }

        return JsonSerializer.Serialize(value, jsonOptions);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ObjectDumper\JsonDumpBuilderOptions.cs 
﻿namespace DotNetToolbox;

public record JsonDumpBuilderOptions : BasicDumpBuilderOptions {
    public override byte MaxDepth { get; set; } = 10;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ObjectDumper\Member.cs 
﻿namespace DotNetToolbox;

internal record Member {
    public Member(MemberKind kind, object? name, Type? type, object? value) {
        Kind = kind;
        Name = name;
        Type = type;
        Value = value;
    }

    public MemberKind Kind { get; }
    public object? Name { get; }
    public Type? Type { get; }
    public object? Value { get; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ObjectDumper\MemberKind.cs 
﻿namespace DotNetToolbox;

internal enum MemberKind {
    Object,
    Element,
    KeyValuePair,
    Property,
    KeyWord,
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ObjectDumper\ObjectExtensions.cs 
﻿namespace DotNetToolbox;

public static class ObjectExtensions {
    public static string Dump(this object? value, Action<DumpBuilderOptions>? config = null) {
        var options = new DumpBuilderOptions();
        config?.Invoke(options);
        return DumpBuilder.Build(value, options);
    }

    public static string DumpAsJson(this object? value, Action<JsonDumpBuilderOptions>? config = null) {
        var options = new JsonDumpBuilderOptions();
        config?.Invoke(options);
        return JsonDumpBuilder.Build(value, options);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ObjectDumper.UnitTests\GlobalUsings.cs 
global using System.Diagnostics.CodeAnalysis;
global using System.Globalization;
global using System.Text.Json;
global using System.Text.Json.Serialization;

global using FluentAssertions;

global using Xunit;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ObjectDumper.UnitTests\ObjectExtensionsTests.cs 
﻿namespace DotNetToolbox;

public class ObjectExtensionsTests {
    [Fact]
    public void JsonDumpBuilderOptions_CopyConstructor_CreateOptions() {
        // Arrange
        var options1 = new JsonDumpBuilderOptions();

        // Act
        var options2 = options1 with { };

        //Assert
        options2.Should().NotBeSameAs(options1);
    }

    [Fact]
    public void DumpBuilderOptions_CopyConstructor_CreateOptions() {
        // Arrange
        var options1 = new DumpBuilderOptions();

        // Act
        var options2 = options1 with { };

        //Assert
        options2.Should().NotBeSameAs(options1);
    }

    [Theory]
    [ClassData(typeof(TestDataForPrimitives))]
    public void Dump_SimpleTypes_ReturnsString(object? value, string expectedText) {
        // Arrange & Act
        var result = value.Dump();

        //Assert
        result.Should().Be(expectedText);
    }

    [Theory]
    [ClassData(typeof(TestDataForComplexType))]
    public void Dump_ForCollections_ReturnsString(object? value, string expectedText) {
        // Arrange & Act
        var result = value.Dump();

        // Assert
        result.Should().Be(expectedText);
    }

    private static readonly JsonSerializerOptions _indentedJson = new() {
        WriteIndented = true,
    };
    [Theory]
    [ClassData(typeof(TestDataForJson))]
    public void Dump_AsJson_ReturnsString(object? subject) {
        // Arrange
        var expectedText = JsonSerializer.Serialize(subject, _indentedJson);

        //Act
        var result = subject.DumpAsJson();

        // Assert
        result.Should().Be(expectedText);
    }

    [Theory]
    [ClassData(typeof(TestDataForJson))]
    public void Dump_AsNotIndentedJson_ReturnsString(object? subject) {
        // Arrange
        var expectedText = JsonSerializer.Serialize(subject);

        //Act
        var result = subject.DumpAsJson(opt => opt.Indented = false);

        // Assert
        result.Should().Be(expectedText);
    }

    [Fact]
    public void Dump_WithCustomIndentSize_ReturnsString() {
        // Arrange & Act
        var result = _listOfLists.Dump(opt => opt.IndentSize = 2);

        //Assert
        result.Should().Be(_listOfListsDump2SpacesLv1);
    }

    [Fact]
    public void Dump_WithCustomFormatter_ReturnsString() {
        // Arrange & Act
        var result = new TestClass(42, "Text").Dump(opt => {
            opt.CustomFormatters[typeof(int)] = v => $"{v:0,000.000}";
            opt.CustomFormatters[typeof(string)] = _ => "It is a string.";
        });

        //Assert
        result.Should().Be(_customFormatterDump);
    }

    [Fact]
    public void Dump_WithTabs_ReturnsString() {
        // Arrange & Act
        var result = new TestClass(42, "Text").Dump(opt => opt.UseTabs = true);

        //Assert
        result.Should().Be(_testWithTabs);
    }

    [Fact]
    public void Dump_SpecialElements_ReturnsString() {
        // Arrange & Act
        _listOfObjects.Add(_listOfObjects);
        var result = _listOfObjects.Dump();

        // Assert
        result.Should().Be(_listOfObjectsDump);
    }

    [Theory]
    [ClassData(typeof(TestDataForNotIndented))]
    public void Dump_NotIndented_ReturnsString(object? value, string expectedText) {
        // Arrange & Act
        var result = value.Dump(opt => opt.Indented = false);

        // Assert
        result.Should().Be(expectedText);
    }

    [Theory]
    [ClassData(typeof(TestDataForFullName))]
    public void Dump_WithFullName_ReturnsString(object? value, string expectedText) {
        // Arrange & Act
        var result = value.Dump(opt => opt.UseFullNames = true);

        // Assert
        result.Should().Be(expectedText);
    }

    [Theory]
    [ClassData(typeof(TestDataForMaxDepth))]
    public void Dump_VeryComplexType_LimitMaxLevel_ReturnsString(byte maxLevel, string expectedText) {
        // Arrange & Act
        var result = CultureInfo.GetCultureInfo("en-CA").Dump(opt => opt.MaxDepth = maxLevel);

        // Assert
        result.Should().Match(expectedText);
    }

    [Theory]
    [InlineData(typeof(int), _integerTypeDumpLv1)]
    [InlineData(typeof(CustomClass<>), _customClassTypeDumpLv1)]
    public void Dump_ExtremelyComplexType_ReturnsString(object value, string expectedText) {
        // Arrange & Act
        var result = value.Dump();

        // Assert
        result.Should().Be(expectedText);
    }

    [Theory]
    [InlineData(typeof(int))]
    public void Dump_NotSupportedTypes_AsJson_ReturnsString(object value) {
        // Arrange & Act
        var action = () => value.DumpAsJson();

        // Assert
        action.Should().Throw<NotSupportedException>();
    }

    #region Test Data

    #region Type defnitions

    [SuppressMessage("CodeQuality", "IDE0079:Remove unnecessary suppression", Justification = "<Pending>")]
    [SuppressMessage("ReSharper", "UnusedMember.Local")]
    private class TestClass(int intValue, string stringValue) {
        public int IntProperty { get; init; } = intValue;
        public string StringProperty { get; set; } = stringValue;
    }

    public interface ICustomClass<out T> {
        T Value { get; }
    };

    [SuppressMessage("CodeQuality", "IDE0079:Remove unnecessary suppression", Justification = "<Pending>")]
    [SuppressMessage("ReSharper", "UnusedMember.Local")]
    private class CustomClass<T>(T? value) : ICustomClass<T> {
        [SuppressMessage("Roslynator", "RCS1158:Static member in generic type should use a type parameter", Justification = "<Pending>")]
        public const string Name = "CustomClass";

        // ReSharper disable once MemberCanBePrivate.Local
        public static readonly T Default = default!;

        public T Value { get; } = value ?? Default;
        public TValue ConvertTo<TValue>(object? obj) {
            var result = (TValue)Convert.ChangeType(obj, typeof(TValue))!;
            OnConverted.Invoke(this, new() { Value = result });
            return result;
        }

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        // ReSharper disable once UnusedType.Local
        public delegate void EventHandler<in TConvertedArgs>(object sender, TConvertedArgs e);
        // ReSharper disable once EventNeverSubscribedTo.Local
        public event EventHandler<ConvertedArgs> OnConverted = (_, _) => { };
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

        // ReSharper disable once UnusedAutoPropertyAccessor.Local
        public class ConvertedArgs : EventArgs {
            public object? Value { get; set; }
        }
    }

    [SuppressMessage("CodeQuality", "IDE0079:Remove unnecessary suppression", Justification = "<Pending>")]
    [SuppressMessage("ReSharper", "UnusedMember.Local")]
    private class TestClassWithGeneric<T>(T value) {
        public T Property { get; set; } = value;
        public Func<T>? ConvertTo { get; set; }
    }

    [SuppressMessage("CodeQuality", "IDE0079:Remove unnecessary suppression", Justification = "<Pending>")]
    [SuppressMessage("ReSharper", "NotAccessedPositionalProperty.Local")]
    private record TestRecord(int IntProperty, string StringProperty);

    [SuppressMessage("CodeQuality", "IDE0079:Remove unnecessary suppression", Justification = "<Pending>")]
    [SuppressMessage("ReSharper", "UnusedMember.Local")]
    private struct TestStruct(int intValue, string stringValue) {
        public int IntProperty { get; set; } = intValue;
        public string StringProperty { get; } = stringValue;
    }

    #endregion

    private static readonly int[] _array = [1, 2, 3];
    private static readonly List<int> _list = [1, 2, 3];
    private static readonly Stack<int> _stack = new([1, 2, 3]);
    private static readonly int[][] _multiDimensionArray = [_array, _array, _array];
    private static readonly List<List<int>> _listOfLists = [_list, _list, _list];
    private static readonly List<object?> _listOfObjects = [null, _list];
    private static readonly Dictionary<string, double> _dictionary = new() { ["A"] = 1.1, ["B"] = 2.2, ["C"] = 3.3 };

    private class TestDataForPrimitives : TheoryData<object?, string> {
        public TestDataForPrimitives() {
            Add(null, "null");
            Add(true, "<Boolean> true");
            Add((nint)42, "<IntPtr> 42");
            Add((nuint)42, "<UIntPtr> 42");
            Add((byte)42, "<Byte> 42");
            Add((sbyte)42, "<SByte> 42");
            Add((char)42, "<Char> '*'");
            Add((short)42, "<Int16> 42");
            Add((ushort)42, "<UInt16> 42");
            Add(42, "<Int32> 42");
            Add((uint)42, "<UInt32> 42");
            Add((long)42, "<Int64> 42");
            Add((ulong)42, "<UInt64> 42");
            Add((float)42.7, "<Single> 42.7");
            Add(42.7, "<Double> 42.7");
            Add(42.7m, "<Decimal> 42.7");
            Add("Text", "<String> \"Text\"");
            Add(new DateTime(2001, 10, 12), $"<DateTime> {new DateOnly(2001, 10, 12).ToString(CultureInfo.CurrentCulture)} 00:00:00");
            Add(new DateTimeOffset(new DateTime(2001, 10, 12), TimeSpan.FromHours(-5)), $"<DateTimeOffset> {new DateOnly(2001, 10, 12).ToString(CultureInfo.CurrentCulture)} 00:00:00 -05:00");
            Add(new DateOnly(2001, 10, 12), $"<DateOnly> {new DateOnly(2001, 10, 12).ToString(CultureInfo.CurrentCulture)}");
            Add(new TimeOnly(23, 15, 52), "<TimeOnly> 23:15");
            Add(new TimeSpan(23, 15, 52), "<TimeSpan> 23:15:52");
            Add(Guid.Parse("b6d3aec4-daca-4dca-ada7-cda51623ed50"), "<Guid> b6d3aec4-daca-4dca-ada7-cda51623ed50");
        }
    }
    private class TestDataForFullName : TheoryData<object?, string> {
        public TestDataForFullName() {
            Add(new TestClass(42, "Text"), _fullNamedTestClassDump);
            Add(typeof(CustomClass<>), _fullNamedCustomClassTypeDump);
        }
    }
    private class TestDataForJson : TheoryData<object?> {
        public TestDataForJson() {
            Add(null);
            Add(true);
            Add('A');
            Add(Guid.NewGuid());
            Add(new DateTimeOffset(new DateTime(2001, 10, 12), TimeSpan.FromHours(-5)));
            Add(new DateTime(2001, 10, 12));
            Add(new DateOnly(2001, 10, 12));
            Add(new TimeOnly(23, 15, 52));
            Add(new TimeSpan(23, 15, 52));
            Add(new List<int>([1, 2, 3]));
            var dict = new Dictionary<string, TestClass> {
                ["One"] = new(42, "Test"),
                ["Two"] = new(7, "Other"),
            };
            Add(dict);
            Add(new CustomClass<int>(42));
            Add(new TestClass(42, "Text"));
        }
    }
    private class TestDataForComplexType : TheoryData<object?, string> {
        public TestDataForComplexType() {
            Add(_array, _arrayDump);
            Add(_list, _listDump);
            Add(_stack, _stackDump);
            Add(_dictionary, _dictionaryOfStringDoubleDump);
            Add(new TestClass(42, "Text"), _testClassDump);
            Add(new TestClassWithGeneric<int>(42), _testGenericClassWithInt32Dump);
            Add(new TestRecord(42, "Text"), _testRecordDump);
            Add(new TestStruct(42, "Text"), _testStructDump);
            Add(new Dictionary<string, TestStruct> {
                ["A"] = new(42, "Text"),
                ["B"] = new(7, "Other"),
            }, _testDictionaryDump);
            Add(_listOfLists, _listOfListsDumpLv1);
            Add(_multiDimensionArray, _multiDimensionArrayDumpLv1);
        }
    }
    private class TestDataForMaxDepth : TheoryData<byte, string> {
        public TestDataForMaxDepth() {
            Add(0, _cultureInfoDumpLv0);
            Add(1, _cultureInfoDumpLv1);
            Add(2, _cultureInfoDumpLv2);
            Add(3, _cultureInfoDumpLv3);
        }
    }
    private class TestDataForNotIndented : TheoryData<object?, string> {
        public TestDataForNotIndented() {
            Add(new TestClass(42, "Text"), _testClassCompactDump);
            Add(new TestClassWithGeneric<double>(42), _testGenericClassDoubleCompactDump);
            Add(new TestRecord(42, "Text"), _testRecordCompactDump);
            Add(new TestStruct(42, "Text"), _testStructCompactDump);
            Add(new Dictionary<string, TestStruct> {
                ["A"] = new(42, "Text"),
                ["B"] = new(7, "Other"),
            }, _testDictionaryCompactDumpLv1);
            Add(_listOfLists, _listOfListsCompactDumpLv1);
        }
    }

    private const string _arrayDump = """
        <Int32[]> [
            1,
            2,
            3
        ]
        """;
    private const string _listDump = """
        <List<Int32>> [
            1,
            2,
            3
        ]
        """;
    private const string _stackDump = """
         <Stack<Int32>> [
             3,
             2,
             1
         ]
         """;
    private const string _dictionaryOfStringDoubleDump = """
        <Dictionary<String, Double>> [
            ["A"] = 1.1,
            ["B"] = 2.2,
            ["C"] = 3.3
        ]
        """;
    private const string _multiDimensionArrayDumpLv1 = """
        <Int32[][]> [
            ...,
            ...,
            ...
        ]
        """;
    private const string _listOfListsDumpLv1 = """
        <List<List<Int32>>> [
            ...,
            ...,
            ...
        ]
        """;
    private const string _listOfListsDump2SpacesLv1 = """
        <List<List<Int32>>> [
          ...,
          ...,
          ...
        ]
        """;
    private const string _listOfListsCompactDumpLv1 = """
        <List<List<Int32>>>[...,...,...]
        """;
    private const string _listOfObjectsDump = """
        <List<Object>> [
            null,
            ...,
            #CircularReference#
        ]
        """;
    private const string _testClassDump = """
        <TestClass> {
            "IntProperty": <Int32> 42,
            "StringProperty": <String> "Text"
        }
        """;
    private const string _testWithTabs = """
        <TestClass> {
        	"IntProperty": <Int32> 42,
        	"StringProperty": <String> "Text"
        }
        """;
    private const string _testClassCompactDump = """
         <TestClass>{"IntProperty":<Int32>42,"StringProperty":<String>"Text"}
         """;
    private const string _testGenericClassWithInt32Dump = """
        <ObjectExtensionsTests+TestClassWithGeneric<Int32>> {
            "Property": <Int32> 42,
            "ConvertTo": <Func<Int32>> null
        }
        """;
    private const string _testGenericClassDoubleCompactDump = """
        <ObjectExtensionsTests+TestClassWithGeneric<Double>>{"Property":<Double>42,"ConvertTo":<Func<Double>>null}
        """;
    private const string _testRecordDump = """
        <TestRecord> {
            "IntProperty": <Int32> 42,
            "StringProperty": <String> "Text"
        }
        """;
    private const string _testRecordCompactDump = """
        <TestRecord>{"IntProperty":<Int32>42,"StringProperty":<String>"Text"}
        """;
    private const string _testStructDump = """
        <TestStruct> {
            "IntProperty": <Int32> 42,
            "StringProperty": <String> "Text"
        }
        """;
    private const string _testStructCompactDump = """
        <TestStruct>{"IntProperty":<Int32>42,"StringProperty":<String>"Text"}
        """;
    private const string _testDictionaryDump = """
        <Dictionary<String, TestStruct>> [
            ["A"] = ...,
            ["B"] = ...
        ]
        """;
    private const string _testDictionaryCompactDumpLv1 = """
        <Dictionary<String, TestStruct>>[["A"]=...,["B"]=...]
        """;
    private const string _cultureInfoDumpLv0 = """
        <CultureInfo> ...
        """;
    private const string _cultureInfoDumpLv1 = """
        <CultureInfo> {
            "Parent": <CultureInfo> ...,
            "LCID": <Int32> 4105,
            "KeyboardLayoutId": <Int32> 4105,
            "Name": <String> "en-CA",
            "IetfLanguageTag": <String> "en-CA",
            "DisplayName": <String> "English (Canada)",
            "NativeName": <String> "English (Canada)",
            "EnglishName": <String> "English (Canada)",
            "TwoLetterISOLanguageName": <String> "en",
            "ThreeLetterISOLanguageName": <String> "eng",
            "ThreeLetterWindowsLanguageName": <String> "ENC",
            "CompareInfo": <CompareInfo> ...,
            "TextInfo": <TextInfo> ...,
            "IsNeutralCulture": <Boolean> false,
            "CultureTypes": <CultureTypes> SpecificCultures,*
            "NumberFormat": <NumberFormatInfo> ...,
            "DateTimeFormat": <DateTimeFormatInfo> ...,
            "Calendar": <Calendar> ...,
            "OptionalCalendars": <Calendar[]> ...,
            "UseUserOverride": <Boolean> false,
            "IsReadOnly": <Boolean> true
        }
        """;
    private const string _cultureInfoDumpLv2 = """
        <CultureInfo> {
            "Parent": <CultureInfo> {
                "Parent": <CultureInfo> ...,
                "LCID": <Int32> 9,
                "KeyboardLayoutId": <Int32> 9,
                "Name": <String> "en",
                "IetfLanguageTag": <String> "en",
                "DisplayName": <String> "English",
                "NativeName": <String> "English",
                "EnglishName": <String> "English",
                "TwoLetterISOLanguageName": <String> "en",
                "ThreeLetterISOLanguageName": <String> "eng",
                "ThreeLetterWindowsLanguageName": <String> "ENU",
                "CompareInfo": <CompareInfo> ...,
                "TextInfo": <TextInfo> ...,
                "IsNeutralCulture": <Boolean> true,
                "CultureTypes": <CultureTypes> NeutralCultures,*
                "NumberFormat": <NumberFormatInfo> ...,
                "DateTimeFormat": <DateTimeFormatInfo> ...,
                "Calendar": <Calendar> ...,
                "OptionalCalendars": <Calendar[]> ...,
                "UseUserOverride": <Boolean> false,
                "IsReadOnly": <Boolean> false
            },
            "LCID": <Int32> 4105,
            "KeyboardLayoutId": <Int32> 4105,
            "Name": <String> "en-CA",
            "IetfLanguageTag": <String> "en-CA",
            "DisplayName": <String> "English (Canada)",
            "NativeName": <String> "English (Canada)",
            "EnglishName": <String> "English (Canada)",
            "TwoLetterISOLanguageName": <String> "en",
            "ThreeLetterISOLanguageName": <String> "eng",
            "ThreeLetterWindowsLanguageName": <String> "ENC",
            "CompareInfo": <CompareInfo> {
                "Name": <String> "en-CA",
                "Version": <SortVersion> ...,
                "LCID": <Int32> 4105
            },
            "TextInfo": <TextInfo> {
                "ANSICodePage": <Int32> 1252,
                "OEMCodePage": <Int32> 850,
                "MacCodePage": <Int32> 10000,
                "EBCDICCodePage": <Int32> 37,
                "LCID": <Int32> 4105,
                "CultureName": <String> "en-CA",
                "IsReadOnly": <Boolean> true,
                "ListSeparator": <String> ",",
                "IsRightToLeft": <Boolean> false
            },
            "IsNeutralCulture": <Boolean> false,
            "CultureTypes": <CultureTypes> SpecificCultures,*
            "NumberFormat": <NumberFormatInfo> {
                "CurrencyDecimalDigits": <Int32> 2,
                "CurrencyDecimalSeparator": <String> ".",
                "IsReadOnly": <Boolean> true,
                "CurrencyGroupSizes": <Int32[]> ...,
                "NumberGroupSizes": <Int32[]> ...,
                "PercentGroupSizes": <Int32[]> ...,
                "CurrencyGroupSeparator": <String> ",",
                "CurrencySymbol": <String> "$",
                "NaNSymbol": <String> "NaN",
                "CurrencyNegativePattern": <Int32> 1,
                "NumberNegativePattern": <Int32> 1,
                "PercentPositivePattern": <Int32> 1,
                "PercentNegativePattern": <Int32> 1,
                "NegativeInfinitySymbol": <String> "-∞",
                "NegativeSign": <String> "-",
                "NumberDecimalDigits": <Int32> 3,
                "NumberDecimalSeparator": <String> ".",
                "NumberGroupSeparator": <String> ",",
                "CurrencyPositivePattern": <Int32> 0,
                "PositiveInfinitySymbol": <String> "∞",
                "PositiveSign": <String> "+",
                "PercentDecimalDigits": <Int32> 3,
                "PercentDecimalSeparator": <String> ".",
                "PercentGroupSeparator": <String> ",",
                "PercentSymbol": <String> "%",
                "PerMilleSymbol": <String> "‰",
                "NativeDigits": <String[]> ...,
                "DigitSubstitution": <DigitShapes> None
            },
            "DateTimeFormat": <DateTimeFormatInfo> {
                "AMDesignator": <String> "a.m.",
                "Calendar": <Calendar> ...,
                "DateSeparator": <String> "-",
                "FirstDayOfWeek": <DayOfWeek> Sunday,
                "CalendarWeekRule": <CalendarWeekRule> FirstDay,
                "FullDateTimePattern": <String> "dddd, MMMM d, yyyy h:mm:ss tt",
                "LongDatePattern": <String> "dddd, MMMM d, yyyy",
                "LongTimePattern": <String> "h:mm:ss tt",
                "MonthDayPattern": <String> "MMMM d",
                "PMDesignator": <String> "p.m.",
                "RFC1123Pattern": <String> "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'",
                "ShortDatePattern": <String> "yyyy-MM-dd",
                "ShortTimePattern": <String> "h:mm tt",
                "SortableDateTimePattern": <String> "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
                "TimeSeparator": <String> ":",
                "UniversalSortableDateTimePattern": <String> "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
                "YearMonthPattern": <String> "MMMM yyyy",
                "AbbreviatedDayNames": <String[]> ...,
                "ShortestDayNames": <String[]> ...,
                "DayNames": <String[]> ...,
                "AbbreviatedMonthNames": <String[]> ...,
                "MonthNames": <String[]> ...,
                "IsReadOnly": <Boolean> true,
                "NativeCalendarName": <String> "Gregorian Calendar",
                "AbbreviatedMonthGenitiveNames": <String[]> ...,
                "MonthGenitiveNames": <String[]> ...
            },
            "Calendar": <Calendar> {
                "MinSupportedDateTime": <DateTime> 0001-01-01 00:00:00,
                "MaxSupportedDateTime": <DateTime> 9999-12-31 23:59:59,
                "AlgorithmType": <CalendarAlgorithmType> SolarCalendar,
                "CalendarType": <GregorianCalendarTypes> Localized,
                "Eras": <Int32[]> ...,
                "TwoDigitYearMax": <Int32> 2049,
                "IsReadOnly": <Boolean> true
            },
            "OptionalCalendars": <Calendar[]> [
                ...
            ],
            "UseUserOverride": <Boolean> false,
            "IsReadOnly": <Boolean> true
        }
        """;
    private const string _cultureInfoDumpLv3 = """
        <CultureInfo> {
            "Parent": <CultureInfo> {
                "Parent": <CultureInfo> {
                    "LCID": <Int32> 127,
                    "KeyboardLayoutId": <Int32> 127,
                    "Name": <String> "",
                    "IetfLanguageTag": <String> "",
                    "DisplayName": <String> "Invariant Language (Invariant Country)",
                    "NativeName": <String> "Invariant Language (Invariant Country)",
                    "EnglishName": <String> "Invariant Language (Invariant Country)",
                    "TwoLetterISOLanguageName": <String> "iv",
                    "ThreeLetterISOLanguageName": <String> "ivl",
                    "ThreeLetterWindowsLanguageName": <String> "IVL",
                    "CompareInfo": <CompareInfo> ...,
                    "TextInfo": <TextInfo> ...,
                    "IsNeutralCulture": <Boolean> false,
                    "CultureTypes": <CultureTypes> SpecificCultures,*
                    "NumberFormat": <NumberFormatInfo> ...,
                    "DateTimeFormat": <DateTimeFormatInfo> ...,
                    "Calendar": <Calendar> ...,
                    "OptionalCalendars": <Calendar[]> ...,
                    "UseUserOverride": <Boolean> false,
                    "IsReadOnly": <Boolean> true
                },
                "LCID": <Int32> 9,
                "KeyboardLayoutId": <Int32> 9,
                "Name": <String> "en",
                "IetfLanguageTag": <String> "en",
                "DisplayName": <String> "English",
                "NativeName": <String> "English",
                "EnglishName": <String> "English",
                "TwoLetterISOLanguageName": <String> "en",
                "ThreeLetterISOLanguageName": <String> "eng",
                "ThreeLetterWindowsLanguageName": <String> "ENU",
                "CompareInfo": <CompareInfo> {
                    "Name": <String> "en",
                    "Version": <SortVersion> ...,
                    "LCID": <Int32> 9
                },
                "TextInfo": <TextInfo> {
                    "ANSICodePage": <Int32> 1252,
                    "OEMCodePage": <Int32> 437,
                    "MacCodePage": <Int32> 10000,
                    "EBCDICCodePage": <Int32> 37,
                    "LCID": <Int32> 9,
                    "CultureName": <String> "en",
                    "IsReadOnly": <Boolean> false,
                    "ListSeparator": <String> ",",
                    "IsRightToLeft": <Boolean> false
                },
                "IsNeutralCulture": <Boolean> true,
                "CultureTypes": <CultureTypes> NeutralCultures,*
                "NumberFormat": <NumberFormatInfo> {
                    "CurrencyDecimalDigits": <Int32> 2,
                    "CurrencyDecimalSeparator": <String> ".",
                    "IsReadOnly": <Boolean> false,
                    "CurrencyGroupSizes": <Int32[]> ...,
                    "NumberGroupSizes": <Int32[]> ...,
                    "PercentGroupSizes": <Int32[]> ...,
                    "CurrencyGroupSeparator": <String> ",",
                    "CurrencySymbol": <String> "¤",
                    "NaNSymbol": <String> "NaN",
                    "CurrencyNegativePattern": <Int32> 1,
                    "NumberNegativePattern": <Int32> 1,
                    "PercentPositivePattern": <Int32> 1,
                    "PercentNegativePattern": <Int32> 1,
                    "NegativeInfinitySymbol": <String> "-∞",
                    "NegativeSign": <String> "-",
                    "NumberDecimalDigits": <Int32> 3,
                    "NumberDecimalSeparator": <String> ".",
                    "NumberGroupSeparator": <String> ",",
                    "CurrencyPositivePattern": <Int32> 0,
                    "PositiveInfinitySymbol": <String> "∞",
                    "PositiveSign": <String> "+",
                    "PercentDecimalDigits": <Int32> 3,
                    "PercentDecimalSeparator": <String> ".",
                    "PercentGroupSeparator": <String> ",",
                    "PercentSymbol": <String> "%",
                    "PerMilleSymbol": <String> "‰",
                    "NativeDigits": <String[]> ...,
                    "DigitSubstitution": <DigitShapes> None
                },
                "DateTimeFormat": <DateTimeFormatInfo> {
                    "AMDesignator": <String> "AM",
                    "Calendar": <Calendar> ...,
                    "DateSeparator": <String> "/",
                    "FirstDayOfWeek": <DayOfWeek> Sunday,
                    "CalendarWeekRule": <CalendarWeekRule> FirstDay,
                    "FullDateTimePattern": <String> "dddd, MMMM d, yyyy h:mm:ss tt",
                    "LongDatePattern": <String> "dddd, MMMM d, yyyy",
                    "LongTimePattern": <String> "h:mm:ss tt",
                    "MonthDayPattern": <String> "MMMM d",
                    "PMDesignator": <String> "PM",
                    "RFC1123Pattern": <String> "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'",
                    "ShortDatePattern": <String> "M/d/yyyy",
                    "ShortTimePattern": <String> "h:mm tt",
                    "SortableDateTimePattern": <String> "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
                    "TimeSeparator": <String> ":",
                    "UniversalSortableDateTimePattern": <String> "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
                    "YearMonthPattern": <String> "MMMM yyyy",
                    "AbbreviatedDayNames": <String[]> ...,
                    "ShortestDayNames": <String[]> ...,
                    "DayNames": <String[]> ...,
                    "AbbreviatedMonthNames": <String[]> ...,
                    "MonthNames": <String[]> ...,
                    "IsReadOnly": <Boolean> false,
                    "NativeCalendarName": <String> "Gregorian Calendar",
                    "AbbreviatedMonthGenitiveNames": <String[]> ...,
                    "MonthGenitiveNames": <String[]> ...
                },
                "Calendar": <Calendar> {
                    "MinSupportedDateTime": <DateTime> 0001-01-01 00:00:00,
                    "MaxSupportedDateTime": <DateTime> 9999-12-31 23:59:59,
                    "AlgorithmType": <CalendarAlgorithmType> SolarCalendar,
                    "CalendarType": <GregorianCalendarTypes> Localized,
                    "Eras": <Int32[]> ...,
                    "TwoDigitYearMax": <Int32> 2049,
                    "IsReadOnly": <Boolean> false
                },
                "OptionalCalendars": <Calendar[]> [
                    ...
                ],
                "UseUserOverride": <Boolean> false,
                "IsReadOnly": <Boolean> false
            },
            "LCID": <Int32> 4105,
            "KeyboardLayoutId": <Int32> 4105,
            "Name": <String> "en-CA",
            "IetfLanguageTag": <String> "en-CA",
            "DisplayName": <String> "English (Canada)",
            "NativeName": <String> "English (Canada)",
            "EnglishName": <String> "English (Canada)",
            "TwoLetterISOLanguageName": <String> "en",
            "ThreeLetterISOLanguageName": <String> "eng",
            "ThreeLetterWindowsLanguageName": <String> "ENC",
            "CompareInfo": <CompareInfo> {
                "Name": <String> "en-CA",
                "Version": <SortVersion> {
                    "FullVersion": <Int32> 26777,
                    "SortId": <Guid> 00006899-0000-0000-0000-000000001009
                },
                "LCID": <Int32> 4105
            },
            "TextInfo": <TextInfo> {
                "ANSICodePage": <Int32> 1252,
                "OEMCodePage": <Int32> 850,
                "MacCodePage": <Int32> 10000,
                "EBCDICCodePage": <Int32> 37,
                "LCID": <Int32> 4105,
                "CultureName": <String> "en-CA",
                "IsReadOnly": <Boolean> true,
                "ListSeparator": <String> ",",
                "IsRightToLeft": <Boolean> false
            },
            "IsNeutralCulture": <Boolean> false,
            "CultureTypes": <CultureTypes> SpecificCultures,*
            "NumberFormat": <NumberFormatInfo> {
                "CurrencyDecimalDigits": <Int32> 2,
                "CurrencyDecimalSeparator": <String> ".",
                "IsReadOnly": <Boolean> true,
                "CurrencyGroupSizes": <Int32[]> [
                    3
                ],
                "NumberGroupSizes": <Int32[]> [
                    3
                ],
                "PercentGroupSizes": <Int32[]> [
                    3
                ],
                "CurrencyGroupSeparator": <String> ",",
                "CurrencySymbol": <String> "$",
                "NaNSymbol": <String> "NaN",
                "CurrencyNegativePattern": <Int32> 1,
                "NumberNegativePattern": <Int32> 1,
                "PercentPositivePattern": <Int32> 1,
                "PercentNegativePattern": <Int32> 1,
                "NegativeInfinitySymbol": <String> "-∞",
                "NegativeSign": <String> "-",
                "NumberDecimalDigits": <Int32> 3,
                "NumberDecimalSeparator": <String> ".",
                "NumberGroupSeparator": <String> ",",
                "CurrencyPositivePattern": <Int32> 0,
                "PositiveInfinitySymbol": <String> "∞",
                "PositiveSign": <String> "+",
                "PercentDecimalDigits": <Int32> 3,
                "PercentDecimalSeparator": <String> ".",
                "PercentGroupSeparator": <String> ",",
                "PercentSymbol": <String> "%",
                "PerMilleSymbol": <String> "‰",
                "NativeDigits": <String[]> [
                    "0",
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                    "8",
                    "9"
                ],
                "DigitSubstitution": <DigitShapes> None
            },
            "DateTimeFormat": <DateTimeFormatInfo> {
                "AMDesignator": <String> "a.m.",
                "Calendar": <Calendar> {
                    "MinSupportedDateTime": <DateTime> 0001-01-01 00:00:00,
                    "MaxSupportedDateTime": <DateTime> 9999-12-31 23:59:59,
                    "AlgorithmType": <CalendarAlgorithmType> SolarCalendar,
                    "CalendarType": <GregorianCalendarTypes> Localized,
                    "Eras": <Int32[]> ...,
                    "TwoDigitYearMax": <Int32> 2049,
                    "IsReadOnly": <Boolean> true
                },
                "DateSeparator": <String> "-",
                "FirstDayOfWeek": <DayOfWeek> Sunday,
                "CalendarWeekRule": <CalendarWeekRule> FirstDay,
                "FullDateTimePattern": <String> "dddd, MMMM d, yyyy h:mm:ss tt",
                "LongDatePattern": <String> "dddd, MMMM d, yyyy",
                "LongTimePattern": <String> "h:mm:ss tt",
                "MonthDayPattern": <String> "MMMM d",
                "PMDesignator": <String> "p.m.",
                "RFC1123Pattern": <String> "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'",
                "ShortDatePattern": <String> "yyyy-MM-dd",
                "ShortTimePattern": <String> "h:mm tt",
                "SortableDateTimePattern": <String> "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
                "TimeSeparator": <String> ":",
                "UniversalSortableDateTimePattern": <String> "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
                "YearMonthPattern": <String> "MMMM yyyy",
                "AbbreviatedDayNames": <String[]> [
                    "Sun.",
                    "Mon.",
                    "Tue.",
                    "Wed.",
                    "Thu.",
                    "Fri.",
                    "Sat."
                ],
                "ShortestDayNames": <String[]> [
                    "S",
                    "M",
                    "T",
                    "W",
                    "T",
                    "F",
                    "S"
                ],
                "DayNames": <String[]> [
                    "Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday"
                ],
                "AbbreviatedMonthNames": <String[]> [
                    "Jan.",
                    "Feb.",
                    "Mar.",
                    "Apr.",
                    "May",
                    "Jun.",
                    "Jul.",
                    "Aug.",
                    "Sep.",
                    "Oct.",
                    "Nov.",
                    "Dec.",
                    ""
                ],
                "MonthNames": <String[]> [
                    "January",
                    "February",
                    "March",
                    "April",
                    "May",
                    "June",
                    "July",
                    "August",
                    "September",
                    "October",
                    "November",
                    "December",
                    ""
                ],
                "IsReadOnly": <Boolean> true,
                "NativeCalendarName": <String> "Gregorian Calendar",
                "AbbreviatedMonthGenitiveNames": <String[]> [
                    "Jan.",
                    "Feb.",
                    "Mar.",
                    "Apr.",
                    "May",
                    "Jun.",
                    "Jul.",
                    "Aug.",
                    "Sep.",
                    "Oct.",
                    "Nov.",
                    "Dec.",
                    ""
                ],
                "MonthGenitiveNames": <String[]> [
                    "January",
                    "February",
                    "March",
                    "April",
                    "May",
                    "June",
                    "July",
                    "August",
                    "September",
                    "October",
                    "November",
                    "December",
                    ""
                ]
            },
            "Calendar": <Calendar> {
                "MinSupportedDateTime": <DateTime> 0001-01-01 00:00:00,
                "MaxSupportedDateTime": <DateTime> 9999-12-31 23:59:59,
                "AlgorithmType": <CalendarAlgorithmType> SolarCalendar,
                "CalendarType": <GregorianCalendarTypes> Localized,
                "Eras": <Int32[]> [
                    1
                ],
                "TwoDigitYearMax": <Int32> 2049,
                "IsReadOnly": <Boolean> true
            },
            "OptionalCalendars": <Calendar[]> [
                {
                    "MinSupportedDateTime": <DateTime> 0001-01-01 00:00:00,
                    "MaxSupportedDateTime": <DateTime> 9999-12-31 23:59:59,
                    "AlgorithmType": <CalendarAlgorithmType> SolarCalendar,
                    "CalendarType": <GregorianCalendarTypes> Localized,
                    "Eras": <Int32[]> ...,
                    "TwoDigitYearMax": <Int32> 2049,
                    "IsReadOnly": <Boolean> false
                }
            ],
            "UseUserOverride": <Boolean> false,
            "IsReadOnly": <Boolean> true
        }
        """;
    private const string _fullNamedTestClassDump = """
        <DotNetToolbox.ObjectExtensionsTests+TestClass> {
            "IntProperty": <System.Int32> 42,
            "StringProperty": <System.String> "Text"
        }
        """;
    private const string _customFormatterDump = """
        <TestClass> {
            "IntProperty": <Int32> 0,042.000,
            "StringProperty": <String> It is a string.
        }
        """;
    private const string _customClassTypeDumpLv1 = """
        <RuntimeType> {
            "IsCollectible": <Boolean> false,
            "FullName": <String> "DotNetToolbox.ObjectExtensionsTests+CustomClass`1",
            "AssemblyQualifiedName": <String> "DotNetToolbox.ObjectExtensionsTests+CustomClass`1, DotNetToolbox.ObjectDumper.UnitTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=414fc8c314317fa7",
            "Namespace": <String> "DotNetToolbox",
            "GUID": <Guid> bbb0d012-07fc-349f-b31e-9fe0a1c7281f,
            "IsEnum": <Boolean> false,
            "IsConstructedGenericType": <Boolean> false,
            "IsGenericType": <Boolean> true,
            "IsGenericTypeDefinition": <Boolean> true,
            "IsSZArray": <Boolean> false,
            "ContainsGenericParameters": <Boolean> true,
            "StructLayoutAttribute": <Attribute> StructLayoutAttribute,
            "IsFunctionPointer": <Boolean> false,
            "IsUnmanagedFunctionPointer": <Boolean> false,
            "Name": <String> "CustomClass`1",
            "DeclaringType": <Type> ObjectExtensionsTests,
            "Assembly": <Assembly> DotNetToolbox.ObjectDumper.UnitTests v1.0.0.0,
            "BaseType": <Type> Object,
            "IsByRefLike": <Boolean> false,
            "IsGenericParameter": <Boolean> false,
            "IsTypeDefinition": <Boolean> true,
            "IsSecurityCritical": <Boolean> true,
            "IsSecuritySafeCritical": <Boolean> false,
            "IsSecurityTransparent": <Boolean> false,
            "MemberType": <MemberTypes> NestedType,
            "MetadataToken": <Int32> 33554440,
            "ReflectedType": <Type> ObjectExtensionsTests,
            "GenericTypeParameters": <Type[]> ...,
            "DeclaredConstructors": <IEnumerable<ConstructorInfo>> ...,
            "DeclaredEvents": <IEnumerable<EventInfo>> ...,
            "DeclaredFields": <IEnumerable<FieldInfo>> ...,
            "DeclaredMembers": <IEnumerable<MemberInfo>> ...,
            "DeclaredMethods": <IEnumerable<MethodInfo>> ...,
            "DeclaredNestedTypes": <IEnumerable<TypeInfo>> ...,
            "DeclaredProperties": <IEnumerable<PropertyInfo>> ...,
            "ImplementedInterfaces": <IEnumerable<Type>> ...,
            "IsInterface": <Boolean> false,
            "IsNested": <Boolean> true,
            "IsArray": <Boolean> false,
            "IsByRef": <Boolean> false,
            "IsPointer": <Boolean> false,
            "IsGenericTypeParameter": <Boolean> false,
            "IsGenericMethodParameter": <Boolean> false,
            "IsVariableBoundArray": <Boolean> false,
            "HasElementType": <Boolean> false,
            "GenericTypeArguments": <Type[]> ...,
            "Attributes": <TypeAttributes> NestedPrivate, BeforeFieldInit,
            "IsAbstract": <Boolean> false,
            "IsImport": <Boolean> false,
            "IsSealed": <Boolean> false,
            "IsSpecialName": <Boolean> false,
            "IsClass": <Boolean> true,
            "IsNestedAssembly": <Boolean> false,
            "IsNestedFamANDAssem": <Boolean> false,
            "IsNestedFamily": <Boolean> false,
            "IsNestedFamORAssem": <Boolean> false,
            "IsNestedPrivate": <Boolean> true,
            "IsNestedPublic": <Boolean> false,
            "IsNotPublic": <Boolean> false,
            "IsPublic": <Boolean> false,
            "IsAutoLayout": <Boolean> true,
            "IsExplicitLayout": <Boolean> false,
            "IsLayoutSequential": <Boolean> false,
            "IsAnsiClass": <Boolean> true,
            "IsAutoClass": <Boolean> false,
            "IsUnicodeClass": <Boolean> false,
            "IsCOMObject": <Boolean> false,
            "IsContextful": <Boolean> false,
            "IsMarshalByRef": <Boolean> false,
            "IsPrimitive": <Boolean> false,
            "IsValueType": <Boolean> false,
            "IsSignatureType": <Boolean> false,
            "IsSerializable": <Boolean> false,
            "IsVisible": <Boolean> false,
            "CustomAttributes": <IEnumerable<CustomAttributeData>> ...
        }
        """;
    private const string _fullNamedCustomClassTypeDump = """
        <System.RuntimeType> {
            "IsCollectible": <System.Boolean> false,
            "FullName": <System.String> "DotNetToolbox.ObjectExtensionsTests+CustomClass`1",
            "AssemblyQualifiedName": <System.String> "DotNetToolbox.ObjectExtensionsTests+CustomClass`1, DotNetToolbox.ObjectDumper.UnitTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=414fc8c314317fa7",
            "Namespace": <System.String> "DotNetToolbox",
            "GUID": <System.Guid> bbb0d012-07fc-349f-b31e-9fe0a1c7281f,
            "IsEnum": <System.Boolean> false,
            "IsConstructedGenericType": <System.Boolean> false,
            "IsGenericType": <System.Boolean> true,
            "IsGenericTypeDefinition": <System.Boolean> true,
            "IsSZArray": <System.Boolean> false,
            "ContainsGenericParameters": <System.Boolean> true,
            "StructLayoutAttribute": <Attribute> System.Runtime.InteropServices.StructLayoutAttribute,
            "IsFunctionPointer": <System.Boolean> false,
            "IsUnmanagedFunctionPointer": <System.Boolean> false,
            "Name": <System.String> "CustomClass`1",
            "DeclaringType": <System.Type> DotNetToolbox.ObjectExtensionsTests,
            "Assembly": <System.Reflection.Assembly> DotNetToolbox.ObjectDumper.UnitTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=414fc8c314317fa7,
            "BaseType": <System.Type> System.Object,
            "IsByRefLike": <System.Boolean> false,
            "IsGenericParameter": <System.Boolean> false,
            "IsTypeDefinition": <System.Boolean> true,
            "IsSecurityCritical": <System.Boolean> true,
            "IsSecuritySafeCritical": <System.Boolean> false,
            "IsSecurityTransparent": <System.Boolean> false,
            "MemberType": <System.Reflection.MemberTypes> NestedType,
            "MetadataToken": <System.Int32> 33554440,
            "ReflectedType": <System.Type> DotNetToolbox.ObjectExtensionsTests,
            "GenericTypeParameters": <System.Type[]> ...,
            "DeclaredConstructors": <System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo>> ...,
            "DeclaredEvents": <System.Collections.Generic.IEnumerable<System.Reflection.EventInfo>> ...,
            "DeclaredFields": <System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo>> ...,
            "DeclaredMembers": <System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo>> ...,
            "DeclaredMethods": <System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>> ...,
            "DeclaredNestedTypes": <System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>> ...,
            "DeclaredProperties": <System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>> ...,
            "ImplementedInterfaces": <System.Collections.Generic.IEnumerable<System.Type>> ...,
            "IsInterface": <System.Boolean> false,
            "IsNested": <System.Boolean> true,
            "IsArray": <System.Boolean> false,
            "IsByRef": <System.Boolean> false,
            "IsPointer": <System.Boolean> false,
            "IsGenericTypeParameter": <System.Boolean> false,
            "IsGenericMethodParameter": <System.Boolean> false,
            "IsVariableBoundArray": <System.Boolean> false,
            "HasElementType": <System.Boolean> false,
            "GenericTypeArguments": <System.Type[]> ...,
            "Attributes": <System.Reflection.TypeAttributes> NestedPrivate, BeforeFieldInit,
            "IsAbstract": <System.Boolean> false,
            "IsImport": <System.Boolean> false,
            "IsSealed": <System.Boolean> false,
            "IsSpecialName": <System.Boolean> false,
            "IsClass": <System.Boolean> true,
            "IsNestedAssembly": <System.Boolean> false,
            "IsNestedFamANDAssem": <System.Boolean> false,
            "IsNestedFamily": <System.Boolean> false,
            "IsNestedFamORAssem": <System.Boolean> false,
            "IsNestedPrivate": <System.Boolean> true,
            "IsNestedPublic": <System.Boolean> false,
            "IsNotPublic": <System.Boolean> false,
            "IsPublic": <System.Boolean> false,
            "IsAutoLayout": <System.Boolean> true,
            "IsExplicitLayout": <System.Boolean> false,
            "IsLayoutSequential": <System.Boolean> false,
            "IsAnsiClass": <System.Boolean> true,
            "IsAutoClass": <System.Boolean> false,
            "IsUnicodeClass": <System.Boolean> false,
            "IsCOMObject": <System.Boolean> false,
            "IsContextful": <System.Boolean> false,
            "IsMarshalByRef": <System.Boolean> false,
            "IsPrimitive": <System.Boolean> false,
            "IsValueType": <System.Boolean> false,
            "IsSignatureType": <System.Boolean> false,
            "IsSerializable": <System.Boolean> false,
            "IsVisible": <System.Boolean> false,
            "CustomAttributes": <System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData>> ...
        }
        """;
    private const string _integerTypeDumpLv1 = """
        <RuntimeType> {
            "IsCollectible": <Boolean> false,
            "FullName": <String> "System.Int32",
            "AssemblyQualifiedName": <String> "System.Int32, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e",
            "Namespace": <String> "System",
            "GUID": <Guid> bf6391d7-4c57-3a00-9c4b-e40608e6a569,
            "IsEnum": <Boolean> false,
            "IsConstructedGenericType": <Boolean> false,
            "IsGenericType": <Boolean> false,
            "IsGenericTypeDefinition": <Boolean> false,
            "IsSZArray": <Boolean> false,
            "ContainsGenericParameters": <Boolean> false,
            "StructLayoutAttribute": <Attribute> StructLayoutAttribute,
            "IsFunctionPointer": <Boolean> false,
            "IsUnmanagedFunctionPointer": <Boolean> false,
            "Name": <String> "Int32",
            "DeclaringType": <Type> null,
            "Assembly": <Assembly> System.Private.CoreLib v8.0.0.0,
            "BaseType": <Type> ValueType,
            "IsByRefLike": <Boolean> false,
            "IsGenericParameter": <Boolean> false,
            "IsTypeDefinition": <Boolean> true,
            "IsSecurityCritical": <Boolean> true,
            "IsSecuritySafeCritical": <Boolean> false,
            "IsSecurityTransparent": <Boolean> false,
            "MemberType": <MemberTypes> TypeInfo,
            "MetadataToken": <Int32> 33554772,
            "ReflectedType": <Type> null,
            "GenericTypeParameters": <Type[]> ...,
            "DeclaredConstructors": <IEnumerable<ConstructorInfo>> ...,
            "DeclaredEvents": <IEnumerable<EventInfo>> ...,
            "DeclaredFields": <IEnumerable<FieldInfo>> ...,
            "DeclaredMembers": <IEnumerable<MemberInfo>> ...,
            "DeclaredMethods": <IEnumerable<MethodInfo>> ...,
            "DeclaredNestedTypes": <IEnumerable<TypeInfo>> ...,
            "DeclaredProperties": <IEnumerable<PropertyInfo>> ...,
            "ImplementedInterfaces": <IEnumerable<Type>> ...,
            "IsInterface": <Boolean> false,
            "IsNested": <Boolean> false,
            "IsArray": <Boolean> false,
            "IsByRef": <Boolean> false,
            "IsPointer": <Boolean> false,
            "IsGenericTypeParameter": <Boolean> false,
            "IsGenericMethodParameter": <Boolean> false,
            "IsVariableBoundArray": <Boolean> false,
            "HasElementType": <Boolean> false,
            "GenericTypeArguments": <Type[]> ...,
            "Attributes": <TypeAttributes> Public, SequentialLayout, Sealed, Serializable, BeforeFieldInit,
            "IsAbstract": <Boolean> false,
            "IsImport": <Boolean> false,
            "IsSealed": <Boolean> true,
            "IsSpecialName": <Boolean> false,
            "IsClass": <Boolean> false,
            "IsNestedAssembly": <Boolean> false,
            "IsNestedFamANDAssem": <Boolean> false,
            "IsNestedFamily": <Boolean> false,
            "IsNestedFamORAssem": <Boolean> false,
            "IsNestedPrivate": <Boolean> false,
            "IsNestedPublic": <Boolean> false,
            "IsNotPublic": <Boolean> false,
            "IsPublic": <Boolean> true,
            "IsAutoLayout": <Boolean> false,
            "IsExplicitLayout": <Boolean> false,
            "IsLayoutSequential": <Boolean> true,
            "IsAnsiClass": <Boolean> true,
            "IsAutoClass": <Boolean> false,
            "IsUnicodeClass": <Boolean> false,
            "IsCOMObject": <Boolean> false,
            "IsContextful": <Boolean> false,
            "IsMarshalByRef": <Boolean> false,
            "IsPrimitive": <Boolean> true,
            "IsValueType": <Boolean> true,
            "IsSignatureType": <Boolean> false,
            "TypeInitializer": <ConstructorInfo> null,
            "IsSerializable": <Boolean> true,
            "IsVisible": <Boolean> true,
            "CustomAttributes": <IEnumerable<CustomAttributeData>> ...
        }
        """;
    #endregion
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Security\GlobalUsings.cs 
// Global using directives

global using System;
global using System.Security.Cryptography;
global using System.Text;

global using static DotNetToolbox.Ensure;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Security\Hashing\Hash.cs 
﻿namespace DotNetToolbox.Security.Hashing;

public class Hash(byte[] value, byte[] salt) {
    public byte[] Value { get; } = IsNotNull(value);
    public byte[] Salt { get; } = IsNotNull(salt);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Security\Hashing\IHasher.cs 
﻿namespace DotNetToolbox.Security.Hashing;

public interface IHasher {
    Hash Generate(byte[] secret);
    Hash Generate(string secret);
    bool Validate(Hash hash, byte[] secret);
    bool Validate(Hash hash, string secret);
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Security\Hashing\Sha512Hasher.cs 
﻿namespace DotNetToolbox.Security.Hashing;

public class Sha512Hasher(int keySize = Sha512Hasher.DefaultKeySize, int iterations = Sha512Hasher.DefaultIterations)
    : IHasher {
    public const int DefaultKeySize = 512;
    public const int DefaultIterations = 350000;

    private readonly HashAlgorithmName _hashAlgorithm = HashAlgorithmName.SHA512;

    public Hash Generate(string secret) => Generate(Encoding.UTF8.GetBytes(IsNotNull(secret)));

    public Hash Generate(byte[] secret) {
        var salt = RandomNumberGenerator.GetBytes(keySize);
        var hash = Rfc2898DeriveBytes.Pbkdf2(
            IsNotNull(secret),
            salt,
            iterations,
            _hashAlgorithm,
            keySize);
        return new(hash, salt);
    }

    public bool Validate(Hash hash, string secret) => Validate(IsNotNull(hash), Encoding.UTF8.GetBytes(IsNotNull(secret)));

    public bool Validate(Hash hash, byte[] secret) {
        var testValue = Rfc2898DeriveBytes.Pbkdf2(
                                         IsNotNull(secret),
                                         hash.Salt,
                                         iterations,
                                         _hashAlgorithm,
                                         keySize);
        return IsNotNull(hash).Value.SequenceEqual(testValue);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Security.UnitTests\GlobalUsings.cs 
global using System;
global using System.Reflection;
global using System.Security.Cryptography;

global using FluentAssertions;

global using NSubstitute;

global using Xunit; 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\Security.UnitTests\Hashing\Sha512HasherTests.cs 
namespace DotNetToolbox.Security.Hashing;

public class Sha512HasherTests {
    private readonly Sha512Hasher _sut = new();

    [Fact]
    public void Constants_ReturnsDefaultValues() {
        Sha512Hasher.DefaultIterations.Should().Be(350000);
        Sha512Hasher.DefaultKeySize.Should().Be(512);
    }

    [Fact]
    public void Generate_ReturnsHashWithSalt() {
        // Arrange
        var secret = new byte[] { 1, 2, 3 };

        // Act
        var result = _sut.Generate(secret);

        // Assert
        result.Should().NotBeNull();
        result.Salt.Should().NotBeNull();
        result.Value.Should().NotBeNull();
    }

    [Fact]
    public void Generate_FromString_ReturnsHashWithSalt() {
        // Arrange
        const string secret = "Some secret to hash.";

        // Act
        var result = _sut.Generate(secret);

        // Assert
        result.Should().NotBeNull();
        result.Salt.Should().NotBeNull();
        result.Value.Should().NotBeNull();
    }

    [Fact]
    public void Validate_WithInvalidHash_ReturnsFalse() {
        // Arrange
        var secret = new byte[] { 1, 2, 3 };
        var salt = new byte[] { 4, 5, 6 };
        var hash = new Hash([7, 8, 9], salt);

        // Act
        var result = _sut.Validate(hash, secret);

        // Assert
        result.Should().BeFalse();
    }

    [Fact]
    public void Validate_WithValidHash_ReturnsTrue() {
        // Arrange
        var secret = new byte[] { 1, 2, 3 };
        var subject = _sut.Generate(secret);

        // Act
        var result = _sut.Validate(subject, secret);

        // Assert
        result.Should().BeTrue();
    }

    [Fact]
    public void Validate_FromString_WithValidHash_ReturnsHashWithSalt() {
        // Arrange
        const string secret = "Some secret to hash.";
        var subject = _sut.Generate(secret);

        // Act
        var result = _sut.Validate(subject, secret);

        // Assert
        result.Should().BeTrue();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities\GlobalUsings.cs 
// Global using directives

global using System.Diagnostics.CodeAnalysis;

global using Microsoft.Extensions.Logging;
global using Microsoft.Extensions.Logging.Abstractions;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities\Logging\ITrackedLogger.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public interface ITrackedLogger : ILogger {
    IReadOnlyList<Log> Logs { get; }
    bool IsTrackingAllLevel { get; }
    bool IsTracking { get; }

    void Clear();
    void StartTracking();
    void StopTracking();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities\Logging\Log.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public record Log() {
    [SetsRequiredMembers]
    public Log(LogLevel level, EventId eventId, object state, Exception? exception, string message)
        : this() {
        Level = level;
        EventId = eventId;
        State = state;
        Exception = exception;
        Message = message;
    }

    public LogLevel Level { get; init; }
    public EventId EventId { get; init; }
    public object State { get; init; } = default!;
    public Exception? Exception { get; init; }
    public string Message { get; init; } = string.Empty;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities\Logging\TrackedLogger.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public class TrackedLogger<T>(ILogger<T> logger, bool trackAllLevels = false, bool startsImmediately = true)
    : TrackedLogger(logger, trackAllLevels, startsImmediately), ILogger<T>;

public class TrackedLogger(ILogger logger, bool trackAllLevels = false, bool startsImmediately = true)
    : ITrackedLogger {
    private readonly List<Log> _logs = [];
    public IReadOnlyList<Log> Logs => _logs.AsReadOnly();
    public bool IsTrackingAllLevel { get; } = trackAllLevels;
    public bool IsTracking { get; private set; } = startsImmediately;

    public void Clear() => _logs.Clear();
    public void StartTracking() => IsTracking = true;
    public void StopTracking() => IsTracking = false;

    public void Log<TState>(LogLevel logLevel,
                            EventId eventId,
                            TState state,
                            Exception? exception,
                            Func<TState, Exception?, string> formatter) {
        if (IsTracking && IsEnabled(logLevel))
            _logs.Add(new(logLevel, eventId, state!, exception, formatter(state, exception)));
        logger.Log(logLevel, eventId, state, exception, formatter);
    }

    public virtual bool IsEnabled(LogLevel logLevel) => IsTrackingAllLevel || logger.IsEnabled(logLevel);

    public IDisposable? BeginScope<TState>(TState state)
        where TState : notnull
        => logger.BeginScope(state);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities\Logging\TrackedLoggerFactory.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public sealed class TrackedLoggerFactory(ILoggerFactory loggerFactory) : ILoggerFactory {
    public void AddProvider(ILoggerProvider provider) => loggerFactory.AddProvider(new TrackedLoggerProvider(provider));
    public ILogger CreateLogger(string categoryName) => new TrackedLogger(loggerFactory.CreateLogger(categoryName));
    public void Dispose() => loggerFactory.Dispose();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities\Logging\TrackedLoggerProvider.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public sealed class TrackedLoggerProvider(ILoggerProvider loggerProvider) : ILoggerProvider {
    public ILogger CreateLogger(string categoryName) => new TrackedLogger(loggerProvider.CreateLogger(categoryName));
    public void Dispose() => loggerProvider.Dispose();
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities\Logging\TrackedNullLogger.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public sealed class TrackedNullLogger<T>(LogLevel minimumLevel = default, bool startsImmediately = true)
    : TrackedNullLogger(NullLogger<T>.Instance, minimumLevel, startsImmediately: startsImmediately), ILogger<T> {
    // This static method intentionally does not create a singleton for testing isolation.
    public static new TrackedNullLogger<T> Instance => new();
}

public class TrackedNullLogger
    : TrackedLogger {
    protected TrackedNullLogger(ILogger logger, LogLevel minimumLevel = default, bool startsImmediately = true)
        : base(logger, startsImmediately: startsImmediately) {
        MinimumLevel = minimumLevel;
    }

    public TrackedNullLogger(LogLevel minimumLevel = default, bool startsImmediately = true)
        : this(NullLogger.Instance, minimumLevel, startsImmediately) {
    }

    // This static method intentionally does not create a singleton for testing isolation.
    public static TrackedNullLogger Instance => new();

    public LogLevel MinimumLevel { get; }
    public override bool IsEnabled(LogLevel logLevel) => logLevel >= MinimumLevel;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities\Logging\TrackedNullLoggerFactory.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public sealed class TrackedNullLoggerFactory : ILoggerFactory {
    public static TrackedNullLoggerFactory Instance { get; } = new();

    private TrackedNullLoggerFactory() { }

    public void AddProvider(ILoggerProvider provider) => NullLoggerFactory.Instance.AddProvider(provider);
    public ILogger CreateLogger(string categoryName) => TrackedNullLogger.Instance;
    public void Dispose() => NullLoggerFactory.Instance.Dispose();
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities.UnitTests\GlobalUsings.cs 
global using FluentAssertions;

global using Microsoft.Extensions.Logging;

global using NSubstitute;

global using Xunit; 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities.UnitTests\Logging\LogTests.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public class LogTests {
    [Fact]
    public void Log_Constructor_ShouldSetPropertiesCorrectly() {
        // Arrange
        var log = new Log();
        const LogLevel level = LogLevel.Information;
        var eventId = new EventId(1, "TestEvent");
        var state = new { Message = "TestMessage" };
        var exception = new Exception("TestException");
        const string message = "TestMessage";

        // Act
        var subject = log with {
            Level = level,
            EventId = eventId,
            State = state,
            Exception = exception,
            Message = message,
        };

        // Assert
        subject.Level.Should().Be(level);
        subject.EventId.Should().Be(eventId);
        subject.State.Should().Be(state);
        subject.Exception.Should().Be(exception);
        subject.Message.Should().Be(message);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities.UnitTests\Logging\TrackedLoggerFactoryTests.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public class TrackedLoggerFactoryTests {
    private readonly ILoggerFactory _loggerFactory;
    private readonly TrackedLoggerFactory _trackedLoggerFactory;

    public TrackedLoggerFactoryTests() {
        _loggerFactory = Substitute.For<ILoggerFactory>();
        _trackedLoggerFactory = new TrackedLoggerFactory(_loggerFactory);
    }

    [Fact]
    public void AddProvider_WrapsProviderWithTrackedLoggerProvider() {
        // Arrange
        var provider = Substitute.For<ILoggerProvider>();

        // Act
        _trackedLoggerFactory.AddProvider(provider);

        // Assert
        _loggerFactory.Received(1).AddProvider(Arg.Is<ILoggerProvider>(p => p is TrackedLoggerProvider));
    }

    [Fact]
    public void CreateLogger_ReturnsTrackedLoggerInstance() {
        // Arrange
        const string categoryName = "TestCategory";
        var logger = Substitute.For<ILogger>();
        _loggerFactory.CreateLogger(Arg.Any<string>()).Returns(logger);

        // Act
        var trackedLogger = _trackedLoggerFactory.CreateLogger(categoryName);

        // Assert
        trackedLogger.Should().BeOfType<TrackedLogger>();
        _loggerFactory.Received(1).CreateLogger(Arg.Is<string>(s => s == categoryName));
    }

    [Fact]
    public void Dispose_DisposesUnderlyingLoggerFactory() {
        // Act
        _trackedLoggerFactory.Dispose();

        // Assert
        _loggerFactory.Received(1).Dispose();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities.UnitTests\Logging\TrackedLoggerProviderTests.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public class TrackedLoggerProviderTests {
    private readonly ILoggerProvider _loggerProvider;
    private readonly TrackedLoggerProvider _trackedLoggerProvider;

    public TrackedLoggerProviderTests() {
        _loggerProvider = Substitute.For<ILoggerProvider>();
        _trackedLoggerProvider = new TrackedLoggerProvider(_loggerProvider);
    }

    [Fact]
    public void CreateLogger_ReturnsTrackedLoggerInstance() {
        // Arrange
        const string categoryName = "TestCategory";
        var logger = Substitute.For<ILogger>();
        _loggerProvider.CreateLogger(Arg.Any<string>()).Returns(logger);

        // Act
        var trackedLogger = _trackedLoggerProvider.CreateLogger(categoryName);

        // Assert
        trackedLogger.Should().BeOfType<TrackedLogger>();
        _loggerProvider.Received(1).CreateLogger(Arg.Is<string>(s => s == categoryName));
    }

    [Fact]
    public void Dispose_DisposesUnderlyingLoggerProvider() {
        // Act
        _trackedLoggerProvider.Dispose();

        // Assert
        _loggerProvider.Received(1).Dispose();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities.UnitTests\Logging\TrackedLoggerTests.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public class TrackedLoggerTests {
    private readonly TrackedLogger<TrackedLoggerTests> _trackedLogger;
    private readonly ILogger<TrackedLoggerTests> _logger;

    private static string Formatter(object s, Exception? _) => s.ToString() ?? string.Empty;

    public TrackedLoggerTests() {
        _logger = Substitute.For<ILogger<TrackedLoggerTests>>();
        _trackedLogger = new(_logger);
    }

    [Fact]
    public void Log_WhenEnabled_AddsLogToList() {
        // Arrange
        const LogLevel logLevel = LogLevel.Information;
        var eventId = new EventId(1, "TestEvent");
        const string state = "TestState";
        var exception = new Exception("TestException");
        _logger.IsEnabled(Arg.Any<LogLevel>()).Returns(true);

        // Act
        _trackedLogger.Log(logLevel, eventId, state, exception, Formatter);

        // Assert
        _trackedLogger.Logs.Should().ContainSingle();
        var log = _trackedLogger.Logs[0];
        log.Level.Should().Be(logLevel);
        log.EventId.Should().Be(eventId);
        log.State.Should().Be(state);
        log.Exception.Should().Be(exception);
        log.Message.Should().Be(state);
    }

    [Fact]
    public void Log_WhenDisabled_AndNotTrackingAll_DoesNotAddLogToList() {
        // Arrange
        const LogLevel logLevel = LogLevel.Information;
        var eventId = new EventId(1, "TestEvent");
        const string state = "TestState";
        var exception = new Exception("TestException");
        _logger.IsEnabled(Arg.Any<LogLevel>()).Returns(false);

        // Act
        _trackedLogger.Log(logLevel, eventId, state, exception, Formatter);

        // Assert
        _trackedLogger.Logs.Should().BeEmpty();
    }

    [Fact]
    public void Log_WhenDisabled_ButTrackingAll_DoesNotAddLogToList() {
        // Arrange
        var trackedLogger = new TrackedLogger(_logger, true);
        const LogLevel logLevel = LogLevel.Information;
        var eventId = new EventId(1, "TestEvent");
        const string state = "TestState";
        var exception = new Exception("TestException");
        _logger.IsEnabled(Arg.Any<LogLevel>()).Returns(false);

        // Act
        trackedLogger.Log(logLevel, eventId, state, exception, Formatter);

        // Assert
        trackedLogger.Logs.Should().ContainSingle();
    }

    [Fact]
    public void Log_WhenPaused_DoesNotAddLogToList() {
        // Arrange
        var trackedLogger = new TrackedLogger(_logger, trackAllLevels: true, startsImmediately: false);

        // Act
        trackedLogger.LogInformation("Some log 1.");
        trackedLogger.LogInformation("Some log 2.");
        trackedLogger.StartTracking();
        trackedLogger.LogInformation("Some log 3.");
        trackedLogger.LogInformation("Some log 4.");
        trackedLogger.StopTracking();
        trackedLogger.LogInformation("Some log 5.");

        // Assert
        trackedLogger.Logs.Should().HaveCount(2);
        trackedLogger.Logs[0].Message.Should().Be("Some log 3.");
        trackedLogger.Logs[1].Message.Should().Be("Some log 4.");
    }

    [Fact]
    public void Clear_ClearsLogsList() {
        // Arrange
        _trackedLogger.LogInformation("Some log 1.");

        // Act
        _trackedLogger.Clear();

        // Assert
        _trackedLogger.Logs.Should().BeEmpty();
    }

    [Theory]
    [InlineData(LogLevel.Trace, false)]
    [InlineData(LogLevel.Debug, false)]
    [InlineData(LogLevel.Information, false)]
    [InlineData(LogLevel.Warning, true)]
    [InlineData(LogLevel.Error, true)]
    [InlineData(LogLevel.Critical, true)]
    [InlineData(LogLevel.None, true)]
    public void IsEnabled_WhenLevelNotBellowMinimumLevel_ReturnsTrue(LogLevel level, bool expectedResult) {
        // Arrange & Act
        _logger.IsEnabled(Arg.Any<LogLevel>()).Returns(ci => ci.ArgAt<LogLevel>(0) >= LogLevel.Warning);
        var isEnabled = _trackedLogger.IsEnabled(level);

        // Assert
        isEnabled.Should().Be(expectedResult);
    }

    [Fact]
    public void BeginScope_WhenStateIsDisposable_ReturnsState() {
        // Arrange
        var originalScope = Substitute.For<IDisposable>();
        _logger.BeginScope(Arg.Any<object>()).Returns(originalScope);

        // Act
        var scope = _trackedLogger.BeginScope<object>(new());

        // Assert
        scope.Should().BeSameAs(originalScope);
    }

    [Fact]
    public void BeginScope_WhenStateIsNotDisposable_ReturnsNull() {
        // Arrange
        var state = new object();
        _logger.BeginScope(Arg.Any<object>()).Returns(default(IDisposable));

        // Act
        var scope = _trackedLogger.BeginScope(state);

        // Assert
        scope.Should().BeNull();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities.UnitTests\Logging\TrackedNullLoggerFactoryTests.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public class TrackedNullLoggerFactoryTests {
    private readonly TrackedNullLoggerFactory _trackedLoggerFactory = TrackedNullLoggerFactory.Instance;

    [Fact]
    public void AddProvider_DoesNotThrows() {
        // Arrange
        var provider = Substitute.For<ILoggerProvider>();

        // Act
        var action = () => _trackedLoggerFactory.AddProvider(provider);

        // Assert
        action.Should().NotThrow();
    }

    [Fact]
    public void CreateLogger_ReturnsTrackedNullLoggerInstance() {
        // Arrange
        const string categoryName = "TestCategory";

        // Act
        var trackedLogger = _trackedLoggerFactory.CreateLogger(categoryName);

        // Assert
        trackedLogger.Should().BeOfType<TrackedNullLogger>();
    }

    [Fact]
    public void Dispose_DisposesUnderlyingLoggerFactory() {
        // Arrange & Act
        var action = _trackedLoggerFactory.Dispose;

        // Assert
        action.Should().NotThrow();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\TestUtilities.UnitTests\Logging\TrackedNullLoggerTests.cs 
﻿namespace DotNetToolbox.TestUtilities.Logging;

public class TrackedNullLoggerTests {
    [Fact]
    public void Constructor_ForGeneric_CreatesLog() {
        // Arrange & Act
        var logger = new TrackedNullLogger<TrackedNullLoggerTests>();

        // Assert
        logger.Should().BeAssignableTo<ILogger<TrackedNullLoggerTests>>();
        logger.MinimumLevel.Should().Be(LogLevel.Trace);
    }

    [Fact]
    public void Instance_ForGeneric_CreatesLog() {
        // Arrange & Act
        var logger = TrackedNullLogger<TrackedNullLoggerTests>.Instance;

        // Assert
        logger.Should().BeAssignableTo<ILogger<TrackedNullLoggerTests>>();
        logger.MinimumLevel.Should().Be(LogLevel.Trace);
    }

    [Fact]
    public void Instance_CreatesLog() {
        // Arrange & Act
        var logger = TrackedNullLogger.Instance;

        // Assert
        logger.Should().BeAssignableTo<ILogger>();
        logger.MinimumLevel.Should().Be(LogLevel.Trace);
    }

    [Theory]
    [InlineData(LogLevel.Trace, false)]
    [InlineData(LogLevel.Debug, false)]
    [InlineData(LogLevel.Information, false)]
    [InlineData(LogLevel.Warning, true)]
    [InlineData(LogLevel.Error, true)]
    [InlineData(LogLevel.Critical, true)]
    [InlineData(LogLevel.None, true)]
    public void IsEnabled_ForGeneric_ReturnsTrue_IfAboveOrEqualMinimum(LogLevel level, bool expectedResult) {
        // Arrange
        var logger = new TrackedNullLogger<TrackedNullLoggerTests>(LogLevel.Warning);

        // Act
        var isEnabled = logger.IsEnabled(level);

        // Assert
        isEnabled.Should().Be(expectedResult);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\CollectionValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public sealed class CollectionValidator<TItem>
    : Validator<ICollection<TItem?>>, ICollectionValidator<TItem> {
    private readonly ValidationCommandFactory _commandFactory;

    public CollectionValidator(ICollection<TItem?>? subject, string source, ValidatorMode mode = And)
        : base(subject, source, mode) {
        Connector = new Connector<ICollection<TItem?>, CollectionValidator<TItem>>(this);
        _commandFactory = ValidationCommandFactory.For(typeof(ICollection<TItem?>), Source);
    }

    public IConnector<CollectionValidator<TItem>> Connector { get; }

    public IConnector<CollectionValidator<TItem>> IsNull() {
        var validator = _commandFactory.Create(nameof(IsNull));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<CollectionValidator<TItem>> IsNotNull() {
        Negate();
        return IsNull();
    }

    public IConnector<CollectionValidator<TItem>> IsEmpty() {
        var validator = _commandFactory.Create(nameof(IsEmpty));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<CollectionValidator<TItem>> IsNotEmpty() {
        Negate();
        return IsEmpty();
    }

    public IConnector<CollectionValidator<TItem>> HasAtLeast(int size) {
        var validator = _commandFactory.Create(nameof(HasAtLeast), size);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<CollectionValidator<TItem>> Has(int size) {
        var validator = _commandFactory.Create(nameof(Has), size);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<CollectionValidator<TItem>> Contains(TItem item) {
        var validator = _commandFactory.Create(nameof(Contains), item);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<CollectionValidator<TItem>> HasAtMost(int size) {
        var validator = _commandFactory.Create(nameof(HasAtMost), size);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<CollectionValidator<TItem>> Each(Func<TItem?, ITerminator> validate) {
        if (Subject is null) return Connector;
        var index = 0;
        foreach (var item in Subject)
            AddItemErrors(validate(item).Result.Errors, $"{Source}[{index++}]");
        return Connector;
    }

    private void AddItemErrors(IEnumerable<ValidationError> errors, string source) {
        foreach (var error in errors) {
            var path = error.Source.Split('.');
            var newSource = path.Length > 1 ? $"{source}.{string.Join('.', path[1..])}" : source;
            AddError(new(newSource, error.Message));
        }
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Connector.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public class Connector<TSubject, TValidator>(TValidator left) : IConnector<TValidator>
    where TValidator : Validator<TSubject> {
    public Result Result => left.Result;

    public TValidator And() => (TValidator)left.SetMode(ValidatorMode.And);
    public TValidator Or() => (TValidator)left.SetMode(ValidatorMode.Or);
    public TValidator AndNot() => (TValidator)left.SetMode(ValidatorMode.AndNot);
    public TValidator OrNot() => (TValidator)left.SetMode(ValidatorMode.OrNot);

    public TValidator And(Func<TValidator, ITerminator> validateRight)
        => ProcessAnd(validateRight, ValidatorMode.And);

    public TValidator AndNot(Func<TValidator, ITerminator> validateRight)
        => ProcessAnd(validateRight, ValidatorMode.AndNot);

    public TValidator Or(Func<TValidator, ITerminator> validateRight)
        => ProcessOr(validateRight, ValidatorMode.And);

    public TValidator OrNot(Func<TValidator, ITerminator> validateRight)
        => ProcessOr(validateRight, ValidatorMode.AndNot);

    private TValidator ProcessAnd(Func<TValidator, ITerminator> validateRight, ValidatorMode mode) {
        var rightValidator = CreateInstance.Of<TValidator>(left.Subject!, left.Source, mode);
        var rightResult = validateRight(rightValidator).Result;
        left.AddErrors(rightResult.Errors);
        return left;
    }

    private TValidator ProcessOr(Func<TValidator, ITerminator> validateRight, ValidatorMode mode) {
        var rightValidator = CreateInstance.Of<TValidator>(left.Subject!, left.Source, mode);
        var rightResult = validateRight(rightValidator).Result;
        if (left.Result.IsInvalid && rightResult.IsInvalid)
            left.AddErrors(rightResult.Errors);
        else
            left.ClearErrors();
        return left;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\DateTimeValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public class DateTimeValidator : Validator<DateTime?>, IDateTimeProviderValidator {
    private readonly ValidationCommandFactory _commandFactory;

    public DateTimeValidator(DateTime? subject, string source, ValidatorMode mode = And)
        : base(subject, source, mode) {
        Connector = new Connector<DateTime?, DateTimeValidator>(this);
        _commandFactory = ValidationCommandFactory.For(typeof(DateTime?), Source);
    }

    public IConnector<DateTimeValidator> Connector { get; }

    public IConnector<DateTimeValidator> IsNull() {
        var validator = _commandFactory.Create(nameof(IsNull));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DateTimeValidator> IsNotNull() {
        Negate();
        return IsNull();
    }

    public IConnector<DateTimeValidator> IsBefore(DateTime dateTime) {
        var validator = _commandFactory.Create(nameof(IsBefore), dateTime);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DateTimeValidator> StartsOn(DateTime dateTime) {
        Negate();
        return IsBefore(dateTime);
    }

    public IConnector<DateTimeValidator> EndsOn(DateTime dateTime) {
        Negate();
        return IsAfter(dateTime);
    }

    public IConnector<DateTimeValidator> IsAfter(DateTime dateTime) {
        var validator = _commandFactory.Create(nameof(IsAfter), dateTime);
        ValidateWith(validator);
        return Connector;
    }
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\DecimalValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public class DecimalValidator : Validator<decimal?>, IDecimalValidator {
    private readonly ValidationCommandFactory _commandFactory;

    public DecimalValidator(decimal? subject, string source, ValidatorMode mode = And)
        : base(subject, source, mode) {
        Connector = new Connector<decimal?, DecimalValidator>(this);
        _commandFactory = ValidationCommandFactory.For(typeof(decimal?), Source);
    }

    public IConnector<DecimalValidator> Connector { get; }

    public IConnector<DecimalValidator> IsNull() {
        var validator = _commandFactory.Create(nameof(IsNull));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DecimalValidator> IsNotNull() {
        Negate();
        return IsNull();
    }

    public IConnector<DecimalValidator> MinimumIs(decimal minimum) {
        Negate();
        return IsLessThan(minimum);
    }

    public IConnector<DecimalValidator> IsGreaterThan(decimal minimum) {
        var validator = _commandFactory.Create(nameof(IsGreaterThan), minimum);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DecimalValidator> IsEqualTo(decimal value) {
        var validator = _commandFactory.Create(nameof(IsEqualTo), value);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DecimalValidator> IsLessThan(decimal maximum) {
        var validator = _commandFactory.Create(nameof(IsLessThan), maximum);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DecimalValidator> MaximumIs(decimal maximum) {
        Negate();
        return IsGreaterThan(maximum);
    }
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\DictionaryValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public class DictionaryValidator<TKey, TValue>
    : Validator<IDictionary<TKey, TValue?>>
        , IDictionaryValidator<TKey, TValue>
    where TKey : notnull {
    private readonly ValidationCommandFactory _commandFactory;

    public DictionaryValidator(IDictionary<TKey, TValue?>? subject, string source, ValidatorMode mode = And)
        : base(subject, source, mode) {
        Connector = new Connector<IDictionary<TKey, TValue?>, DictionaryValidator<TKey, TValue>>(this);
        _commandFactory = ValidationCommandFactory.For(typeof(IDictionary<TKey, TValue?>), Source);
    }

    public IConnector<DictionaryValidator<TKey, TValue>> Connector { get; }

    public IConnector<DictionaryValidator<TKey, TValue>> IsNull() {
        var validator = _commandFactory.Create(nameof(IsNull));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DictionaryValidator<TKey, TValue>> IsNotNull() {
        Negate();
        return IsNull();
    }

    public IConnector<DictionaryValidator<TKey, TValue>> IsEmpty() {
        var validator = _commandFactory.Create(nameof(IsEmpty));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DictionaryValidator<TKey, TValue>> IsNotEmpty() {
        Negate();
        return IsEmpty();
    }

    public IConnector<DictionaryValidator<TKey, TValue>> HasAtLeast(int size) {
        var validator = _commandFactory.Create(nameof(HasAtLeast), size);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DictionaryValidator<TKey, TValue>> Has(int size) {
        var validator = _commandFactory.Create(nameof(Has), size);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DictionaryValidator<TKey, TValue>> ContainsKey(TKey key) {
        var validator = _commandFactory.Create(nameof(ContainsKey), key);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DictionaryValidator<TKey, TValue>> HasAtMost(int size) {
        var validator = _commandFactory.Create(nameof(HasAtMost), size);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<DictionaryValidator<TKey, TValue>> Each(Func<TValue?, ITerminator> validateUsing) {
        if (Subject is null) return Connector;
        foreach (var key in Subject.Keys)
            AddItemErrors(validateUsing(Subject[key]).Result.Errors, $"{Source}[{key}]");
        return Connector;
    }

    private void AddItemErrors(IEnumerable<ValidationError> errors, string source) {
        foreach (var error in errors) {
            var path = error.Source.Split('.');
            var newSource = $"{source}.{string.Join('.', path[1..])}";
            AddError(new(newSource, error.Message));
        }
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\GlobalUsings.cs 
// Global using directives

global using System;
global using System.Collections;
global using System.Diagnostics.CodeAnalysis;
global using System.Runtime.CompilerServices;
global using System.Text;
global using System.Text.RegularExpressions;

global using DotNetToolbox.Results;
global using DotNetToolbox.ValidationBuilder.Commands;

global using static System.Constants.ErrorMessages;
global using static DotNetToolbox.Ensure;
global using static DotNetToolbox.ValidationBuilder.ValidatorFactory;
global using static DotNetToolbox.ValidationBuilder.ValidatorMode;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IBinaryConnector.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface IBinaryConnector<out TValidator>
    where TValidator : IValidator {
    TValidator And();
    TValidator Or();
    TValidator AndNot();
    TValidator OrNot();
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IBinaryOperator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface IBinaryOperator<out TValidator>
    where TValidator : IValidator {
    TValidator And(Func<TValidator, ITerminator> validateRight);
    TValidator Or(Func<TValidator, ITerminator> validateRight);
    TValidator AndNot(Func<TValidator, ITerminator> validateRight);
    TValidator OrNot(Func<TValidator, ITerminator> validateRight);
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\ICollectionValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface ICollectionValidator<TItem> : IValidator {
    IConnector<CollectionValidator<TItem>> IsNull();
    IConnector<CollectionValidator<TItem>> IsNotNull();
    IConnector<CollectionValidator<TItem>> IsEmpty();
    IConnector<CollectionValidator<TItem>> IsNotEmpty();
    IConnector<CollectionValidator<TItem>> HasAtMost(int size);
    IConnector<CollectionValidator<TItem>> HasAtLeast(int size);
    IConnector<CollectionValidator<TItem>> Has(int size);
    IConnector<CollectionValidator<TItem>> Contains(TItem item);

    IConnector<CollectionValidator<TItem>> Each(Func<TItem?, ITerminator> validate);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IConnector.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface IConnector<out TValidator>
    : ITerminator,
      IBinaryConnector<TValidator>,
      IBinaryOperator<TValidator>
    where TValidator : IValidator;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IDateTimeValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface IDateTimeProviderValidator : IValidator {
    IConnector<DateTimeValidator> IsNull();
    IConnector<DateTimeValidator> IsNotNull();
    IConnector<DateTimeValidator> IsAfter(DateTime dateTime);
    IConnector<DateTimeValidator> IsBefore(DateTime dateTime);
    IConnector<DateTimeValidator> StartsOn(DateTime dateTime);
    IConnector<DateTimeValidator> EndsOn(DateTime dateTime);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IDecimalValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface IDecimalValidator : IValidator {
    IConnector<DecimalValidator> IsNull();
    IConnector<DecimalValidator> IsNotNull();
    IConnector<DecimalValidator> MinimumIs(decimal minimum);
    IConnector<DecimalValidator> IsGreaterThan(decimal minimum);
    IConnector<DecimalValidator> IsEqualTo(decimal value);
    IConnector<DecimalValidator> IsLessThan(decimal maximum);
    IConnector<DecimalValidator> MaximumIs(decimal maximum);
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IDictionaryValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface IDictionaryValidator<TKey, TValue> : IValidator
    where TKey : notnull {
    IConnector<DictionaryValidator<TKey, TValue>> IsNull();
    IConnector<DictionaryValidator<TKey, TValue>> IsNotNull();
    IConnector<DictionaryValidator<TKey, TValue>> IsNotEmpty();
    IConnector<DictionaryValidator<TKey, TValue>> HasAtMost(int size);
    IConnector<DictionaryValidator<TKey, TValue>> HasAtLeast(int size);
    IConnector<DictionaryValidator<TKey, TValue>> Has(int size);
    IConnector<DictionaryValidator<TKey, TValue>> ContainsKey(TKey key);

    IConnector<DictionaryValidator<TKey, TValue>> Each(Func<TValue?, ITerminator> validateUsing);
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IIntegerValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface IIntegerValidator : IValidator {
    IConnector<IntegerValidator> IsNull();
    IConnector<IntegerValidator> IsNotNull();
    IConnector<IntegerValidator> MinimumIs(int minimum);
    IConnector<IntegerValidator> IsGreaterThan(int minimum);
    IConnector<IntegerValidator> IsEqualTo(int value);
    IConnector<IntegerValidator> IsLessThan(int maximum);
    IConnector<IntegerValidator> MaximumIs(int maximum);
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IntegerValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public class IntegerValidator : Validator<int?>, IIntegerValidator {
    private readonly ValidationCommandFactory _commandFactory;

    public IntegerValidator(int? subject, string source, ValidatorMode mode = And)
        : base(subject, source, mode) {
        Connector = new Connector<int?, IntegerValidator>(this);
        _commandFactory = ValidationCommandFactory.For(typeof(int?), Source);
    }

    public IConnector<IntegerValidator> Connector { get; }

    public IConnector<IntegerValidator> IsNull() {
        var validator = _commandFactory.Create(nameof(IsNull));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<IntegerValidator> IsNotNull() {
        Negate();
        return IsNull();
    }

    public IConnector<IntegerValidator> MinimumIs(int minimum) {
        Negate();
        return IsLessThan(minimum);
    }

    public IConnector<IntegerValidator> IsGreaterThan(int minimum) {
        var validator = _commandFactory.Create(nameof(IsGreaterThan), minimum);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<IntegerValidator> IsEqualTo(int value) {
        var validator = _commandFactory.Create(nameof(IsEqualTo), value);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<IntegerValidator> IsLessThan(int maximum) {
        var validator = _commandFactory.Create(nameof(IsLessThan), maximum);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<IntegerValidator> MaximumIs(int maximum) {
        Negate();
        return IsGreaterThan(maximum);
    }
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IObjectValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface IObjectValidator : IValidator {
    IConnector<ObjectValidator> IsNull();
    IConnector<ObjectValidator> IsNotNull();
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IStringValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface IStringValidator : IValidator {
    IConnector<StringValidator> IsNull();
    IConnector<StringValidator> IsNotNull();
    IConnector<StringValidator> IsEmpty();
    IConnector<StringValidator> IsNotEmpty();
    IConnector<StringValidator> IsEmptyOrWhiteSpace();
    IConnector<StringValidator> IsNotEmptyOrWhiteSpace();
    IConnector<StringValidator> LengthIsAtLeast(int length);
    IConnector<StringValidator> LengthIsAtMost(int length);
    IConnector<StringValidator> LengthIs(int length);
    IConnector<StringValidator> IsIn(params string[] list);
    IConnector<StringValidator> IsEmail();
    IConnector<StringValidator> IsValidPassword(IValidatable policy);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\ITerminator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface ITerminator {
    Result Result { get; }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\ITypeValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface ITypeValidator : IValidator {
    IConnector<TypeValidator> IsNull();
    IConnector<TypeValidator> IsNotNull();
    IConnector<TypeValidator> IsEqualTo<TType>();
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IValidatableValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface IValidatableValidator : IValidator {
    IConnector<ValidatableValidator> IsNull();
    IConnector<ValidatableValidator> IsNotNull();
    IConnector<ValidatableValidator> IsValid();
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\IValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public interface IValidator {
    ValidatorMode Mode { get; }
    string Source { get; }
    Result Result { get; }

    Validator SetMode(ValidatorMode mode);
    void Negate();
    void ClearErrors();
    void AddError(ValidationError error);
    void AddErrors(IEnumerable<ValidationError> errors);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\ObjectValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public class ObjectValidator : Validator<object?>, IObjectValidator {
    private readonly ValidationCommandFactory _commandFactory;

    public ObjectValidator(object? subject, string source, ValidatorMode mode = And)
        : base(subject, source, mode) {
        Connector = new(this);
        _commandFactory = ValidationCommandFactory.For(typeof(int?), Source);
    }

    public Connector<object?, ObjectValidator> Connector { get; }

    public IConnector<ObjectValidator> IsNull() {
        var validator = _commandFactory.Create(nameof(IsNull));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<ObjectValidator> IsNotNull() {
        Negate();
        return IsNull();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\StringValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public class StringValidator : Validator<string?>, IStringValidator {
    private readonly ValidationCommandFactory _commandFactory;

    public StringValidator(string? subject, string source, ValidatorMode mode = And)
        : base(subject, source, mode) {
        Connector = new Connector<string?, StringValidator>(this);
        _commandFactory = ValidationCommandFactory.For(typeof(string), Source);
    }

    public IConnector<StringValidator> Connector { get; }

    public IConnector<StringValidator> IsNull() {
        var validator = _commandFactory.Create(nameof(IsNull));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<StringValidator> IsNotNull() {
        Negate();
        return IsNull();
    }

    public IConnector<StringValidator> IsEmpty() {
        var validator = _commandFactory.Create(nameof(IsEmpty));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<StringValidator> IsNotEmpty() {
        Negate();
        return IsEmpty();
    }

    public IConnector<StringValidator> IsEmptyOrWhiteSpace() {
        var validator = _commandFactory.Create(nameof(IsEmptyOrWhiteSpace));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<StringValidator> IsNotEmptyOrWhiteSpace() {
        Negate();
        return IsEmptyOrWhiteSpace();
    }

    public IConnector<StringValidator> LengthIsAtLeast(int length) {
        var validator = _commandFactory.Create(nameof(LengthIsAtLeast), length);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<StringValidator> Contains(string substring) {
        var validator = _commandFactory.Create(nameof(Contains), substring);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<StringValidator> IsIn(params string[] list) {
        var validator = _commandFactory.Create(nameof(IsIn), list.OfType<object?>().ToArray());
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<StringValidator> LengthIs(int length) {
        var validator = _commandFactory.Create(nameof(LengthIs), length);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<StringValidator> LengthIsAtMost(int length) {
        var validator = _commandFactory.Create(nameof(LengthIsAtMost), length);
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<StringValidator> IsEmail() {
        var validator = _commandFactory.Create(nameof(IsEmail));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<StringValidator> IsValidPassword(IValidatable policy) {
        var validator = _commandFactory.Create(nameof(IsValidPassword), policy);
        ValidateWith(validator);
        return Connector;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\TypeValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public class TypeValidator : Validator<Type?>, ITypeValidator {
    private readonly ValidationCommandFactory _commandFactory;

    public TypeValidator(Type? subject, string source, ValidatorMode mode = And)
        : base(subject, source, mode) {
        Connector1 = new Connector<Type?, TypeValidator>(this);
        _commandFactory = ValidationCommandFactory.For(typeof(Type), Source);
    }

    public IConnector<TypeValidator> Connector1 { get; }

    public IConnector<TypeValidator> IsNull() {
        var validator = _commandFactory.Create(nameof(IsNull));
        ValidateWith(validator);
        return Connector1;
    }

    public IConnector<TypeValidator> IsNotNull() {
        Negate();
        return IsNull();
    }

    public IConnector<TypeValidator> IsEqualTo<TType>() {
        var validator = _commandFactory.Create(nameof(IsEqualTo), typeof(TType));
        ValidateWith(validator);
        return Connector1;
    }
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\ValidatableValidator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;
public class ValidatableValidator : Validator<IValidatable?>, IValidatableValidator {
    private readonly ValidationCommandFactory _commandFactory;

    public ValidatableValidator(IValidatable? subject, string source, ValidatorMode mode = And)
        : base(subject, source, mode) {
        Connector = new Connector<IValidatable?, ValidatableValidator>(this);
        _commandFactory = ValidationCommandFactory.For(typeof(IValidatable), Source);
    }

    public IConnector<ValidatableValidator> Connector { get; }

    public IConnector<ValidatableValidator> IsNull() {
        var validator = _commandFactory.Create(nameof(IsNull));
        ValidateWith(validator);
        return Connector;
    }

    public IConnector<ValidatableValidator> IsNotNull() {
        Negate();
        return IsNull();
    }

    public IConnector<ValidatableValidator> IsValid() {
        var validator = _commandFactory.Create(nameof(IsValid));
        ValidateWith(validator);
        return Connector;
    }
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Validator.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public abstract class Validator(string source, ValidatorMode mode = And) : IValidator {
    public ValidatorMode Mode { get; private set; } = mode;
    public string Source { get; } = source;
    public Result Result { get; private set; } = Result.Success();

    public Validator SetMode(ValidatorMode mode) {
        Mode = mode;
        return this;
    }

    public void Negate() => Mode ^= Not;

    public void ClearErrors() => Result = Result.Success();

    public void AddError(ValidationError error) => Result += error;

    public void AddErrors(IEnumerable<ValidationError> errors) => Result += errors.ToArray();
}

public abstract class Validator<TSubject>(TSubject? subject, string source, ValidatorMode mode = And) : Validator(source, mode) {
    public TSubject? Subject { get; } = subject;

    protected void ValidateWith(IValidationCommand validator) {
        var rightResult = Mode.Has(Not)
            ? validator.Negate(Subject)
            : validator.Validate(Subject);
        if (Mode.Has(Or) && (rightResult.IsSuccess || Result.IsSuccess)) {
            ClearErrors();
            return;
        }

        AddErrors(rightResult.Errors);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\ValidatorFactory.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

public static class ValidatorFactory {
    public static IConnector<CollectionValidator<TSubject>> Create<TSubject>(ICollection<TSubject?>? subject, string source, ValidatorMode mode = And) {
        var validator = new CollectionValidator<TSubject>(subject, source, mode);
        return validator.IsNotNull();
    }

    public static IConnector<CollectionValidator<TSubject>> Create<TSubject>(ICollection<TSubject?>? subject, string source, Func<TSubject?, ITerminator> itemIsValid, ValidatorMode mode = And) {
        var validator = new CollectionValidator<TSubject>(subject, source, mode);
        return validator.IsNotNull().And().Each(itemIsValid);
    }

    public static IConnector<DateTimeValidator> Create(bool allowNull, DateTime? subject, string source, ValidatorMode mode = And) {
        var validator = new DateTimeValidator(subject, source, mode);
        return allowNull ? validator.Connector : validator.IsNotNull();
    }

    public static IConnector<DecimalValidator> Create(bool allowNull, decimal? subject, string source, ValidatorMode mode = And) {
        var validator = new DecimalValidator(subject, source, mode);
        return allowNull ? validator.Connector : validator.IsNotNull();
    }

    public static IConnector<DictionaryValidator<TSubjectKey, TSubjectValue>> Create<TSubjectKey, TSubjectValue>(IDictionary<TSubjectKey, TSubjectValue?>? subject, string source, ValidatorMode mode = And)
        where TSubjectKey : notnull {
        var validator = new DictionaryValidator<TSubjectKey, TSubjectValue>(subject, source, mode);
        return validator.IsNotNull();
    }

    public static IConnector<DictionaryValidator<TSubjectKey, TSubjectValue>> Create<TSubjectKey, TSubjectValue>(IDictionary<TSubjectKey, TSubjectValue?>? subject, string source, Func<TSubjectValue?, ITerminator> validateValue, ValidatorMode mode = And)
        where TSubjectKey : notnull {
        var validator = new DictionaryValidator<TSubjectKey, TSubjectValue>(subject, source, mode);
        return validator.IsNotNull().And().Each(validateValue);
    }

    public static IConnector<IntegerValidator> Create(bool allowNull, int? subject, string source, ValidatorMode mode = And) {
        var validator = new IntegerValidator(subject, source, mode);
        return allowNull ? validator.Connector : validator.IsNotNull();
    }

    public static IConnector<ObjectValidator> Create(bool allowNull, object? subject, string source, ValidatorMode mode = And) {
        var validator = new ObjectValidator(subject, source, mode);
        return allowNull ? validator.Connector : validator.IsNotNull();
    }

    public static IConnector<StringValidator> Create(bool allowNull, string? subject, string source, ValidatorMode mode = And) {
        var validator = new StringValidator(subject, source, mode);
        return allowNull ? validator.Connector : validator.IsNotNull();
    }

    public static IConnector<TypeValidator> Create(Type? subject, string source, ValidatorMode mode = And) {
        var validator = new TypeValidator(subject, source, mode);
        return validator.IsNotNull();
    }

    public static IConnector<ValidatableValidator> Create(bool allowNull, IValidatable? subject, string source, ValidatorMode mode = And) {
        var validator = new ValidatableValidator(subject, source, mode);
        return allowNull ? validator.Connector : validator.IsNotNull();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\ValidatorMode.cs 
﻿namespace DotNetToolbox.ValidationBuilder;

[Flags]
public enum ValidatorMode {
    And =        0b0001,
    Or =         0b0010,
    Not =        0b0100,
    AndNot =  And | Not,
    OrNot =    Or | Not,
}

public static class ValidatorModeExtensions {
    public static bool Has(this ValidatorMode mode, ValidatorMode flag)
        => (mode & flag) == flag;
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\ContainsCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class ContainsCommand
    : ValidationCommand {
    public ContainsCommand(string subString, string source)
        : base(source) {
        ValidateAs = s => ((string)s).Contains(subString);
        ValidationErrorMessage = MustContain;
        GetErrorMessageArguments = _ => [subString];
    }
}

public sealed class ContainsCommand<TItem>
    : ValidationCommand {
    public ContainsCommand(TItem? item, string source)
        : base(source) {
        ValidateAs = c => ((ICollection<TItem?>)c).Contains(item);
        ValidationErrorMessage = MustContain;
        GetErrorMessageArguments = _ => [item!];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\ContainsKeyCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class ContainsKeyCommand<TKey, TValue>
    : ValidationCommand
    where TKey : notnull {
    public ContainsKeyCommand(TKey key, string source)
        : base(source) {
        ValidateAs = d => ((IDictionary<TKey, TValue?>)d).ContainsKey(key);
        ValidationErrorMessage = MustContainKey;
        GetErrorMessageArguments = _ => [key];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\ContainsValueCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class ContainsValueCommand<TKey, TValue>
    : ValidationCommand
    where TKey : notnull {
    public ContainsValueCommand(TValue? value, string source)
        : base(source) {
        ValidateAs = d => ((IDictionary<TKey, TValue?>)d).Values.Contains(value);
        ValidationErrorMessage = MustContainValue;
        GetErrorMessageArguments = _ => [value!];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\CountIsCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class HasCommand<TItem>
    : ValidationCommand {
    public HasCommand(int count, string source)
        : base(source) {
        ValidateAs = c => ((ICollection<TItem?>)c).Count == count;
        ValidationErrorMessage = MustHaveACountOf;
        GetErrorMessageArguments = c => [count, ((ICollection<TItem?>)c!).Count];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsAfterCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class IsAfterCommand
    : ValidationCommand {
    public IsAfterCommand(DateTime @event, string source)
        : base(source) {
        ValidateAs = dt => (DateTime)dt > @event;
        ValidationErrorMessage = MustBeAfter;
        GetErrorMessageArguments = dt => [@event, (DateTime)dt!];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsBeforeCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class IsBeforeCommand
    : ValidationCommand {
    public IsBeforeCommand(DateTime @event, string source)
        : base(source) {
        ValidateAs = dt => (DateTime)dt < @event;
        ValidationErrorMessage = MustBeBefore;
        GetErrorMessageArguments = dt => [@event, (DateTime)dt!];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsEmailCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed partial class IsEmailCommand
    : ValidationCommand {
    public IsEmailCommand(string source)
        : base(source) {
        ValidateAs = s => EmailChecker().IsMatch((string)s);
        ValidationErrorMessage = MustBeAValidEmail;
    }

    [GeneratedRegex("^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$", RegexOptions.Compiled | RegexOptions.CultureInvariant)]
    private static partial Regex EmailChecker();
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsEmptyCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class IsEmptyCommand
    : ValidationCommand {
    public IsEmptyCommand(string source)
        : base(source) {
        ValidateAs = s => ((string)s).Length == 0;
        ValidationErrorMessage = MustBeEmpty;
    }
}

public sealed class IsEmptyCommand<TItem>
    : ValidationCommand {
    public IsEmptyCommand(string source)
        : base(source) {
        ValidateAs = c => ((ICollection<TItem?>)c).Count == 0;
        ValidationErrorMessage = MustBeEmpty;
    }
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsEmptyOrWhiteSpaceCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class IsEmptyOrWhiteSpaceCommand
    : ValidationCommand {
    public IsEmptyOrWhiteSpaceCommand(string source)
        : base(source) {
        ValidateAs = s => ((string)s).Trim().Length == 0;
        ValidationErrorMessage = MustBeEmptyOrWhiteSpace;
    }
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsEqualToCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class IsEqualToCommand
    : ValidationCommand{
    public IsEqualToCommand(object value, string source)
        : base(source) {
        ValidateAs = o => IsEquivalent(value, o);
        ValidationErrorMessage = MustBeEqualTo;
        GetErrorMessageArguments = o => [GetString(value), GetString(o)];
    }

    private static string GetString(object? o) {
        if (o is not IEnumerable oc) return $"{o}";
        var sb = new StringBuilder();
        sb.Append('[');
        foreach (var i in oc) {
            sb.Append(GetString(i));
            sb.Append(", ");
        }

        sb.Remove(sb.Length - 2, 2);
        sb.Append(']');
        return sb.ToString();
    }

    private static bool IsEquivalent(object v, object? o)
    {
        if (v.Equals(o)) return true;
        if (v is not ICollection vc) return false;
        if (o is not ICollection oc) return false;
        if (oc.Count != vc.Count) return false;
        var d1 = GroupByCount(oc);
        var d2 = GroupByCount(vc);
        if (d1.Count != d2.Count) return false;
        foreach (var k1 in d1.Keys)
        {
            var k2 = d2.Keys.FirstOrDefault(k => IsEquivalent(k1, k));
            if (k2 is null) return false;
            if (d2[k2] != d1[k1]) return false;
        }

        return true;
    }

    private static Dictionary<object, int> GroupByCount(IEnumerable oc)
    {
        var d1 = new Dictionary<object, int>();
        foreach (var i in oc) {
            if (d1.TryGetValue(i, out var value)) d1[i] = ++value;
            else d1.Add(i, 1);
        }

        return d1;
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsGreaterThanCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class IsGreaterThanCommand<TValue>
    : ValidationCommand
    where TValue : IComparable<TValue> {
    public IsGreaterThanCommand(TValue threshold, string source)
        : base(source) {
        ValidateAs = v => ((TValue)v).CompareTo(threshold) > 0;
        ValidationErrorMessage = MustBeGraterThan;
        GetErrorMessageArguments = v => [threshold, v!];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsInCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class IsInCommand<TItem>
    : ValidationCommand {
    public IsInCommand(TItem?[] list, string source)
        : base(source) {
        ValidateAs = i => list.Contains((TItem)i);
        ValidationErrorMessage = MustBeIn;
        GetErrorMessageArguments = i => [list, i!];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsLessThanCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class IsLessThanCommand<TValue>
    : ValidationCommand
    where TValue : IComparable<TValue> {
    public IsLessThanCommand(TValue threshold, string source)
        : base(source) {
        ValidateAs = v => ((TValue)v).CompareTo(threshold) < 0;
        ValidationErrorMessage = MustBeLessThan;
        GetErrorMessageArguments = v => [threshold, v!];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsNullCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class IsNullCommand : ValidationCommand {
    public IsNullCommand(string source)
        : base(source) {
        ValidationErrorMessage = MustBeNull;
    }

    public override Result Validate(object? subject)
        => subject is null
        ? Result.Success()
        : Result.Invalid(Source, string.Format(ValidationErrorMessage, GetErrorMessageArguments(subject)));

    public override Result Negate(object? subject)
        => subject is not null
        ? Result.Success()
        : Result.Invalid(Source, string.Format(InvertMessage(ValidationErrorMessage), GetErrorMessageArguments(subject)));
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsValidCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class IsValidCommand(string source) : ValidationCommand(source) {
    public override Result Validate(object? subject) {
        var result = Result.Success();
        return subject is not IValidatable v
                   ? result
                   : v.Validate().Errors
                      .Aggregate(result, (current, error) => {
                          var newSource = $"{Source}.{error.Source}";
                          return current + new ValidationError(error.Message, newSource);
                      });
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IsValidPasswordCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class IsValidPasswordCommand(IValidatable policy, string source) : ValidationCommand(source) {
    public override Result Validate(object? subject) {
        if (subject is not string password) return Result.Success();
        var context = new Dictionary<string, object?> { ["Password"] = password };
        var policyResult = policy.Validate(context);
        if (policyResult.IsSuccess) return Result.Success();
        var result = Result.Invalid(Source, MustBeAValidPassword);
        return policyResult.Errors.Aggregate(result, (current, error) => current + error);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\IValidationCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public interface IValidationCommand {
    Result Validate(object? subject);
    Result Negate(object? subject);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\LengthIsCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class LengthIsCommand
    : ValidationCommand {
    public LengthIsCommand(int length, string source)
        : base(source) {
        ValidateAs = s => ((string)s).Length == length;
        ValidationErrorMessage = MustHaveALengthOf;
        GetErrorMessageArguments = s => [length, ((string)s!).Length];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\MaximumCountIsCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class HasAtMostCommand<TItem>
    : ValidationCommand {
    public HasAtMostCommand(int count, string source)
        : base(source) {
        ValidateAs = o => ((ICollection<TItem?>)o).Count <= count;
        ValidationErrorMessage = MustHaveAMaximumCountOf;
        GetErrorMessageArguments = c => [count, ((ICollection<TItem?>)c!).Count];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\MaximumLengthIsCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class LengthIsAtMostCommand
    : ValidationCommand {
    public LengthIsAtMostCommand(int length, string source)
        : base(source) {
        ValidateAs = s => ((string)s).Length <= length;
        ValidationErrorMessage = MustHaveAMaximumLengthOf;
        GetErrorMessageArguments = s => [length, ((string)s!).Length];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\MinimumCountIsCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class HasAtLeastCommand<TItem>
    : ValidationCommand {
    public HasAtLeastCommand(int count, string source)
        : base(source) {
        ValidateAs = c => ((ICollection<TItem?>)c).Count >= count;
        ValidationErrorMessage = MustHaveAMinimumCountOf;
        GetErrorMessageArguments = c => [count, ((ICollection<TItem?>)c!).Count];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\MinimumLengthIsCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class LengthIsAtLeastCommand : ValidationCommand {
    public LengthIsAtLeastCommand(int length, string source)
        : base(source) {
        ValidateAs = s => ((string)s).Length >= length;
        ValidationErrorMessage = MustHaveAMinimumLengthOf;
        GetErrorMessageArguments = s => [length, ((string)s!).Length];
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\ValidationCommand.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public abstract class ValidationCommand(string source) : IValidationCommand {
    protected string Source { get; } = source;

    public virtual Result Validate(object? subject)
        => subject is null || ValidateAs(subject)
            ? Result.Success()
            : Result.Invalid(Source, string.Format(ValidationErrorMessage, GetErrorMessageArguments(subject)));

    public virtual Result Negate(object? subject)
        => subject is null || !ValidateAs(subject)
            ? Result.Success()
            : Result.Invalid(Source, string.Format(InvertMessage(ValidationErrorMessage), GetErrorMessageArguments(subject)));

    protected Func<object, bool> ValidateAs { get; init; } = _ => true;
    protected string ValidationErrorMessage { get; init; } = MustBeValid;
    protected Func<object?, object[]> GetErrorMessageArguments { get; init; } = _ => [];
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Commands\ValidationCommandFactory.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Commands;

public sealed class ValidationCommandFactory {
    private readonly Type _subjectType;
    private readonly string _source;

    private ValidationCommandFactory(Type subjectType, string source) {
        _subjectType = subjectType;
        _source = source;
    }

    public static ValidationCommandFactory For(Type subjectType, string source)
        => new(subjectType, source);

    public IValidationCommand Create(string command, params object?[] arguments) {
        #pragma warning disable IDE0046 // Convert to conditional expression
        // ReSharper disable once ConvertIfStatementToSwitchStatement - Better readability
        if (command == "IsNull") return new IsNullCommand(_source);
        if (command == "IsEqualTo") return new IsEqualToCommand(arguments[0]!, _source);
        if (_subjectType == typeof(int)) return CreateNumberCommand<int>(command, arguments);
        if (_subjectType == typeof(decimal)) return CreateNumberCommand<decimal>(command, arguments);
        if (_subjectType == typeof(DateTime)) return CreateDateTimeCommand(command, arguments);
        if (_subjectType == typeof(int?)) return CreateNumberCommand<int>(command, arguments);
        if (_subjectType == typeof(decimal?)) return CreateNumberCommand<decimal>(command, arguments);
        if (_subjectType == typeof(DateTime?)) return CreateDateTimeCommand(command, arguments);
        if (_subjectType == typeof(string)) return CreateStringCommand(command, arguments);
        if (_subjectType.IsAssignableTo(typeof(ICollection<int>))) return CreateCollectionCommand<int>(command, arguments);
        if (_subjectType.IsAssignableTo(typeof(ICollection<decimal>))) return CreateCollectionCommand<decimal>(command, arguments);
        if (_subjectType.IsAssignableTo(typeof(ICollection<int?>))) return CreateCollectionCommand<int>(command, arguments);
        if (_subjectType.IsAssignableTo(typeof(ICollection<decimal?>))) return CreateCollectionCommand<decimal>(command, arguments);
        if (_subjectType.IsAssignableTo(typeof(ICollection<string?>))) return CreateCollectionCommand<string>(command, arguments);
        if (_subjectType.IsAssignableTo(typeof(IDictionary<string, int>))) return CreateDictionaryCommand<string, int>(command, arguments);
        if (_subjectType.IsAssignableTo(typeof(IDictionary<string, decimal>))) return CreateDictionaryCommand<string, decimal>(command, arguments);
        if (_subjectType.IsAssignableTo(typeof(IDictionary<string, int?>))) return CreateDictionaryCommand<string, int>(command, arguments);
        if (_subjectType.IsAssignableTo(typeof(IDictionary<string, decimal?>))) return CreateDictionaryCommand<string, decimal>(command, arguments);
        if (_subjectType.IsAssignableTo(typeof(IDictionary<string, string>))) return CreateDictionaryCommand<string, string>(command, arguments);
        if (_subjectType.IsAssignableTo(typeof(IValidatable))) return CreateValidatableCommand(command);
        throw new InvalidOperationException($"Unsupported command '{command}' for type '{_subjectType.Name}'.");
        #pragma warning restore IDE0046 // Convert to conditional expression
    }

    private IsValidCommand CreateValidatableCommand(string command)
        => command switch {
            "IsValid" => new(_source),
            _ => throw new InvalidOperationException($"Unsupported command '{command}' for {_subjectType.Name}."),
           };

    private IValidationCommand CreateNumberCommand<TValue>(string command, IReadOnlyList<object?> arguments)
        where TValue : struct, IComparable<TValue> {
        return command switch {
            "IsLessThan" => new IsLessThanCommand<TValue>(GetLimitValue(), _source),
            "IsGreaterThan" => new IsGreaterThanCommand<TValue>(GetLimitValue(), _source),
            _ => throw new InvalidOperationException($"Unsupported command '{command}' for type '{_subjectType.Name}'."),
               };

        TValue GetLimitValue() => GetArgumentValue<TValue>(command, arguments, 0);
    }

    private IValidationCommand CreateDateTimeCommand(string command, IReadOnlyList<object?> arguments) {
        return command switch {
            "IsBefore" => new IsBeforeCommand(GetLimitValue(), _source),
            "IsAfter" => new IsAfterCommand(GetLimitValue(), _source),
            _ => throw new InvalidOperationException($"Unsupported command '{command}' for type '{_subjectType.Name}'."),
               };

        DateTime GetLimitValue() => GetArgumentValue<DateTime>(command, arguments, 0);
    }

    private IValidationCommand CreateStringCommand(string command, IReadOnlyList<object?> arguments) {
        return command switch {
            "IsEmpty" => new IsEmptyCommand(_source),
            "IsEmptyOrWhiteSpace" => new IsEmptyOrWhiteSpaceCommand(_source),
            "LengthIsAtLeast" => new LengthIsAtLeastCommand(GetLengthValue(), _source),
            "LengthIsAtMost" => new LengthIsAtMostCommand(GetLengthValue(), _source),
            "LengthIs" => new LengthIsCommand(GetLengthValue(), _source),
            "Contains" => new ContainsCommand(GetCandidateValue(), _source),
            "IsIn" => new IsInCommand<string>(GetListValue(), _source),
            "IsEmail" => new IsEmailCommand(_source),
            "IsValidPassword" => new IsValidPasswordCommand(GetPolicy(), _source),
            _ => throw new InvalidOperationException($"Unsupported command '{command}' for type '{_subjectType.Name}'."),
               };

        int GetLengthValue() => GetArgumentValue<int>(command, arguments, 0);
        string GetCandidateValue() => GetArgumentValue<string>(command, arguments, 0);
        string?[] GetListValue() => [.. GetArgumentValues<string>(command, arguments)];
        IValidatable GetPolicy() => GetArgumentValue<IValidatable>(command, arguments, 0);
    }

    private IValidationCommand CreateCollectionCommand<TItem>(string command, IReadOnlyList<object?> arguments) {
        return command switch {
            "IsEmpty" => new IsEmptyCommand<TItem>(_source),
            "Contains" => new ContainsCommand<TItem>(GetItemValue(), _source),
            "HasAtLeast" => new HasAtLeastCommand<TItem>(GetCountValue(), _source),
            "HasAtMost" => new HasAtMostCommand<TItem>(GetCountValue(), _source),
            "Has" => new HasCommand<TItem>(GetCountValue(), _source),
            _ => throw new InvalidOperationException($"Unsupported command '{command}' for type '{_subjectType.Name}'."),
               };

        int GetCountValue() => GetArgumentValue<int>(command, arguments, 0);
        TItem? GetItemValue() => GetArgumentValueOrDefault<TItem>(command, arguments, 0);
    }

    private IValidationCommand CreateDictionaryCommand<TKey, TValue>(string command, IReadOnlyList<object?> arguments)
        where TKey : notnull {
        return command switch {
            "IsEmpty" => new IsEmptyCommand<KeyValuePair<TKey, TValue?>>(_source),
            "HasAtLeast" => new HasAtLeastCommand<KeyValuePair<TKey, TValue?>>(GetCountValue(), _source),
            "HasAtMost" => new HasAtMostCommand<KeyValuePair<TKey, TValue?>>(GetCountValue(), _source),
            "Has" => new HasCommand<KeyValuePair<TKey, TValue?>>(GetCountValue(), _source),
            "ContainsKey" => new ContainsKeyCommand<TKey, TValue?>(GetKeyValue(), _source),
            "ContainsValue" => new ContainsValueCommand<TKey, TValue?>(GetValueValue(), _source),
            _ => throw new InvalidOperationException($"Unsupported command '{command}' for type '{_subjectType.Name}'."),
               };

        int GetCountValue() => GetArgumentValueOrDefault<int>(command, arguments, 0);
        TKey GetKeyValue() => GetArgumentValue<TKey>(command, arguments, 0);
        TValue? GetValueValue() => GetArgumentValueOrDefault<TValue>(command, arguments, 0);
    }

    [return: NotNull]
    private static TArgument GetArgumentValue<TArgument>(string methodName, IReadOnlyList<object?> arguments, uint argumentIndex, [CallerArgumentExpression(nameof(arguments))] string? paramName = null)
        => argumentIndex >= arguments.Count
            ? throw new ArgumentException($"Invalid number of arguments for '{methodName}'. Missing argument {argumentIndex}.", paramName)
            : arguments[(int)argumentIndex] is TArgument value
                    ? value
                    : throw new ArgumentException($"Invalid type of {paramName}[{argumentIndex}] of '{methodName}'. Expected: {typeof(TArgument).Name}. Found: {arguments[(int)argumentIndex]!.GetType().Name}.", $"{paramName}[{argumentIndex}]");

    private static TArgument? GetArgumentValueOrDefault<TArgument>(string methodName, IReadOnlyList<object?> arguments, uint argumentIndex, [CallerArgumentExpression(nameof(arguments))] string? paramName = null)
        => argumentIndex >= arguments.Count
            ? throw new ArgumentException($"Invalid number of arguments for '{methodName}'. Missing argument {argumentIndex}.", paramName)
            : arguments[(int)argumentIndex] switch {
                null => default,
                TArgument value => value,
                _ => throw new ArgumentException($"Invalid type of {paramName}[{argumentIndex}] of '{methodName}'. Expected: {typeof(TArgument).Name}. Found: {arguments[(int)argumentIndex]!.GetType().Name}.", $"{paramName}[{argumentIndex}]"),
            };

    private static TArgument?[] GetArgumentValues<TArgument>(string methodName, IReadOnlyList<object?> arguments, [CallerArgumentExpression(nameof(arguments))] string? paramName = null) {
        var list = IsNotEmpty(IsNotNull(arguments, paramName), paramName);
        for (var index = 0; index < list.Count; index++) GetArgumentValueOrDefault<TArgument>(methodName, arguments, (uint)index, paramName);

        return list.Select(i => i is null ? default : (TArgument)i).ToArray();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Constants\ErrorMessages.cs 
﻿namespace System.Constants;

public static class ErrorMessages {
    public const string MustBeAfter = "Value must be after {0}. Found: {1}.";
    public const string MustBeBefore = "Value must be before {0}. Found: {1}.";
    public const string MustBeEmpty = "Value must be empty.";
    public const string MustBeEmptyOrWhiteSpace = "Value must be empty or white space.";
    public const string MustBeEqualTo = "Value must be equal to {0}. Found: {1}.";
    public const string MustBeGraterThan = "Value must be greater than {0}. Found: {1}.";
    public const string MustBeIn = "Value must be one of these: '{0}'. Found: {1}.";
    public const string MustBeLessThan = "Value must be less than {0}. Found: {1}.";
    public const string MustBeNull = "Value must be null.";
    public const string MustBeNullOrEmpty = "Value must be null or empty.";
    public const string MustBeNullOrWhiteSpace = "Value must be null or white space.";
    public const string MustContain = "Value must contain '{0}'.";
    public const string MustContainValue = "Value must contain the value '{0}'.";
    public const string MustContainKey = "Value must contain the key '{0}'.";
    public const string MustContainNull = "Value must contain null item(s).";
    public const string MustContainNullOrEmpty = "Value must contain null or empty string(s).";
    public const string MustContainNullOrWhiteSpace = "Value must contain null or white space string(s).";
    public const string MustHaveACountOf = "Value count must be {0}. Found: {1}.";
    public const string MustHaveALengthOf = "Value length must be {0}. Found: {1}.";
    public const string MustHaveAMaximumCountOf = "Value maximum count must be {0}. Found: {1}.";
    public const string MustHaveAMaximumLengthOf = "Value maximum length must be {0}. Found: {1}.";
    public const string MustHaveAMinimumCountOf = "Value minimum count must be {0}. Found: {1}.";
    public const string MustHaveAMinimumLengthOf = "Value minimum length must be {0}. Found: {1}.";
    public const string MustBeValid = "Value must be valid.";
    public const string MustBeAValidEmail = "Value must be a valid email.";
    public const string MustBeAValidPassword = "Value must be a valid password.";
    public const string MustBeOfType = "Value must be of type '{0}'. Found: '{1}'.";

    public static readonly string CannotBeAfter = InvertMessage(MustBeAfter);
    public static readonly string CannotBeBefore = InvertMessage(MustBeBefore);
    public static readonly string CannotBeEmpty = InvertMessage(MustBeEmpty);
    public static readonly string CannotBeEmptyOrWhiteSpace = InvertMessage(MustBeEmptyOrWhiteSpace);
    public static readonly string CannotBeEqualTo = InvertMessage(MustBeEqualTo);
    public static readonly string CannotBeGraterThan = InvertMessage(MustBeGraterThan);
    public static readonly string CannotBeIn = InvertMessage(MustBeIn);
    public static readonly string CannotBeLessThan = InvertMessage(MustBeLessThan);
    public static readonly string CannotBeNull = InvertMessage(MustBeNull);
    public static readonly string CannotBeNullOrEmpty = InvertMessage(MustBeNullOrEmpty);
    public static readonly string CannotBeNullOrWhiteSpace = InvertMessage(MustBeNullOrWhiteSpace);
    public static readonly string CannotContain = InvertMessage(MustContain);
    public static readonly string CannotContainValue = InvertMessage(MustContainValue);
    public static readonly string CannotContainKey = InvertMessage(MustContainKey);
    public static readonly string CannotContainNull = InvertMessage(MustContainNull);
    public static readonly string CannotContainNullOrEmpty = InvertMessage(MustContainNullOrEmpty);
    public static readonly string CannotContainNullOrWhiteSpace = InvertMessage(MustContainNullOrWhiteSpace);
    public static readonly string CannotHaveCount = InvertMessage(MustHaveACountOf);
    public static readonly string CannotHaveLength = InvertMessage(MustHaveALengthOf);
    public static readonly string CannotHaveMaximumCount = InvertMessage(MustHaveAMaximumCountOf);
    public static readonly string CannotHaveMaximumLength = InvertMessage(MustHaveAMaximumLengthOf);
    public static readonly string CannotHaveMinimumCount = InvertMessage(MustHaveAMinimumCountOf);
    public static readonly string CannotHaveMinimumLength = InvertMessage(MustHaveAMinimumLengthOf);
    public static readonly string CannotBeOfType = InvertMessage(MustBeOfType);

    public static string InvertMessage(string message)
        => message switch {
            _ when message.Contains(" cannot ") => message.Replace(" cannot ", " must "),
            _ when message.Contains(" must ") => message.Replace(" must ", " cannot "),
            _ when message.Contains(" is not ") => message.Replace(" is not ", " is "),
            _ when message.Contains(" is ") => message.Replace(" is ", " is not "),
            _ => message,
        };
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder\Extensions\ValidationExtensions.cs 
﻿namespace DotNetToolbox.ValidationBuilder.Extensions;

public static class ValidationExtensions {
    public static IConnector<ObjectValidator> IsRequired(this object? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: false, subject, source!);
    public static IConnector<ObjectValidator> IsOptional(this object? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: true, subject, source!);

    public static IConnector<ValidatableValidator> IsOptional(this IValidatable? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: true, subject, source!);
    public static IConnector<ValidatableValidator> IsRequired(this IValidatable? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: false, subject, source!);

    public static IConnector<TypeValidator> Is(this Type? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(subject, source!);

    public static IConnector<IntegerValidator> Is(this int subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: false, subject, source!);
    public static IConnector<IntegerValidator> IsOptional(this int? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: true, subject, source!);
    public static IConnector<IntegerValidator> IsRequired(this int? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: false, subject, source!);

    public static IConnector<DecimalValidator> Is(this decimal subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: false, subject, source!);
    public static IConnector<DecimalValidator> IsOptional(this decimal? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: true, subject, source!);
    public static IConnector<DecimalValidator> IsRequired(this decimal? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: false, subject, source!);

    public static IConnector<DateTimeValidator> Is(this DateTime subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: false, subject, source!);
    public static IConnector<DateTimeValidator> IsOptional(this DateTime? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: true, subject, source!);
    public static IConnector<DateTimeValidator> IsRequired(this DateTime? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: false, subject, source!);

    public static IConnector<StringValidator> IsOptional(this string? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: true, subject, source!);
    public static IConnector<StringValidator> IsRequired(this string? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(allowNull: false, subject, source!);

    public static IConnector<CollectionValidator<TItem>> Is<TItem>(this ICollection<TItem?> subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(subject, source!);
    public static IConnector<CollectionValidator<TItem>> CheckIfEach<TItem>(this ICollection<TItem?> subject, Func<TItem?, ITerminator> itemIsValid, [CallerArgumentExpression(nameof(subject))] string? source = null)
        => Create(subject, source!, itemIsValid);

    public static IConnector<DictionaryValidator<TKey, TValue>> Is<TKey, TValue>(this IDictionary<TKey, TValue?>? subject, [CallerArgumentExpression(nameof(subject))] string? source = null)
        where TKey : notnull
        => Create(subject, source!);
    public static IConnector<DictionaryValidator<TKey, TValue>> CheckIfEach<TKey, TValue>(this IDictionary<TKey, TValue?>? subject, Func<TValue?, ITerminator> validate, [CallerArgumentExpression(nameof(subject))] string? source = null)
        where TKey : notnull
        => Create(subject, source!, validate);
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\CollectionValidatorsTests.cs 
namespace DotNetToolbox.ValidationBuilder;

public class CollectionValidatorsTests {
    public record TestObject : IValidatable {
        public required ICollection<int> Numbers { get; init; } = Array.Empty<int>();
        public required ICollection<(string Name, int Age)> Names { get; init; } = Array.Empty<(string Name, int Age)>();
        public ICollection<string> Empty { get; } = Array.Empty<string>();

        public Result Validate(IDictionary<string, object?>? context = null) {
            var result = Success();
            result += Numbers.Is()
                .And().IsNotEmpty()
                .And().HasAtLeast(2)
                .And().HasAtMost(4)
                .And().Has(3)
                .And().Contains(5)
                .And().Each(item => item.Is().And().IsGreaterThan(0)).Result;
            result += Names.CheckIfEach(value => value.Name.IsRequired()).Result;
            result += Empty!.Is().And().IsEmpty().Result;
            return result;
        }
    }

    private class TestData : TheoryData<TestObject, int> {
        public TestData() {
            Add(new() { Numbers = [ 1, 3, 5], Names = new[] { ("Name", 30) } }, 0);
            Add(new() { Numbers = [], Names = new[] { ("Name", 30), default! } }, 5);
            Add(new() { Numbers = [ 0, 5, 10, 13, 20], Names = new[] { ("Name", 30) } }, 3);
            Add(new() { Numbers = null!, Names = null! }, 2);
        }
    }

    [Theory]
    [ClassData(typeof(TestData))]
    public void Validate_Validates(TestObject subject, int errorCount) {
        // Act
        var result = subject.Validate();

        // Assert
        result.Errors.Should().HaveCount(errorCount);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\ConnectorTests.cs 
namespace DotNetToolbox.ValidationBuilder;

public class ConnectorTests {
    [Theory]
    [InlineData("value", 0)]
    [InlineData("error", 1)]
    [InlineData("val", 1)]
    [InlineData("err", 2)]
    public void And_AccumulatesErrors(string value, int expectedErrorCount) {
        // Arrange
        var validator = CreateValidatorFor(value);

        // Act
        var result = validator.LengthIs(5).And().Contains("val").Result;

        // Assert
        result.Errors.Should().HaveCount(expectedErrorCount);
    }

    [Theory]
    [InlineData("value", 0)]
    [InlineData("error", 0)]
    [InlineData("val", 0)]
    [InlineData("err", 2)]
    public void Or_AccumulatesErrors(string value, int expectedErrorCount) {
        // Arrange
        var validator = CreateValidatorFor(value);

        // Act
        var result = validator.LengthIs(5).Or().Contains("val").Result;

        // Assert
        result.Errors.Should().HaveCount(expectedErrorCount);
    }

    [Theory]
    [InlineData("value", 1)]
    [InlineData("error", 0)]
    [InlineData("val", 2)]
    [InlineData("err", 1)]
    public void AndNot_AccumulatesErrors(string value, int expectedErrorCount) {
        // Arrange
        var validator = CreateValidatorFor(value);

        // Act
        var result = validator.LengthIs(5).AndNot().Contains("val").Result;

        // Assert
        result.Errors.Should().HaveCount(expectedErrorCount);
    }

    [Theory]
    [InlineData("value", 0)]
    [InlineData("error", 0)]
    [InlineData("val", 2)]
    [InlineData("err", 0)]
    public void OrNot_AccumulatesErrors(string value, int expectedErrorCount) {
        // Arrange
        var validator = CreateValidatorFor(value);

        // Act
        var result = validator.LengthIs(5).OrNot().Contains("val").Result;

        // Assert
        result.Errors.Should().HaveCount(expectedErrorCount);
    }

    [Theory]
    [InlineData("value", 0)]
    [InlineData("error", 1)]
    [InlineData("val", 1)]
    [InlineData("err", 2)]
    public void AndClause_AccumulatesErrors(string value, int expectedErrorCount) {
        // Arrange
        var validator = CreateValidatorFor(value);

        // Act
        var result = validator.LengthIs(5).And(i => i.Contains("val")).Result;

        // Assert
        result.Errors.Should().HaveCount(expectedErrorCount);
    }

    [Theory]
    [InlineData("value", 0)]
    [InlineData("error", 0)]
    [InlineData("val", 0)]
    [InlineData("err", 2)]
    public void OrClause_AccumulatesErrors(string value, int expectedErrorCount) {
        // Arrange
        var validator = CreateValidatorFor(value);

        // Act
        var result = validator.LengthIs(5).Or(i => i.Contains("val")).Result;

        // Assert
        result.Errors.Should().HaveCount(expectedErrorCount);
    }

    [Theory]
    [InlineData("value", 1)]
    [InlineData("error", 0)]
    [InlineData("val", 2)]
    [InlineData("err", 1)]
    public void AndNotClause_AccumulatesErrors(string value, int expectedErrorCount) {
        // Arrange
        var validator = CreateValidatorFor(value);

        // Act
        var result = validator.LengthIs(5).AndNot(i => i.Contains("val")).Result;

        // Assert
        result.Errors.Should().HaveCount(expectedErrorCount);
    }

    [Theory]
    [InlineData("value", 0)]
    [InlineData("error", 0)]
    [InlineData("val", 2)]
    [InlineData("err", 0)]
    public void OrNotClause_AccumulatesErrors(string value, int expectedErrorCount) {
        // Arrange
        var validator = CreateValidatorFor(value);

        // Act
        var result = validator.LengthIs(5).OrNot(i => i.Contains("val")).Result;

        // Assert
        result.Errors.Should().HaveCount(expectedErrorCount);
    }

    private static StringValidator CreateValidatorFor(string value, ValidatorMode mode = ValidatorMode.And)
        => new(value, "Source", mode);
} 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\DateTimeValidatorsTests.cs 
namespace DotNetToolbox.ValidationBuilder;

public class DateTimeValidatorsTests {
    private static readonly DateTime _baseDate = DateTime.Parse("2023-04-01 12:34:56.789");

    public record TestObject : IValidatable {
        public DateTime NotNull { get; init; }
        public DateTime? Nullable { get; init; }
        public DateTime? Required { get; init; }

        public Result Validate(IDictionary<string, object?>? context = null) {
            var result = Success();
            result += NotNull.Is().And().IsAfter(_baseDate).And().IsBefore(_baseDate.AddDays(1)).Result;
            result += Nullable.IsOptional().And().IsAfter(_baseDate).And().IsBefore(_baseDate.AddDays(1)).Result;
            result += Required.IsRequired().And().StartsOn(_baseDate).And().EndsOn(_baseDate.AddDays(1)).Result;
            return result;
        }
    }

    private class TestData : TheoryData<TestObject, bool, int> {
        public TestData() {
            Add(new() { NotNull = _baseDate.AddSeconds(1), Nullable = _baseDate.AddSeconds(1), Required = _baseDate.AddSeconds(1) }, true, 0);
            Add(new() { NotNull = _baseDate, Nullable = null, Required = null }, false, 2);
            Add(new() { NotNull = _baseDate.AddDays(-1), Nullable = _baseDate, Required = _baseDate.AddDays(-1) }, false, 3);
            Add(new() { NotNull = _baseDate.AddDays(3), Nullable = _baseDate, Required = _baseDate.AddDays(3) }, false, 3);
        }
    }

    [Theory]
    [ClassData(typeof(TestData))]
    public void Validate_Validates(TestObject subject, bool isSuccess, int errorCount) {
        // Act
        var result = subject.Validate();

        // Assert
        result.IsSuccess.Should().Be(isSuccess);
        result.Errors.Should().HaveCount(errorCount);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\DecimalValidatorsTests.cs 
namespace DotNetToolbox.ValidationBuilder;

public class DecimalValidatorsTests {
    public record TestObject : IValidatable {
        public decimal NonNull { get; init; }
        public decimal? Nullable { get; init; }
        public decimal? Required { get; init; }

        public Result Validate(IDictionary<string, object?>? context = null) {
            var result = Success();
            result += NonNull.Is().Result;
            result += Nullable.IsOptional().And().IsGreaterThan(10).And().IsLessThan(20).And().IsEqualTo(15).Result;
            result += Required.IsRequired().And().MinimumIs(10).And().MaximumIs(20).Result;
            return result;
        }
    }

    private class TestData : TheoryData<TestObject, bool, int> {
        public TestData() {
            Add(new() { Nullable = 15, Required = 15 }, true, 0);
            Add(new() { Nullable = null, Required = null }, false, 1);
            Add(new() { Nullable = 5, Required = 5 }, false, 3);
            Add(new() { Nullable = 25, Required = 25 }, false, 3);
        }
    }

    [Theory]
    [ClassData(typeof(TestData))]
    public void Validate_Validates(TestObject subject, bool isSuccess, int errorCount) {
        // Act
        var result = subject.Validate();

        // Assert
        result.IsSuccess.Should().Be(isSuccess);
        result.Errors.Should().HaveCount(errorCount);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\DictionaryValidatorsTests.cs 
namespace DotNetToolbox.ValidationBuilder;

public class DictionaryValidatorsTests {
    public record TestObject : IValidatable {
        public required IDictionary<string, int> Numbers { get; init; } = new Dictionary<string, int>();
        public required IDictionary<string, string> Names { get; init; } = new Dictionary<string, string>();
        public IDictionary<string, string> Empty { get; } = new Dictionary<string, string>();

        public Result Validate(IDictionary<string, object?>? context = null) {
            var result = Success();
            result += Numbers.Is()
                .And().IsNotEmpty()
                .And().HasAtLeast(2)
                .And().HasAtMost(4)
                .And().Has(3)
                .And().ContainsKey("Five")
                .And().Each(item => item.Is().And().IsGreaterThan(0)).Result;
            result += Names!.CheckIfEach(value => value.IsRequired()).Result;
            result += Empty!.Is().And().IsEmpty().Result;
            return result;
        }
    }

    private class TestData : TheoryData<TestObject, bool, int> {
        public TestData() {
            Add(new() { Numbers = new Dictionary<string, int> { ["One"] = 1, ["Three"] = 3, ["Five"] = 5 }, Names = new Dictionary<string, string> { ["Some"] = "Name" } }, true, 0);
            Add(new() { Numbers = new Dictionary<string, int>(), Names = new Dictionary<string, string> { ["Name"] = default! } }, false, 5);
            Add(new() { Numbers = new Dictionary<string, int> { ["One"] = 1, ["Two"] = default!, ["Three"] = 3, ["Four"] = 4, ["Nine"] = 9 }, Names = new Dictionary<string, string> { ["Some"] = "Name" } }, false, 4);
            Add(new() { Numbers = null!, Names = null! }, false, 2);
        }
    }

    [Theory]
    [ClassData(typeof(TestData))]
    public void Validate_Validates(TestObject subject, bool isSuccess, int errorCount) {
        // Act
        var result = subject.Validate();

        // Assert
        result.IsSuccess.Should().Be(isSuccess);
        result.Errors.Should().HaveCount(errorCount);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\GlobalUsings.cs 
global using DotNetToolbox.Results;
global using DotNetToolbox.ValidationBuilder.Extensions;

global using FluentAssertions;

global using NSubstitute;

global using Xunit;

global using static DotNetToolbox.Results.Result;
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\IntegerValidatorsTests.cs 
namespace DotNetToolbox.ValidationBuilder;

public class IntegerValidatorsTests {
    public record TestObject : IValidatable {
        public int NonNull { get; init; }
        public int? Nullable { get; init; }
        public int? Required { get; init; }

        public Result Validate(IDictionary<string, object?>? context = null) {
            var result = Success();
            result += NonNull.Is().Result;
            result += Nullable.IsOptional().And().IsGreaterThan(10).And().IsLessThan(20).And().IsEqualTo(15).Result;
            result += Required.IsRequired().And().MinimumIs(10).And().MaximumIs(20).Result;
            return result;
        }
    }

    private class TestData : TheoryData<TestObject, int> {
        public TestData() {
            Add(new() { Nullable = 15, Required = 15 }, 0);
            Add(new() { Nullable = null, Required = null }, 1);
            Add(new() { Nullable = 5, Required = 5 }, 3);
            Add(new() { Nullable = 25, Required = 25 }, 3);
        }
    }

    [Theory]
    [ClassData(typeof(TestData))]
    public void Validate_Validates(TestObject subject, int errorCount) {
        // Act
        var result = subject.Validate();

        // Assert
        result.Errors.Should().HaveCount(errorCount);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\StringValidatorsTests.cs 
namespace DotNetToolbox.ValidationBuilder;

public class StringValidatorsTests {
    public record TestObject : IValidatable {
        private readonly IValidatable _fakePolicy = Substitute.For<IValidatable>();

        public TestObject() {
            _fakePolicy.Validate(Arg.Any<Dictionary<string, object?>>()).Returns(x => {
                var result = Success();
                if (x[0] is not "Invalid") return result;

                result += new ValidationError("Some error.", "Password");
                result += new ValidationError("Password", "Some other error.");
                return result;
            });
        }

        public string? Name { get; init; }
        public string? Email { get; init; }
        public string? Password { get; init; }
        public string Empty { get; } = string.Empty;

        public Result Validate(IDictionary<string, object?>? context = null) {
            var result = Success();
            result += Name.IsRequired()
                          .And().IsNotEmptyOrWhiteSpace()
                          .And().LengthIsAtLeast(3)
                          .And().Contains("ext")
                          .And().LengthIsAtMost(10)
                          .And().LengthIs(5)
                          .And().IsIn("Text1", "Text2", "Text3").Result;
            result += Email.IsRequired()
                           .And().IsNotEmpty()
                           .And().IsEmail().Result;
            result += Password.IsOptional()
                           .And().IsNotEmpty()
                           .And().IsValidPassword(_fakePolicy).Result;
            result += Empty.IsRequired().And().IsEmpty().And().IsEmptyOrWhiteSpace().Result;
            return result;
        }
    }

    private class TestData : TheoryData<TestObject, int> {
        public TestData() {
            Add(new() { Name = "Text1", Email = "some@email.com" }, 0);
            Add(new() { Name = "Text1", Email = "" }, 2);
            Add(new() { Name = "Text1", Email = "NotEmail" }, 1);
            Add(new() { Name = null, Password = "AnyTh1n6!" }, 2);
            Add(new() { Name = "" }, 6);
            Add(new() { Name = "  " }, 6);
            Add(new() { Name = "12" }, 5);
            Add(new() { Name = "12345678901" }, 5);
            Add(new() { Name = "Other", Password = "Invalid" }, 3);
        }
    }

    [Theory]
    [ClassData(typeof(TestData))]
    public void Validate_Validates(TestObject subject, int errorCount) {
        // Act
        var result = subject.Validate();

        // Assert
        result.Errors.Should().HaveCount(errorCount);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\TypeValidatorsTests.cs 
namespace DotNetToolbox.ValidationBuilder;

public class TypeValidatorsTests {
    public record TestObject : IValidatable {
        public Type? Type { get; init; }

        public Result Validate(IDictionary<string, object?>? context = null) {
            var result = Success();
            result += Type.Is()
                .And().IsEqualTo<string>().Result;
            return result;
        }
    }

    private class TestData : TheoryData<TestObject, int> {
        public TestData() {
            Add(new() { Type = typeof(string) }, 0);
            Add(new() { Type = null }, 1);
            Add(new() { Type = typeof(int) }, 1);
        }
    }

    [Theory]
    [ClassData(typeof(TestData))]
    public void Validate_Validates(TestObject subject, int errorCount) {
        // Act
        var result = subject.Validate();

        // Assert
        result.Errors.Should().HaveCount(errorCount);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\ValidatableValidatorsTests.cs 
namespace DotNetToolbox.ValidationBuilder;

public class ValidatableValidatorsTests {
    public record ChildObject : IValidatable {
        public required string Name { get; init; }

        public Result Validate(IDictionary<string, object?>? context = null) {
            var result = Success();
            result += Name.IsRequired()
                .And().LengthIs(5).Result;
            return result;
        }
    }

    public record TestObject : IValidatable {
        public required ChildObject Child { get; init; }

        public Result Validate(IDictionary<string, object?>? context = null) {
            var result = Success();
            result += Child.IsRequired()
                .And().IsValid().Result;
            return result;
        }
    }

    private class TestData : TheoryData<TestObject, bool, int> {
        public TestData() {
            Add(new() { Child = new() { Name = "Mario" } }, true, 0);
            Add(new() { Child = new() { Name = default! } }, false, 1);
            Add(new() { Child = default! }, false, 1);
        }
    }

    [Theory]
    [ClassData(typeof(TestData))]
    public void Validate_Validates(TestObject subject, bool isSuccess, int errorCount) {
        // Act
        var result = subject.Validate();

        // Assert
        result.IsSuccess.Should().Be(isSuccess);
        result.Errors.Should().HaveCount(errorCount);
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\ValidatorsTests.cs 
namespace DotNetToolbox.ValidationBuilder;

public class ValidatorsTests {
    public class TestObject(long subject, string source, ValidatorMode mode = ValidatorMode.And) : Validator<long>(subject, source, mode);

    [Fact]
    public void Constructor_CreatesBuilder() {
        // Act
        var result = new TestObject(100, "SomeSubject");

        // Assert
        result.Mode.Should().Be(ValidatorMode.And);
        result.Result.IsSuccess.Should().BeTrue();
    }

    [Fact]
    public void Constructor_WithModeAndPreviousResult_CreatesBuilder() {
        // Act
        var result = new TestObject(100, "SomeSubject", ValidatorMode.Or);

        // Assert
        result.Mode.Should().Be(ValidatorMode.Or);
        result.Result.IsSuccess.Should().BeTrue();
    }
}
 
---------------------------------------------------------------------------------------- 
P:\Projects\DotNetToolbox\Source\ValidationBuilder.UnitTests\Commands\ValidationCommandFactoryTests.cs 
namespace DotNetToolbox.ValidationBuilder.Commands;

public class ValidationCommandFactoryTests {
    private static object?[] Args(params object?[] args) => args;

    [Theory]
    [InlineData(typeof(decimal))]
    [InlineData(typeof(int))]
    [InlineData(typeof(string))]
    [InlineData(typeof(DateTime))]
    [InlineData(typeof(IValidatable))]
    [InlineData(typeof(List<int>))]
    [InlineData(typeof(List<string>))]
    [InlineData(typeof(Dictionary<string, int>))]
    [InlineData(typeof(Dictionary<string, decimal>))]
    [InlineData(typeof(Dictionary<string, string>))]
    [InlineData(typeof(Dictionary<double, double>))]
    public void Create_ForUnsupportedValidator_Throws(Type subjectType) {
        //Act
        var action = () => ValidationCommandFactory.For(subjectType, "Attribute").Create("Anything", []);

        //Assert
        action.Should().Throw<InvalidOperationException>();
    }

    private const string _string = "AbcDef";
    private const int _integer = 42;
    private const decimal _decimal = 42.0m;
    private static readonly DateTime _dateTime = DateTime.Parse("2020-01-01 10:10:10.12345");
    private static readonly Type _type = typeof(string);
    private static readonly List<int> _integers = [1, 2, 3];
    private static readonly List<decimal> _decimals = [1.0m, 2.0m, 3.0m];
    private static readonly List<int?> _nullableIntegers = [1, 2, 3];
    private static readonly List<decimal?> _nullableDecimals = [1.0m, 2.0m, 3.0m];
    private static readonly List<string> _strings = ["A", _string, "C"];
    private static readonly Dictionary<string, int> _strings2Integers = new() { ["A"] = 1, ["B"] = 2, ["C"] = 3 };
    private static readonly Dictionary<string, decimal> _strings2Decimals = new() { ["A"] = 1m, ["B"] = 2m, ["C"] = 3m };
    private static readonly Dictionary<string, int?> _strings2NullableIntegers = new() { ["A"] = 1, ["B"] = 2, ["C"] = 3 };
    private static readonly Dictionary<string, decimal?> _strings2NullableDecimals = new() { ["A"] = 1m, ["B"] = 2m, ["C"] = 3m };
    private static readonly Dictionary<string, string> _strings2Strings = new() { ["A"] = "1", ["B"] = "2", ["C"] = "3" };

    private class TestDataForValidateSuccess : TheoryData<string, object?[], object?, Type> {
        public TestDataForValidateSuccess() {
            Add("Contains", Args(_integers[1]), _integers, _integers.GetType());
            Add("Contains", Args(_string[1..^1]), _string, _string.GetType());
            Add("ContainsKey", Args(_strings2Strings.Keys.First()), _strings2Strings, _strings2Strings.GetType());
            Add("ContainsValue", Args(_strings2Integers.Values.Last()), _strings2Integers, _strings2Integers.GetType());
            Add("Has", Args(_integers.Count), _integers, _integers.GetType());
            Add("Has", Args(_decimals.Count), _decimals, _decimals.GetType());
            Add("Has", Args(_nullableIntegers.Count), _integers, _nullableIntegers.GetType());
            Add("Has", Args(_nullableDecimals.Count), _decimals, _nullableDecimals.GetType());
            Add("Has", Args(_strings.Count), _strings, _strings.GetType());
            Add("Has", Args(_strings2Integers.Count), _strings2Integers, _strings2Integers.GetType());
            Add("Has", Args(_strings2Decimals.Count), _strings2Decimals, _strings2Decimals.GetType());
            Add("Has", Args(_strings2NullableIntegers.Count), _strings2Integers, _strings2NullableIntegers.GetType());
            Add("Has", Args(_strings2NullableDecimals.Count), _strings2Decimals, _strings2NullableDecimals.GetType());
            Add("Has", Args(_strings2Strings.Count), _strings2Strings, _strings2Strings.GetType());
            Add("HasAtLeast", Args(_strings.Count), _strings, _strings.GetType());
            Add("HasAtLeast", Args(_strings2Strings.Count), _strings2Strings, _strings2Strings.GetType());
            Add("HasAtMost", Args(_strings.Count), _strings, _strings.GetType());
            Add("HasAtMost", Args(_strings2Strings.Count), _strings2Strings, _strings2Strings.GetType());
            Add("IsAfter", Args(_dateTime), _dateTime.AddSeconds(1), _dateTime.GetType());
            Add("IsBefore", Args(_dateTime), _dateTime.AddSeconds(-1), _dateTime.GetType());
            Add("IsEmpty", Args(), _integers.Where(_ => false).ToList(), _integers.GetType());
            Add("IsEmpty", Args(), _strings2Integers.Where(_ => false).ToDictionary(k => k.Key, v => v.Value), _strings2Integers.GetType());
            Add("IsEqualTo", Args(_dateTime), _dateTime, _dateTime.GetType());
            Add("IsEqualTo", Args(_decimal), _decimal, _decimal.GetType());
            Add("IsEqualTo", Args(_integer), _integer, _integer.GetType());
            Add("IsEqualTo", Args(_integers), new List<int> { 1, 3, 2 }, _integers.GetType());
            Add("IsEqualTo", Args(_string), _string, _string.GetType());
            Add("IsEqualTo", Args(_strings), _strings, _strings.GetType());
            Add("IsEqualTo", Args(_type), _type, typeof(Type));
            Add("IsGreaterThan", Args(_decimal), _decimal + 0.01m, _decimal.GetType());
            Add("IsGreaterThan", Args(_integer), _integer + 1, _integer.GetType());
            Add("IsIn", Args(_strings.OfType<object?>().ToArray()), _string, _string.GetType());
            Add("IsLessThan", Args(_decimal), _decimal - 0.01m, _decimal.GetType());
            Add("IsLessThan", Args(_integer), _integer - 1, _integer.GetType());
            Add("IsNull", Args(), default(string), typeof(string));
            Add("LengthIs", Args(_string.Length), _string, _string.GetType());
            Add("LengthIsAtLeast", Args(_string.Length), _string, _string.GetType());
            Add("LengthIsAtMost", Args(_string.Length), _string, _string.GetType());
        }
    }

    [Theory]
    [ClassData(typeof(TestDataForValidateSuccess))]
    public void Validate_WithValidSubject_ReturnsSuccess(string validatorName, object?[] args, object? validValue, Type valueType) {
        var validator = ValidationCommandFactory.For(valueType, "Attribute").Create(validatorName, args);
        var validResult = validator.Validate(validValue);

        validResult.IsSuccess.Should().BeTrue();
    }

    private class TestDataForValidateFailure : TheoryData<string, object?[], object?, Type> {
        public TestDataForValidateFailure() {
            Add("IsNull", Args(), "NotNull", typeof(string));
            Add("IsEmpty", Args(), _integers, _integers.GetType());
            Add("IsEmpty", Args(), _strings2Integers, _strings2Integers.GetType());
            Add("Contains", Args("Xyz"), _string, _string.GetType());
            Add("Contains", Args(13), _integers, _integers.GetType());
            Add("ContainsKey", Args("Nope"), _strings2Strings, _strings2Strings.GetType());
            Add("ContainsValue", Args(13), _strings2Integers, _strings2Integers.GetType());
            Add("Has", Args(99), _integers, _integers.GetType());
            Add("Has", Args(99), _strings, _strings.GetType());
            Add("Has", Args(99), _strings2Decimals, _strings2Decimals.GetType());
            Add("Has", Args(99), _strings2Integers, _strings2Integers.GetType());
            Add("Has", Args(99), _strings2Strings, _strings2Strings.GetType());
            Add("IsAfter", Args(_dateTime), _dateTime.AddSeconds(-1), _dateTime.GetType());
            Add("IsBefore", Args(_dateTime), _dateTime.AddSeconds(1), _dateTime.GetType());
            Add("IsEqualTo", Args(_integer), _integers, _integers.GetType());
            Add("IsEqualTo", Args(_integers), _integer, _integer.GetType());
            Add("IsEqualTo", Args(_integers), new List<int> { 1, 2 }, _integers.GetType());
            Add("IsEqualTo", Args(_integers), new List<int> { 1, 2, 4 }, _integers.GetType());
            Add("IsEqualTo", Args(_integers), new List<int> { 1, 2, 3, 3 }, _integers.GetType());
            Add("IsEqualTo", Args(new List<int> { 1, 3, 2, 2 }), new List<int> { 1, 2, 3, 3 }, _integers.GetType());
            Add("IsEqualTo", Args(_integers), new List<string> { "1", "2", "2" }, _integers.GetType());
            Add("IsEqualTo", Args(_string), "Nope", _string.GetType());
            Add("IsEqualTo", Args(_integer), 13, _integer.GetType());
            Add("IsEqualTo", Args(_decimal), 13.01m, _decimal.GetType());
            Add("IsEqualTo", Args(_dateTime), _dateTime.AddDays(-1), _dateTime.GetType());
            Add("IsEqualTo", Args(_type), typeof(long), typeof(Type));
            Add("IsGreaterThan", Args(_integer), _integer - 1, _integer.GetType());
            Add("IsGreaterThan", Args(_decimal), _decimal - 0.01m, _decimal.GetType());
            Add("IsLessThan", Args(_decimal), _decimal + 0.01m, _decimal.GetType());
            Add("IsLessThan", Args(_integer), _integer + 1, _integer.GetType());
            Add("IsIn", Args(_strings.OfType<object?>().ToArray()), "Nope", _string.GetType());
            Add("LengthIs", Args(2), _string, _string.GetType());
            Add("HasAtMost", Args(2), _strings2Strings, _strings2Strings.GetType());
            Add("HasAtMost", Args(2), _strings, _strings.GetType());
            Add("LengthIsAtMost", Args(2), _string, _string.GetType());
            Add("HasAtLeast", Args(99), _strings2Strings, _strings2Strings.GetType());
            Add("HasAtLeast", Args(99), _strings, _strings.GetType());
            Add("LengthIsAtLeast", Args(99), _string, _string.GetType());
        }
    }

    [Theory]
    [ClassData(typeof(TestDataForValidateFailure))]
    public void Validate_WithInvalidSubject_ReturnsFailure(
        string validatorName,
        object?[] args,
        object invalidValue,
        Type valueType) {
        var validator = ValidationCommandFactory.For(valueType, "Attribute").Create(validatorName, args);
        var invalidResult = validator.Validate(invalidValue);

        invalidResult.IsInvalid.Should().BeTrue();
    }

    private class TestCommand() : ValidationCommand("Source");

    [Fact]
    public void Validate_WithDefaultCommand_ReturnsSuccess() {
        var command = new TestCommand();

        var result = command.Validate("Value");

        result.IsSuccess.Should().BeTrue();
    }
}
 
